import * as torii from '@dojoengine/torii-wasm';
export { torii };
import { A as AchievementsPage, P as PlayerAchievementsPage, c as AggregationsPage, d as ActivitiesPage, e as SqlQueryResponse, S as SchemaType, b as SDKConfig, f as SDK } from './index.d-_SKF3ZMA.js';
export { g as AchievementData, h as AchievementProgressionData, i as AchievementProgressionSubscriptionQuery, j as AchievementProgressionView, k as AchievementQueryInput, l as AchievementTaskData, m as ActivityEntry, n as ActivityQueryInput, o as ActivitySubscriptionQuery, p as AggregationEntryView, q as AggregationQueryInput, r as AndComposeClause, s as AttributesFilter, C as ClauseBuilder, t as ContractType, G as GetParams, u as GetTokenBalanceRequest, v as GetTokenContracts, w as GetTokenRequest, x as GetTokenTransferRequest, H as HashedKeysClause, y as HistoricalToriiQueryBuilder, z as HistoricalToriiQueryBuilderOptions, K as KeysClause, M as MemberClause, B as MemberValueParam, D as MergedModels, N as NO_ACCOUNT, E as NO_IDENTITY, F as NO_SIGNER, O as OrComposeClause, I as Pagination, J as ParsedEntity, L as PlayerAchievementEntryData, Q as PlayerAchievementEntryView, R as PlayerAchievementProgressData, T as PlayerAchievementQueryInput, U as PlayerAchievementStatsData, V as SDKClientConfig, W as SDKFunctionOptions, X as SqlQueryIntegerValue, Y as SqlQueryValue, a as StandardizedQueryResult, Z as SubscribeAchievementProgressionRequest, _ as SubscribeParams, $ as SubscribeResponse, a0 as SubscribeTokenBalanceRequest, a1 as SubscribeTokenRequest, a2 as SubscribeTokenTransferRequest, a3 as SubscriptionCallback, a4 as SubscriptionCallbackArgs, a5 as TaskProgressData, a6 as ToriiQueryBuilder, a7 as ToriiResponse, a8 as UNDEFINED_CLAUSE, a9 as UnionOfModelData, aa as UpdateAchievementProgressionSubscriptionRequest, ab as UpdateTokenBalanceSubscriptionRequest, ac as UpdateTokenTransferSubscriptionRequest, ad as convertToPrimitive, ae as deepMerge, af as defaultAchievementProgression, ag as defaultToken, ah as defaultTokenBalance, ai as defaultTokenTransfer, aj as defaultToriiPagination, ak as generateTypedData, al as getAchievements, am as getModel, an as getModelByEntityId, ao as getPlayerAchievements, ap as getTokenBalances, aq as getTokenContracts, ar as getTokenTransfers, as as getTokens, at as isCairoCustomEnum, au as isCairoOption, av as mergeCairoCustomEnum, aw as mergeCairoOption, ax as onAchievementProgressionUpdated, ay as onTokenBalanceUpdated, az as onTokenTransferUpdated, aA as onTokenUpdated, aB as parseEntities, aC as parseTokenRequest, aD as safeCallback, aE as subscribeQueryModelCallback, aF as subscribeToken, aG as subscribeTokenBalance, aH as subscribeTokenTransfer, aI as toAchievementQuery, aJ as toPlayerAchievementQuery, aK as updateAchievementProgressionSubscription, aL as updateTokenBalanceSubscription, aM as updateTokenTransferSubscription } from './index.d-_SKF3ZMA.js';
import * as torii$1 from '@dojoengine/torii-wasm/types';
import '@dojoengine/torii-wasm/node';
import 'starknet';
import 'neverthrow';

interface GrpcClientInterface {
    getEntities(query: torii$1.Query): Promise<torii$1.Entities>;
    onEntityUpdated(clause: torii$1.Clause | null | undefined, world_addresses: string[] | null | undefined, callback: Function): Promise<torii$1.Subscription>;
    updateEntitySubscription(subscription: torii$1.Subscription, clauses?: torii$1.Clause | null, world_addresses?: string[] | null): Promise<void>;
    getEventMessages(query: torii$1.Query): Promise<torii$1.Entities>;
    onEventMessageUpdated(clause: torii$1.Clause | null | undefined, world_addresses: string[] | null | undefined, callback: Function): Promise<torii$1.Subscription>;
    updateEventMessageSubscription(subscription: torii$1.Subscription, clauses?: torii$1.Clause | null, world_addresses?: string[] | null): Promise<void>;
    getTokens(params: {
        contract_addresses?: string[];
        token_ids?: any[];
        pagination?: torii$1.Pagination;
    }): Promise<torii$1.Tokens>;
    getTokenContracts(params: {
        contract_addresses?: string[];
        contract_types?: torii$1.ContractType[];
        pagination?: torii$1.Pagination;
    }): Promise<torii$1.TokenContracts>;
    getTokenBalances(params: {
        contract_addresses?: string[];
        account_addresses?: string[];
        token_ids?: any[];
        pagination?: torii$1.Pagination;
    }): Promise<torii$1.TokenBalances>;
    getTokenTransfers(params: {
        contract_addresses?: string[];
        account_addresses?: string[];
        token_ids?: any[];
        pagination?: torii$1.Pagination;
    }): Promise<torii$1.TokenTransfers>;
    onTokenBalanceUpdated(contractAddresses: string[], accountAddresses: string[], tokenIds: any[], callback: (res: torii$1.TokenBalance) => void): Promise<torii$1.Subscription>;
    onTokenUpdated(contractAddresses: string[], tokenIds: any[], callback: (res: torii$1.Token) => void): Promise<torii$1.Subscription>;
    onTokenTransferUpdated(contractAddresses: string[], accountAddresses: string[], tokenIds: any[], callback: (res: torii$1.TokenTransfer) => void): Promise<torii$1.Subscription>;
    updateTokenBalanceSubscription(subscription: torii$1.Subscription, contract_addresses: string[], account_addresses: string[], token_ids: any[]): Promise<void>;
    updateTokenTransferSubscription(subscription: torii$1.Subscription, contract_addresses: string[], account_addresses: string[], token_ids: any[]): Promise<void>;
    getAchievements(params: torii$1.AchievementQuery): Promise<AchievementsPage>;
    getPlayerAchievements(params: torii$1.PlayerAchievementQuery): Promise<PlayerAchievementsPage>;
    onAchievementProgressionUpdated(world_addresses: string[] | null | undefined, namespaces: string[] | null | undefined, player_addresses: string[] | null | undefined, achievement_ids: string[] | null | undefined, callback: Function): Promise<torii$1.Subscription>;
    updateAchievementProgressionSubscription(subscription: torii$1.Subscription, world_addresses: string[], namespaces: string[], player_addresses: string[], achievement_ids: string[]): Promise<void>;
    publishMessage(message: torii$1.Message): Promise<string>;
    publishMessageBatch(messages: torii$1.Message[]): Promise<string[]>;
    getControllers(params: {
        contract_addresses?: string[];
        usernames?: string[];
        pagination?: torii$1.Pagination;
    }): Promise<torii$1.Controllers>;
    getAggregations(query: torii$1.AggregationQuery): Promise<AggregationsPage>;
    onAggregationUpdated(aggregator_ids: string[] | null | undefined, entity_ids: string[] | null | undefined, callback: Function): Promise<torii$1.Subscription>;
    updateAggregationSubscription(subscription: torii$1.Subscription, aggregator_ids: string[], entity_ids: string[]): Promise<void>;
    getActivities(query: torii$1.ActivityQuery): Promise<ActivitiesPage>;
    onActivityUpdated(world_addresses: string[] | null | undefined, namespaces: string[] | null | undefined, caller_addresses: string[] | null | undefined, callback: Function): Promise<torii$1.Subscription>;
    updateActivitySubscription(subscription: torii$1.Subscription, world_addresses: string[], namespaces: string[], caller_addresses: string[]): Promise<void>;
    executeSql(query: string): Promise<SqlQueryResponse>;
    getWorlds(worldAddresses?: string[]): Promise<any[]>;
}

interface InitGrpcOptions {
    toriiUrl?: string;
    worldAddress: string;
}
declare function initGrpc(options: InitGrpcOptions): GrpcClientInterface;

/**
 * Creates a new Torii client instance.
 *
 * @param {torii.ClientConfig} config - The configuration object for the Torii client.
 * @returns {Promise<torii.ToriiClient>} - A promise that resolves to the Torii client instance.
 */
declare function createClient(config: torii.ClientConfig): Promise<torii.ToriiClient>;
declare const defaultClientConfig: Partial<torii.ClientConfig>;
/**
 * Initializes the SDK for web environment with the provided configuration and schema.
 *
 * @template T - The schema type.
 * @param {SDKConfig} options - The configuration object for the SDK.
 * @returns {Promise<SDK<T>>} - A promise that resolves to the initialized SDK instance.
 *
 * @example
 * ```typescript
 * import { init } from "@dojoengine/sdk";
 * import { schema } from "./models.gen";
 *
 * const sdk = await init<typeof schema>({
 *     client: {
 *         worldAddress: "0x...",
 *         toriiUrl: "http://localhost:8080",
 *     },
 *     domain: {
 *         name: "MyApp",
 *         version: "1.0.0",
 *         chainId: "SN_MAIN",
 *     },
 * });
 * ```
 */
declare function init<T extends SchemaType>(options: SDKConfig & {
    grpcClient?: GrpcClientInterface;
}): Promise<SDK<T>>;

export { AchievementsPage, ActivitiesPage, AggregationsPage, type GrpcClientInterface, type InitGrpcOptions, PlayerAchievementsPage, SDK, SDKConfig, SchemaType, SqlQueryResponse, createClient, defaultClientConfig, init, initGrpc };
