import * as _protobuf_ts_runtime from '@protobuf-ts/runtime';
import { MessageType, PartialMessage, IBinaryReader, BinaryReadOptions, IBinaryWriter, BinaryWriteOptions } from '@protobuf-ts/runtime';
import * as _protobuf_ts_runtime_rpc from '@protobuf-ts/runtime-rpc';
import { ServiceType, RpcOptions, ServerStreamingCall, UnaryCall, ServiceInfo, RpcTransport } from '@protobuf-ts/runtime-rpc';

declare class EnumOption$Type extends MessageType<EnumOption> {
    constructor();
    create(value?: PartialMessage<EnumOption>): EnumOption;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumOption): EnumOption;
    internalBinaryWrite(message: EnumOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.EnumOption
 */
interface EnumOption {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: types.Ty ty = 2
     */
    ty?: Ty$1;
}
/**
 * @generated MessageType for protobuf message types.EnumOption
 */
declare const EnumOption: EnumOption$Type;
declare class Enum$Type extends MessageType<Enum> {
    constructor();
    create(value?: PartialMessage<Enum>): Enum;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enum): Enum;
    internalBinaryWrite(message: Enum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Enum
 */
interface Enum {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 option = 2
     */
    option: number;
    /**
     * @generated from protobuf field: repeated types.EnumOption options = 3
     */
    options: EnumOption[];
}
/**
 * @generated MessageType for protobuf message types.Enum
 */
declare const Enum: Enum$Type;
declare class Primitive$Type extends MessageType<Primitive$1> {
    constructor();
    create(value?: PartialMessage<Primitive$1>): Primitive$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Primitive$1): Primitive$1;
    internalBinaryWrite(message: Primitive$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Primitive
 */
interface Primitive$1 {
    /**
     * @generated from protobuf oneof: primitive_type
     */
    primitive_type: {
        oneofKind: "i8";
        /**
         * @generated from protobuf field: int32 i8 = 1
         */
        i8: number;
    } | {
        oneofKind: "i16";
        /**
         * @generated from protobuf field: int32 i16 = 2
         */
        i16: number;
    } | {
        oneofKind: "i32";
        /**
         * @generated from protobuf field: int32 i32 = 3
         */
        i32: number;
    } | {
        oneofKind: "i64";
        /**
         * @generated from protobuf field: int64 i64 = 4
         */
        i64: bigint;
    } | {
        oneofKind: "i128";
        /**
         * @generated from protobuf field: bytes i128 = 5
         */
        i128: Uint8Array;
    } | {
        oneofKind: "u8";
        /**
         * @generated from protobuf field: uint32 u8 = 6
         */
        u8: number;
    } | {
        oneofKind: "u16";
        /**
         * @generated from protobuf field: uint32 u16 = 7
         */
        u16: number;
    } | {
        oneofKind: "u32";
        /**
         * @generated from protobuf field: uint32 u32 = 8
         */
        u32: number;
    } | {
        oneofKind: "u64";
        /**
         * @generated from protobuf field: uint64 u64 = 9
         */
        u64: bigint;
    } | {
        oneofKind: "u128";
        /**
         * @generated from protobuf field: bytes u128 = 10
         */
        u128: Uint8Array;
    } | {
        oneofKind: "u256";
        /**
         * @generated from protobuf field: bytes u256 = 11
         */
        u256: Uint8Array;
    } | {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: bool bool = 12
         */
        bool: boolean;
    } | {
        oneofKind: "felt252";
        /**
         * @generated from protobuf field: bytes felt252 = 13
         */
        felt252: Uint8Array;
    } | {
        oneofKind: "class_hash";
        /**
         * @generated from protobuf field: bytes class_hash = 14
         */
        class_hash: Uint8Array;
    } | {
        oneofKind: "contract_address";
        /**
         * @generated from protobuf field: bytes contract_address = 15
         */
        contract_address: Uint8Array;
    } | {
        oneofKind: "eth_address";
        /**
         * @generated from protobuf field: bytes eth_address = 16
         */
        eth_address: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.Primitive
 */
declare const Primitive$1: Primitive$Type;
declare class Struct$Type extends MessageType<Struct> {
    constructor();
    create(value?: PartialMessage<Struct>): Struct;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Struct): Struct;
    internalBinaryWrite(message: Struct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Struct
 */
interface Struct {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: repeated types.Member children = 2
     */
    children: Member[];
}
/**
 * @generated MessageType for protobuf message types.Struct
 */
declare const Struct: Struct$Type;
declare class Array$$Type extends MessageType<Array$> {
    constructor();
    create(value?: PartialMessage<Array$>): Array$;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Array$): Array$;
    internalBinaryWrite(message: Array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Array
 */
interface Array$ {
    /**
     * @generated from protobuf field: repeated types.Ty children = 1
     */
    children: Ty$1[];
}
/**
 * @generated MessageType for protobuf message types.Array
 */
declare const Array$: Array$$Type;
declare class FixedSizeArray$Type extends MessageType<FixedSizeArray$1> {
    constructor();
    create(value?: PartialMessage<FixedSizeArray$1>): FixedSizeArray$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FixedSizeArray$1): FixedSizeArray$1;
    internalBinaryWrite(message: FixedSizeArray$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.FixedSizeArray
 */
interface FixedSizeArray$1 {
    /**
     * @generated from protobuf field: repeated types.Ty children = 1
     */
    children: Ty$1[];
    /**
     * @generated from protobuf field: uint32 size = 2
     */
    size: number;
}
/**
 * @generated MessageType for protobuf message types.FixedSizeArray
 */
declare const FixedSizeArray$1: FixedSizeArray$Type;
declare class Ty$Type extends MessageType<Ty$1> {
    constructor();
    create(value?: PartialMessage<Ty$1>): Ty$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ty$1): Ty$1;
    internalBinaryWrite(message: Ty$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Ty
 */
interface Ty$1 {
    /**
     * @generated from protobuf oneof: ty_type
     */
    ty_type: {
        oneofKind: "primitive";
        /**
         * @generated from protobuf field: types.Primitive primitive = 2
         */
        primitive: Primitive$1;
    } | {
        oneofKind: "enum";
        /**
         * @generated from protobuf field: types.Enum enum = 3
         */
        enum: Enum;
    } | {
        oneofKind: "struct";
        /**
         * @generated from protobuf field: types.Struct struct = 4
         */
        struct: Struct;
    } | {
        oneofKind: "tuple";
        /**
         * @generated from protobuf field: types.Array tuple = 5
         */
        tuple: Array$;
    } | {
        oneofKind: "array";
        /**
         * @generated from protobuf field: types.Array array = 6
         */
        array: Array$;
    } | {
        oneofKind: "bytearray";
        /**
         * @generated from protobuf field: string bytearray = 7
         */
        bytearray: string;
    } | {
        oneofKind: "fixed_size_array";
        /**
         * @generated from protobuf field: types.FixedSizeArray fixed_size_array = 8
         */
        fixed_size_array: FixedSizeArray$1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.Ty
 */
declare const Ty$1: Ty$Type;
declare class Member$Type extends MessageType<Member> {
    constructor();
    create(value?: PartialMessage<Member>): Member;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Member): Member;
    internalBinaryWrite(message: Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Member
 */
interface Member {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: types.Ty ty = 2
     */
    ty?: Ty$1;
    /**
     * @generated from protobuf field: bool key = 3
     */
    key: boolean;
}
/**
 * @generated MessageType for protobuf message types.Member
 */
declare const Member: Member$Type;

/**
 * @generated from protobuf enum types.PatternMatching
 */
declare enum PatternMatching$1 {
    /**
     * @generated from protobuf enum value: FixedLen = 0;
     */
    FixedLen = 0,
    /**
     * @generated from protobuf enum value: VariableLen = 1;
     */
    VariableLen = 1
}
/**
 * @generated from protobuf enum types.LogicalOperator
 */
declare enum LogicalOperator$1 {
    /**
     * @generated from protobuf enum value: AND = 0;
     */
    AND = 0,
    /**
     * @generated from protobuf enum value: OR = 1;
     */
    OR = 1
}
/**
 * @generated from protobuf enum types.ComparisonOperator
 */
declare enum ComparisonOperator$1 {
    /**
     * @generated from protobuf enum value: EQ = 0;
     */
    EQ = 0,
    /**
     * @generated from protobuf enum value: NEQ = 1;
     */
    NEQ = 1,
    /**
     * @generated from protobuf enum value: GT = 2;
     */
    GT = 2,
    /**
     * @generated from protobuf enum value: GTE = 3;
     */
    GTE = 3,
    /**
     * @generated from protobuf enum value: LT = 4;
     */
    LT = 4,
    /**
     * @generated from protobuf enum value: LTE = 5;
     */
    LTE = 5,
    /**
     * @generated from protobuf enum value: IN = 6;
     */
    IN = 6,
    /**
     * @generated from protobuf enum value: NOT_IN = 7;
     */
    NOT_IN = 7,
    /**
     * Array-specific operators
     *
     * Array contains value
     *
     * @generated from protobuf enum value: CONTAINS = 8;
     */
    CONTAINS = 8,
    /**
     * Array contains all values
     *
     * @generated from protobuf enum value: CONTAINS_ALL = 9;
     */
    CONTAINS_ALL = 9,
    /**
     * Array contains any of the values
     *
     * @generated from protobuf enum value: CONTAINS_ANY = 10;
     */
    CONTAINS_ANY = 10,
    /**
     * Array length equals
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_EQ = 11;
     */
    ARRAY_LENGTH_EQ = 11,
    /**
     * Array length greater than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_GT = 12;
     */
    ARRAY_LENGTH_GT = 12,
    /**
     * Array length less than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_LT = 13;
     */
    ARRAY_LENGTH_LT = 13
}
/**
 * @generated from protobuf enum types.OrderDirection
 */
declare enum OrderDirection$1 {
    /**
     * @generated from protobuf enum value: ASC = 0;
     */
    ASC = 0,
    /**
     * @generated from protobuf enum value: DESC = 1;
     */
    DESC = 1
}
/**
 * @generated from protobuf enum types.PaginationDirection
 */
declare enum PaginationDirection$1 {
    /**
     * @generated from protobuf enum value: FORWARD = 0;
     */
    FORWARD = 0,
    /**
     * @generated from protobuf enum value: BACKWARD = 1;
     */
    BACKWARD = 1
}
/**
 * @generated from protobuf enum types.CallType
 */
declare enum CallType$1 {
    /**
     * @generated from protobuf enum value: EXECUTE = 0;
     */
    EXECUTE = 0,
    /**
     * @generated from protobuf enum value: EXECUTE_FROM_OUTSIDE = 1;
     */
    EXECUTE_FROM_OUTSIDE = 1
}
/**
 * @generated from protobuf enum types.ContractType
 */
declare enum ContractType$1 {
    /**
     * @generated from protobuf enum value: WORLD = 0;
     */
    WORLD = 0,
    /**
     * @generated from protobuf enum value: ERC20 = 1;
     */
    ERC20 = 1,
    /**
     * @generated from protobuf enum value: ERC721 = 2;
     */
    ERC721 = 2,
    /**
     * @generated from protobuf enum value: ERC1155 = 3;
     */
    ERC1155 = 3,
    /**
     * @generated from protobuf enum value: UDC = 4;
     */
    UDC = 4,
    /**
     * @generated from protobuf enum value: OTHER = 5;
     */
    OTHER = 5
}
declare class World$Type extends MessageType<World$1> {
    constructor();
    create(value?: PartialMessage<World$1>): World$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: World$1): World$1;
    internalBinaryWrite(message: World$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.World
 */
interface World$1 {
    /**
     * The hex-encoded address of the world.
     *
     * @generated from protobuf field: string world_address = 1
     */
    world_address: string;
    /**
     * A list of metadata for all registered components in the world.
     *
     * @generated from protobuf field: repeated types.Model models = 2
     */
    models: Model$1[];
}
/**
 * @generated MessageType for protobuf message types.World
 */
declare const World$1: World$Type;
declare class Model$Type extends MessageType<Model$1> {
    constructor();
    create(value?: PartialMessage<Model$1>): Model$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model$1): Model$1;
    internalBinaryWrite(message: Model$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Model
 */
interface Model$1 {
    /**
     * Model selector
     *
     * @generated from protobuf field: bytes selector = 1
     */
    selector: Uint8Array;
    /**
     * Model namespace
     *
     * @generated from protobuf field: string namespace = 2
     */
    namespace: string;
    /**
     * Model name
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * Model size when it is packed for storage
     *
     * @generated from protobuf field: uint32 packed_size = 4
     */
    packed_size: number;
    /**
     * Model size when it is unpacked
     *
     * @generated from protobuf field: uint32 unpacked_size = 5
     */
    unpacked_size: number;
    /**
     * felt bytes of the class hash of the component
     *
     * @generated from protobuf field: bytes class_hash = 6
     */
    class_hash: Uint8Array;
    /**
     * The layout of the component in bytes
     *
     * @generated from protobuf field: bytes layout = 7
     */
    layout: Uint8Array;
    /**
     * The schema of the component serialized in bytes (for simplicity sake)
     *
     * @generated from protobuf field: bytes schema = 8
     */
    schema: Uint8Array;
    /**
     * felt bytes of the contract address of the component
     *
     * @generated from protobuf field: bytes contract_address = 9
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: bool use_legacy_store = 10
     */
    use_legacy_store: boolean;
    /**
     * The world address of the model
     *
     * @generated from protobuf field: bytes world_address = 11
     */
    world_address: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.Model
 */
declare const Model$1: Model$Type;
declare class Entity$Type extends MessageType<Entity$1> {
    constructor();
    create(value?: PartialMessage<Entity$1>): Entity$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity$1): Entity$1;
    internalBinaryWrite(message: Entity$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Entity
 */
interface Entity$1 {
    /**
     * The entity's hashed keys
     *
     * @generated from protobuf field: bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array;
    /**
     * Models of the entity
     *
     * @generated from protobuf field: repeated types.Struct models = 2
     */
    models: Struct[];
    /**
     * Created at timestamp
     *
     * @generated from protobuf field: uint64 created_at = 3
     */
    created_at: bigint;
    /**
     * Updated at timestamp
     *
     * @generated from protobuf field: uint64 updated_at = 4
     */
    updated_at: bigint;
    /**
     * Block timestamp when the entity was updated
     *
     * @generated from protobuf field: uint64 executed_at = 5
     */
    executed_at: bigint;
    /**
     * The world address of the entity
     *
     * @generated from protobuf field: bytes world_address = 6
     */
    world_address: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.Entity
 */
declare const Entity$1: Entity$Type;
declare class Event$Type extends MessageType<Event> {
    constructor();
    create(value?: PartialMessage<Event>): Event;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event;
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Event
 */
interface Event {
    /**
     * The event's keys
     *
     * @generated from protobuf field: repeated bytes keys = 1
     */
    keys: Uint8Array[];
    /**
     * Data of the event
     *
     * @generated from protobuf field: repeated bytes data = 2
     */
    data: Uint8Array[];
    /**
     * event's transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 3
     */
    transaction_hash: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.Event
 */
declare const Event: Event$Type;
declare class Query$Type extends MessageType<Query$1> {
    constructor();
    create(value?: PartialMessage<Query$1>): Query$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query$1): Query$1;
    internalBinaryWrite(message: Query$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Query
 */
interface Query$1 {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause$1;
    /**
     * @generated from protobuf field: bool no_hashed_keys = 2
     */
    no_hashed_keys: boolean;
    /**
     * @generated from protobuf field: repeated string models = 3
     */
    models: string[];
    /**
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
    /**
     * @generated from protobuf field: bool historical = 5
     */
    historical: boolean;
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 6
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message types.Query
 */
declare const Query$1: Query$Type;
declare class EventQuery$Type extends MessageType<EventQuery> {
    constructor();
    create(value?: PartialMessage<EventQuery>): EventQuery;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventQuery): EventQuery;
    internalBinaryWrite(message: EventQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.EventQuery
 */
interface EventQuery {
    /**
     * @generated from protobuf field: types.KeysClause keys = 1
     */
    keys?: KeysClause$1;
    /**
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.EventQuery
 */
declare const EventQuery: EventQuery$Type;
declare class Clause$Type extends MessageType<Clause$1> {
    constructor();
    create(value?: PartialMessage<Clause$1>): Clause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clause$1): Clause$1;
    internalBinaryWrite(message: Clause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Clause
 */
interface Clause$1 {
    /**
     * @generated from protobuf oneof: clause_type
     */
    clause_type: {
        oneofKind: "hashed_keys";
        /**
         * @generated from protobuf field: types.HashedKeysClause hashed_keys = 1
         */
        hashed_keys: HashedKeysClause;
    } | {
        oneofKind: "keys";
        /**
         * @generated from protobuf field: types.KeysClause keys = 2
         */
        keys: KeysClause$1;
    } | {
        oneofKind: "member";
        /**
         * @generated from protobuf field: types.MemberClause member = 3
         */
        member: MemberClause$1;
    } | {
        oneofKind: "composite";
        /**
         * @generated from protobuf field: types.CompositeClause composite = 4
         */
        composite: CompositeClause$1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.Clause
 */
declare const Clause$1: Clause$Type;
declare class KeysClause$Type extends MessageType<KeysClause$1> {
    constructor();
    create(value?: PartialMessage<KeysClause$1>): KeysClause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeysClause$1): KeysClause$1;
    internalBinaryWrite(message: KeysClause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.KeysClause
 */
interface KeysClause$1 {
    /**
     * @generated from protobuf field: repeated bytes keys = 2
     */
    keys: Uint8Array[];
    /**
     * @generated from protobuf field: types.PatternMatching pattern_matching = 3
     */
    pattern_matching: PatternMatching$1;
    /**
     * @generated from protobuf field: repeated string models = 4
     */
    models: string[];
}
/**
 * @generated MessageType for protobuf message types.KeysClause
 */
declare const KeysClause$1: KeysClause$Type;
declare class HashedKeysClause$Type extends MessageType<HashedKeysClause> {
    constructor();
    create(value?: PartialMessage<HashedKeysClause>): HashedKeysClause;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HashedKeysClause): HashedKeysClause;
    internalBinaryWrite(message: HashedKeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.HashedKeysClause
 */
interface HashedKeysClause {
    /**
     * @generated from protobuf field: repeated bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message types.HashedKeysClause
 */
declare const HashedKeysClause: HashedKeysClause$Type;
declare class MemberValue$Type extends MessageType<MemberValue$1> {
    constructor();
    create(value?: PartialMessage<MemberValue$1>): MemberValue$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValue$1): MemberValue$1;
    internalBinaryWrite(message: MemberValue$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.MemberValue
 */
interface MemberValue$1 {
    /**
     * @generated from protobuf oneof: value_type
     */
    value_type: {
        oneofKind: "primitive";
        /**
         * @generated from protobuf field: types.Primitive primitive = 1
         */
        primitive: Primitive$1;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 2
         */
        string: string;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: types.MemberValueList list = 3
         */
        list: MemberValueList;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.MemberValue
 */
declare const MemberValue$1: MemberValue$Type;
declare class MemberValueList$Type extends MessageType<MemberValueList> {
    constructor();
    create(value?: PartialMessage<MemberValueList>): MemberValueList;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValueList): MemberValueList;
    internalBinaryWrite(message: MemberValueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.MemberValueList
 */
interface MemberValueList {
    /**
     * @generated from protobuf field: repeated types.MemberValue values = 1
     */
    values: MemberValue$1[];
}
/**
 * @generated MessageType for protobuf message types.MemberValueList
 */
declare const MemberValueList: MemberValueList$Type;
declare class MemberClause$Type extends MessageType<MemberClause$1> {
    constructor();
    create(value?: PartialMessage<MemberClause$1>): MemberClause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberClause$1): MemberClause$1;
    internalBinaryWrite(message: MemberClause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.MemberClause
 */
interface MemberClause$1 {
    /**
     * @generated from protobuf field: string model = 2
     */
    model: string;
    /**
     * @generated from protobuf field: string member = 3
     */
    member: string;
    /**
     * @generated from protobuf field: types.ComparisonOperator operator = 4
     */
    operator: ComparisonOperator$1;
    /**
     * @generated from protobuf field: types.MemberValue value = 5
     */
    value?: MemberValue$1;
}
/**
 * @generated MessageType for protobuf message types.MemberClause
 */
declare const MemberClause$1: MemberClause$Type;
declare class CompositeClause$Type extends MessageType<CompositeClause$1> {
    constructor();
    create(value?: PartialMessage<CompositeClause$1>): CompositeClause$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompositeClause$1): CompositeClause$1;
    internalBinaryWrite(message: CompositeClause$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.CompositeClause
 */
interface CompositeClause$1 {
    /**
     * @generated from protobuf field: types.LogicalOperator operator = 3
     */
    operator: LogicalOperator$1;
    /**
     * @generated from protobuf field: repeated types.Clause clauses = 4
     */
    clauses: Clause$1[];
}
/**
 * @generated MessageType for protobuf message types.CompositeClause
 */
declare const CompositeClause$1: CompositeClause$Type;
declare class Token$Type extends MessageType<Token$1> {
    constructor();
    create(value?: PartialMessage<Token$1>): Token$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token$1): Token$1;
    internalBinaryWrite(message: Token$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Token
 */
interface Token$1 {
    /**
     * @generated from protobuf field: optional bytes token_id = 1
     */
    token_id?: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * @generated from protobuf field: bytes metadata = 6
     */
    metadata: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes total_supply = 7
     */
    total_supply?: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.Token
 */
declare const Token$1: Token$Type;
declare class TokenBalance$Type extends MessageType<TokenBalance$1> {
    constructor();
    create(value?: PartialMessage<TokenBalance$1>): TokenBalance$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalance$1): TokenBalance$1;
    internalBinaryWrite(message: TokenBalance$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TokenBalance
 */
interface TokenBalance$1 {
    /**
     * @generated from protobuf field: bytes balance = 1
     */
    balance: Uint8Array;
    /**
     * @generated from protobuf field: bytes account_address = 2
     */
    account_address: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 3
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes token_id = 4
     */
    token_id?: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.TokenBalance
 */
declare const TokenBalance$1: TokenBalance$Type;
declare class OrderBy$Type extends MessageType<OrderBy$1> {
    constructor();
    create(value?: PartialMessage<OrderBy$1>): OrderBy$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBy$1): OrderBy$1;
    internalBinaryWrite(message: OrderBy$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.OrderBy
 */
interface OrderBy$1 {
    /**
     * @generated from protobuf field: string field = 1
     */
    field: string;
    /**
     * @generated from protobuf field: types.OrderDirection direction = 2
     */
    direction: OrderDirection$1;
}
/**
 * @generated MessageType for protobuf message types.OrderBy
 */
declare const OrderBy$1: OrderBy$Type;
declare class Controller$Type extends MessageType<Controller$1> {
    constructor();
    create(value?: PartialMessage<Controller$1>): Controller$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Controller$1): Controller$1;
    internalBinaryWrite(message: Controller$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Controller
 */
interface Controller$1 {
    /**
     * @generated from protobuf field: bytes address = 1
     */
    address: Uint8Array;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: uint64 deployed_at_timestamp = 3
     */
    deployed_at_timestamp: bigint;
}
/**
 * @generated MessageType for protobuf message types.Controller
 */
declare const Controller$1: Controller$Type;
declare class Pagination$Type extends MessageType<Pagination$1> {
    constructor();
    create(value?: PartialMessage<Pagination$1>): Pagination$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination$1): Pagination$1;
    internalBinaryWrite(message: Pagination$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Pagination
 */
interface Pagination$1 {
    /**
     * @generated from protobuf field: string cursor = 1
     */
    cursor: string;
    /**
     * @generated from protobuf field: uint32 limit = 2
     */
    limit: number;
    /**
     * @generated from protobuf field: types.PaginationDirection direction = 3
     */
    direction: PaginationDirection$1;
    /**
     * @generated from protobuf field: repeated types.OrderBy order_by = 4
     */
    order_by: OrderBy$1[];
}
/**
 * @generated MessageType for protobuf message types.Pagination
 */
declare const Pagination$1: Pagination$Type;
declare class ControllerQuery$Type extends MessageType<ControllerQuery$1> {
    constructor();
    create(value?: PartialMessage<ControllerQuery$1>): ControllerQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControllerQuery$1): ControllerQuery$1;
    internalBinaryWrite(message: ControllerQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.ControllerQuery
 */
interface ControllerQuery$1 {
    /**
     * The list of contract addresses to retrieve controllers for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of usernames to retrieve controllers for
     *
     * @generated from protobuf field: repeated string usernames = 2
     */
    usernames: string[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.ControllerQuery
 */
declare const ControllerQuery$1: ControllerQuery$Type;
declare class TokenAttributeFilter$Type extends MessageType<TokenAttributeFilter> {
    constructor();
    create(value?: PartialMessage<TokenAttributeFilter>): TokenAttributeFilter;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenAttributeFilter): TokenAttributeFilter;
    internalBinaryWrite(message: TokenAttributeFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Token attribute filter for filtering tokens by their metadata attributes
 *
 * @generated from protobuf message types.TokenAttributeFilter
 */
interface TokenAttributeFilter {
    /**
     * The name of the trait/attribute to filter by
     *
     * @generated from protobuf field: string trait_name = 1
     */
    trait_name: string;
    /**
     * The value of the trait/attribute to filter by
     *
     * @generated from protobuf field: string trait_value = 2
     */
    trait_value: string;
}
/**
 * @generated MessageType for protobuf message types.TokenAttributeFilter
 */
declare const TokenAttributeFilter: TokenAttributeFilter$Type;
declare class TokenQuery$Type extends MessageType<TokenQuery$1> {
    constructor();
    create(value?: PartialMessage<TokenQuery$1>): TokenQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenQuery$1): TokenQuery$1;
    internalBinaryWrite(message: TokenQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message types.TokenQuery
 */
interface TokenQuery$1 {
    /**
     * The list of contract addresses to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
    /**
     * The list of attribute filters to apply
     *
     * @generated from protobuf field: repeated types.TokenAttributeFilter attribute_filters = 3
     */
    attribute_filters: TokenAttributeFilter[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TokenQuery
 */
declare const TokenQuery$1: TokenQuery$Type;
declare class TokenBalanceQuery$Type extends MessageType<TokenBalanceQuery$1> {
    constructor();
    create(value?: PartialMessage<TokenBalanceQuery$1>): TokenBalanceQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalanceQuery$1): TokenBalanceQuery$1;
    internalBinaryWrite(message: TokenBalanceQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message types.TokenBalanceQuery
 */
interface TokenBalanceQuery$1 {
    /**
     * The account addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TokenBalanceQuery
 */
declare const TokenBalanceQuery$1: TokenBalanceQuery$Type;
declare class TokenContractQuery$Type extends MessageType<TokenContractQuery$1> {
    constructor();
    create(value?: PartialMessage<TokenContractQuery$1>): TokenContractQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenContractQuery$1): TokenContractQuery$1;
    internalBinaryWrite(message: TokenContractQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token contracts
 *
 * @generated from protobuf message types.TokenContractQuery
 */
interface TokenContractQuery$1 {
    /**
     * The list of contract addresses to retrieve token contracts for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of contract types to filter by
     *
     * @generated from protobuf field: repeated types.ContractType contract_types = 2
     */
    contract_types: ContractType$1[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TokenContractQuery
 */
declare const TokenContractQuery$1: TokenContractQuery$Type;
declare class TokenTransfer$Type extends MessageType<TokenTransfer$1> {
    constructor();
    create(value?: PartialMessage<TokenTransfer$1>): TokenTransfer$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTransfer$1): TokenTransfer$1;
    internalBinaryWrite(message: TokenTransfer$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A token transfer record
 *
 * @generated from protobuf message types.TokenTransfer
 */
interface TokenTransfer$1 {
    /**
     * Unique identifier for the transfer (event_id:token_id key)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Contract address of the token
     *
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * Sender address
     *
     * @generated from protobuf field: bytes from_address = 3
     */
    from_address: Uint8Array;
    /**
     * Recipient address
     *
     * @generated from protobuf field: bytes to_address = 4
     */
    to_address: Uint8Array;
    /**
     * Amount transferred (big-endian bytes)
     *
     * @generated from protobuf field: bytes amount = 5
     */
    amount: Uint8Array;
    /**
     * Token ID when applicable (ERC721/1155); omitted for ERC20
     *
     * @generated from protobuf field: optional bytes token_id = 6
     */
    token_id?: Uint8Array;
    /**
     * Executed at timestamp (seconds since epoch)
     *
     * @generated from protobuf field: uint64 executed_at = 7
     */
    executed_at: bigint;
    /**
     * Optional event id that originated this transfer
     *
     * @generated from protobuf field: optional string event_id = 8
     */
    event_id?: string;
}
/**
 * @generated MessageType for protobuf message types.TokenTransfer
 */
declare const TokenTransfer$1: TokenTransfer$Type;
declare class TokenTransferQuery$Type extends MessageType<TokenTransferQuery$1> {
    constructor();
    create(value?: PartialMessage<TokenTransferQuery$1>): TokenTransferQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTransferQuery$1): TokenTransferQuery$1;
    internalBinaryWrite(message: TokenTransferQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token transfers
 *
 * @generated from protobuf message types.TokenTransferQuery
 */
interface TokenTransferQuery$1 {
    /**
     * Filter by any of these account addresses (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * Filter by token contract addresses
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * Filter by token IDs (bytes of numeric id)
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TokenTransferQuery
 */
declare const TokenTransferQuery$1: TokenTransferQuery$Type;
declare class TransactionCall$Type extends MessageType<TransactionCall$1> {
    constructor();
    create(value?: PartialMessage<TransactionCall$1>): TransactionCall$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionCall$1): TransactionCall$1;
    internalBinaryWrite(message: TransactionCall$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TransactionCall
 */
interface TransactionCall$1 {
    /**
     * The contract address being called
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The function name being called
     *
     * @generated from protobuf field: string entrypoint = 2
     */
    entrypoint: string;
    /**
     * The calldata for the function call
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The type of call (EXECUTE, EXECUTE_FROM_OUTSIDE)
     *
     * @generated from protobuf field: types.CallType call_type = 4
     */
    call_type: CallType$1;
    /**
     * The address making the call
     *
     * @generated from protobuf field: bytes caller_address = 5
     */
    caller_address: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.TransactionCall
 */
declare const TransactionCall$1: TransactionCall$Type;
declare class Transaction$Type extends MessageType<Transaction$1> {
    constructor();
    create(value?: PartialMessage<Transaction$1>): Transaction$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction$1): Transaction$1;
    internalBinaryWrite(message: Transaction$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Transaction
 */
interface Transaction$1 {
    /**
     * The transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 1
     */
    transaction_hash: Uint8Array;
    /**
     * The sender address
     *
     * @generated from protobuf field: bytes sender_address = 2
     */
    sender_address: Uint8Array;
    /**
     * The transaction calldata
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The maximum fee for the transaction
     *
     * @generated from protobuf field: bytes max_fee = 4
     */
    max_fee: Uint8Array;
    /**
     * The transaction signature
     *
     * @generated from protobuf field: repeated bytes signature = 5
     */
    signature: Uint8Array[];
    /**
     * The transaction nonce
     *
     * @generated from protobuf field: bytes nonce = 6
     */
    nonce: Uint8Array;
    /**
     * The block number the transaction was included in
     *
     * @generated from protobuf field: uint64 block_number = 7
     */
    block_number: bigint;
    /**
     * The transaction type (INVOKE, L1_HANDLER, etc.)
     *
     * @generated from protobuf field: string transaction_type = 8
     */
    transaction_type: string;
    /**
     * The timestamp when the transaction was executed
     *
     * @generated from protobuf field: uint64 block_timestamp = 9
     */
    block_timestamp: bigint;
    /**
     * The parsed calls within the transaction
     *
     * @generated from protobuf field: repeated types.TransactionCall calls = 10
     */
    calls: TransactionCall$1[];
    /**
     * The unique models associated with this transaction
     *
     * @generated from protobuf field: repeated bytes unique_models = 11
     */
    unique_models: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message types.Transaction
 */
declare const Transaction$1: Transaction$Type;
declare class TransactionFilter$Type extends MessageType<TransactionFilter$1> {
    constructor();
    create(value?: PartialMessage<TransactionFilter$1>): TransactionFilter$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionFilter$1): TransactionFilter$1;
    internalBinaryWrite(message: TransactionFilter$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TransactionFilter
 */
interface TransactionFilter$1 {
    /**
     * The list of transaction hashes to retrieve
     *
     * @generated from protobuf field: repeated bytes transaction_hashes = 1
     */
    transaction_hashes: Uint8Array[];
    /**
     * The list of caller addresses to filter by
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 2
     */
    caller_addresses: Uint8Array[];
    /**
     * The list of contract addresses to filter by (calls made to these contracts)
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 3
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of entrypoints to filter by
     *
     * @generated from protobuf field: repeated string entrypoints = 4
     */
    entrypoints: string[];
    /**
     * The list of model selectors to filter by
     *
     * @generated from protobuf field: repeated bytes model_selectors = 5
     */
    model_selectors: Uint8Array[];
    /**
     * The block number range to filter by
     *
     * @generated from protobuf field: optional uint64 from_block = 6
     */
    from_block?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_block = 7
     */
    to_block?: bigint;
}
/**
 * @generated MessageType for protobuf message types.TransactionFilter
 */
declare const TransactionFilter$1: TransactionFilter$Type;
declare class TransactionQuery$Type extends MessageType<TransactionQuery$1> {
    constructor();
    create(value?: PartialMessage<TransactionQuery$1>): TransactionQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionQuery$1): TransactionQuery$1;
    internalBinaryWrite(message: TransactionQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TransactionQuery
 */
interface TransactionQuery$1 {
    /**
     * The filter to apply to the query
     *
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter$1;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.TransactionQuery
 */
declare const TransactionQuery$1: TransactionQuery$Type;
declare class Activity$Type extends MessageType<Activity> {
    constructor();
    create(value?: PartialMessage<Activity>): Activity;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Activity): Activity;
    private binaryReadMap8;
    internalBinaryWrite(message: Activity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Activity tracking for user sessions
 *
 * @generated from protobuf message types.Activity
 */
interface Activity {
    /**
     * Unique identifier: world_address:namespace:caller_address:session_start_timestamp
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * World contract address
     *
     * @generated from protobuf field: bytes world_address = 2
     */
    world_address: Uint8Array;
    /**
     * Namespace
     *
     * @generated from protobuf field: string namespace = 3
     */
    namespace: string;
    /**
     * Caller address
     *
     * @generated from protobuf field: bytes caller_address = 4
     */
    caller_address: Uint8Array;
    /**
     * Session start time
     *
     * @generated from protobuf field: uint64 session_start = 5
     */
    session_start: bigint;
    /**
     * Session end time
     *
     * @generated from protobuf field: uint64 session_end = 6
     */
    session_end: bigint;
    /**
     * Total action count in session
     *
     * @generated from protobuf field: uint32 action_count = 7
     */
    action_count: number;
    /**
     * Map of action names to call counts
     *
     * @generated from protobuf field: map<string, uint32> actions = 8
     */
    actions: {
        [key: string]: number;
    };
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: uint64 updated_at = 9
     */
    updated_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.Activity
 */
declare const Activity: Activity$Type;
declare class ActivityQuery$Type extends MessageType<ActivityQuery$1> {
    constructor();
    create(value?: PartialMessage<ActivityQuery$1>): ActivityQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityQuery$1): ActivityQuery$1;
    internalBinaryWrite(message: ActivityQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.ActivityQuery
 */
interface ActivityQuery$1 {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by caller addresses
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 3
     */
    caller_addresses: Uint8Array[];
    /**
     * Filter by time range (unix timestamps)
     *
     * @generated from protobuf field: optional uint64 from_time = 4
     */
    from_time?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_time = 5
     */
    to_time?: bigint;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 6
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.ActivityQuery
 */
declare const ActivityQuery$1: ActivityQuery$Type;
declare class SqlValue$Type extends MessageType<SqlValue> {
    constructor();
    create(value?: PartialMessage<SqlValue>): SqlValue;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlValue): SqlValue;
    internalBinaryWrite(message: SqlValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * SQL query value types
 *
 * @generated from protobuf message types.SqlValue
 */
interface SqlValue {
    /**
     * @generated from protobuf oneof: value_type
     */
    value_type: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 1
         */
        text: string;
    } | {
        oneofKind: "integer";
        /**
         * @generated from protobuf field: int64 integer = 2
         */
        integer: bigint;
    } | {
        oneofKind: "real";
        /**
         * @generated from protobuf field: double real = 3
         */
        real: number;
    } | {
        oneofKind: "blob";
        /**
         * @generated from protobuf field: bytes blob = 4
         */
        blob: Uint8Array;
    } | {
        oneofKind: "null";
        /**
         * @generated from protobuf field: bool null = 5
         */
        null: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated MessageType for protobuf message types.SqlValue
 */
declare const SqlValue: SqlValue$Type;
declare class SqlRow$Type extends MessageType<SqlRow> {
    constructor();
    create(value?: PartialMessage<SqlRow>): SqlRow;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlRow): SqlRow;
    private binaryReadMap1;
    internalBinaryWrite(message: SqlRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A single row from SQL query results
 *
 * @generated from protobuf message types.SqlRow
 */
interface SqlRow {
    /**
     * Map of column name to value
     *
     * @generated from protobuf field: map<string, types.SqlValue> fields = 1
     */
    fields: {
        [key: string]: SqlValue;
    };
}
/**
 * @generated MessageType for protobuf message types.SqlRow
 */
declare const SqlRow: SqlRow$Type;
declare class SqlQueryRequest$Type extends MessageType<SqlQueryRequest> {
    constructor();
    create(value?: PartialMessage<SqlQueryRequest>): SqlQueryRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlQueryRequest): SqlQueryRequest;
    internalBinaryWrite(message: SqlQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to execute a SQL query
 *
 * @generated from protobuf message types.SqlQueryRequest
 */
interface SqlQueryRequest {
    /**
     * The SQL query to execute
     *
     * @generated from protobuf field: string query = 1
     */
    query: string;
}
/**
 * @generated MessageType for protobuf message types.SqlQueryRequest
 */
declare const SqlQueryRequest: SqlQueryRequest$Type;
declare class SqlQueryResponse$Type extends MessageType<SqlQueryResponse$1> {
    constructor();
    create(value?: PartialMessage<SqlQueryResponse$1>): SqlQueryResponse$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlQueryResponse$1): SqlQueryResponse$1;
    internalBinaryWrite(message: SqlQueryResponse$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing SQL query results
 *
 * @generated from protobuf message types.SqlQueryResponse
 */
interface SqlQueryResponse$1 {
    /**
     * The rows returned by the query
     *
     * @generated from protobuf field: repeated types.SqlRow rows = 1
     */
    rows: SqlRow[];
}
/**
 * @generated MessageType for protobuf message types.SqlQueryResponse
 */
declare const SqlQueryResponse$1: SqlQueryResponse$Type;
declare class Contract$Type extends MessageType<Contract> {
    constructor();
    create(value?: PartialMessage<Contract>): Contract;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract;
    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.Contract
 */
interface Contract {
    /**
     * The contract address
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The type of contract
     *
     * @generated from protobuf field: types.ContractType contract_type = 2
     */
    contract_type: ContractType$1;
    /**
     * Current block height
     *
     * @generated from protobuf field: optional uint64 head = 3
     */
    head?: bigint;
    /**
     * Transactions per second
     *
     * @generated from protobuf field: optional uint64 tps = 4
     */
    tps?: bigint;
    /**
     * Last block timestamp
     *
     * @generated from protobuf field: optional uint64 last_block_timestamp = 5
     */
    last_block_timestamp?: bigint;
    /**
     * Last pending block transaction
     *
     * @generated from protobuf field: optional bytes last_pending_block_tx = 6
     */
    last_pending_block_tx?: Uint8Array;
    /**
     * When the contract was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updated_at: bigint;
    /**
     * When the contract was first tracked
     *
     * @generated from protobuf field: uint64 created_at = 8
     */
    created_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.Contract
 */
declare const Contract: Contract$Type;
declare class ContractQuery$Type extends MessageType<ContractQuery> {
    constructor();
    create(value?: PartialMessage<ContractQuery>): ContractQuery;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractQuery): ContractQuery;
    internalBinaryWrite(message: ContractQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve contracts
 *
 * @generated from protobuf message types.ContractQuery
 */
interface ContractQuery {
    /**
     * The list of contract addresses to retrieve
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of contract types to filter by
     *
     * @generated from protobuf field: repeated types.ContractType contract_types = 2
     */
    contract_types: ContractType$1[];
}
/**
 * @generated MessageType for protobuf message types.ContractQuery
 */
declare const ContractQuery: ContractQuery$Type;
declare class TokenContract$Type extends MessageType<TokenContract$1> {
    constructor();
    create(value?: PartialMessage<TokenContract$1>): TokenContract$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenContract$1): TokenContract$1;
    internalBinaryWrite(message: TokenContract$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message types.TokenContract
 */
interface TokenContract$1 {
    /**
     * The contract address
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The type of contract
     *
     * @generated from protobuf field: types.ContractType contract_type = 2
     */
    contract_type: ContractType$1;
    /**
     * The name of the contract
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * The symbol of the contract
     *
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * The decimals of the contract
     *
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * The metadata of the contract
     *
     * @generated from protobuf field: bytes metadata = 6
     */
    metadata: Uint8Array;
    /**
     * The total supply of the contract
     *
     * @generated from protobuf field: optional bytes total_supply = 7
     */
    total_supply?: Uint8Array;
    /**
     * The traits of the contract (JSON object with trait types and possible values)
     *
     * @generated from protobuf field: string traits = 8
     */
    traits: string;
    /**
     * The first token metadata of the contract
     *
     * @generated from protobuf field: bytes token_metadata = 9
     */
    token_metadata: Uint8Array;
}
/**
 * @generated MessageType for protobuf message types.TokenContract
 */
declare const TokenContract$1: TokenContract$Type;
declare class AggregationQuery$Type extends MessageType<AggregationQuery$1> {
    constructor();
    create(value?: PartialMessage<AggregationQuery$1>): AggregationQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregationQuery$1): AggregationQuery$1;
    internalBinaryWrite(message: AggregationQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A query for aggregations (leaderboards, stats, rankings)
 *
 * @generated from protobuf message types.AggregationQuery
 */
interface AggregationQuery$1 {
    /**
     * The list of aggregator IDs to retrieve (e.g., "top_scores", "most_wins")
     *
     * @generated from protobuf field: repeated string aggregator_ids = 1
     */
    aggregator_ids: string[];
    /**
     * The list of entity IDs to filter by (optional)
     *
     * @generated from protobuf field: repeated string entity_ids = 2
     */
    entity_ids: string[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.AggregationQuery
 */
declare const AggregationQuery$1: AggregationQuery$Type;
declare class AggregationEntry$Type extends MessageType<AggregationEntry> {
    constructor();
    create(value?: PartialMessage<AggregationEntry>): AggregationEntry;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregationEntry): AggregationEntry;
    internalBinaryWrite(message: AggregationEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * An entry in an aggregation with its calculated position
 *
 * @generated from protobuf message types.AggregationEntry
 */
interface AggregationEntry {
    /**
     * Unique identifier for this entry
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * The aggregator this entry belongs to
     *
     * @generated from protobuf field: string aggregator_id = 2
     */
    aggregator_id: string;
    /**
     * The entity being ranked
     *
     * @generated from protobuf field: string entity_id = 3
     */
    entity_id: string;
    /**
     * Normalized value for ordering (zero-padded hex)
     *
     * @generated from protobuf field: bytes value = 4
     */
    value: Uint8Array;
    /**
     * Display value for presentation (original format)
     *
     * @generated from protobuf field: string display_value = 5
     */
    display_value: string;
    /**
     * Calculated position/rank (1-indexed)
     *
     * @generated from protobuf field: uint64 position = 6
     */
    position: bigint;
    /**
     * The model ID this aggregation is based on
     *
     * @generated from protobuf field: string model_id = 7
     */
    model_id: string;
    /**
     * When the entry was created (RFC3339 timestamp)
     *
     * @generated from protobuf field: string created_at = 8
     */
    created_at: string;
    /**
     * When the entry was last updated (RFC3339 timestamp)
     *
     * @generated from protobuf field: string updated_at = 9
     */
    updated_at: string;
}
/**
 * @generated MessageType for protobuf message types.AggregationEntry
 */
declare const AggregationEntry: AggregationEntry$Type;
declare class Achievement$Type extends MessageType<Achievement> {
    constructor();
    create(value?: PartialMessage<Achievement>): Achievement;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Achievement): Achievement;
    internalBinaryWrite(message: Achievement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Achievement definition
 *
 * @generated from protobuf message types.Achievement
 */
interface Achievement {
    /**
     * Achievement ID (unique identifier)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * World contract address
     *
     * @generated from protobuf field: bytes world_address = 2
     */
    world_address: Uint8Array;
    /**
     * Namespace
     *
     * @generated from protobuf field: string namespace = 3
     */
    namespace: string;
    /**
     * Entity ID from on-chain
     *
     * @generated from protobuf field: string entity_id = 4
     */
    entity_id: string;
    /**
     * Is this achievement hidden
     *
     * @generated from protobuf field: bool hidden = 5
     */
    hidden: boolean;
    /**
     * Display index/order
     *
     * @generated from protobuf field: uint32 index = 6
     */
    index: number;
    /**
     * Points awarded for completion
     *
     * @generated from protobuf field: uint32 points = 7
     */
    points: number;
    /**
     * Start time
     *
     * @generated from protobuf field: string start = 8
     */
    start: string;
    /**
     * End time
     *
     * @generated from protobuf field: string end = 9
     */
    end: string;
    /**
     * Achievement group
     *
     * @generated from protobuf field: string group = 10
     */
    group: string;
    /**
     * Icon identifier
     *
     * @generated from protobuf field: string icon = 11
     */
    icon: string;
    /**
     * Achievement title
     *
     * @generated from protobuf field: string title = 12
     */
    title: string;
    /**
     * Achievement description
     *
     * @generated from protobuf field: string description = 13
     */
    description: string;
    /**
     * Tasks to complete for this achievement
     *
     * @generated from protobuf field: repeated types.AchievementTask tasks = 14
     */
    tasks: AchievementTask[];
    /**
     * Additional data (JSON)
     *
     * @generated from protobuf field: optional string data = 15
     */
    data?: string;
    /**
     * Total completions across all players
     *
     * @generated from protobuf field: uint32 total_completions = 16
     */
    total_completions: number;
    /**
     * Completion rate (percentage 0-100)
     *
     * @generated from protobuf field: double completion_rate = 17
     */
    completion_rate: number;
    /**
     * When the achievement was created
     *
     * @generated from protobuf field: uint64 created_at = 18
     */
    created_at: bigint;
    /**
     * When the achievement was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 19
     */
    updated_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.Achievement
 */
declare const Achievement: Achievement$Type;
declare class AchievementTask$Type extends MessageType<AchievementTask> {
    constructor();
    create(value?: PartialMessage<AchievementTask>): AchievementTask;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementTask): AchievementTask;
    internalBinaryWrite(message: AchievementTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A task within an achievement
 *
 * @generated from protobuf message types.AchievementTask
 */
interface AchievementTask {
    /**
     * Task ID from on-chain (unique within achievement)
     *
     * @generated from protobuf field: string task_id = 1
     */
    task_id: string;
    /**
     * Task description
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Target count to complete this task
     *
     * @generated from protobuf field: uint32 total = 3
     */
    total: number;
    /**
     * Total completions across all players
     *
     * @generated from protobuf field: uint32 total_completions = 4
     */
    total_completions: number;
    /**
     * Completion rate (percentage 0-100)
     *
     * @generated from protobuf field: double completion_rate = 5
     */
    completion_rate: number;
    /**
     * When the task was created
     *
     * @generated from protobuf field: uint64 created_at = 6
     */
    created_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.AchievementTask
 */
declare const AchievementTask: AchievementTask$Type;
declare class PlayerAchievementStats$Type extends MessageType<PlayerAchievementStats> {
    constructor();
    create(value?: PartialMessage<PlayerAchievementStats>): PlayerAchievementStats;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementStats): PlayerAchievementStats;
    internalBinaryWrite(message: PlayerAchievementStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Player's global achievement statistics (across all worlds/namespaces)
 *
 * @generated from protobuf message types.PlayerAchievementStats
 */
interface PlayerAchievementStats {
    /**
     * Total points earned across all games
     *
     * @generated from protobuf field: uint32 total_points = 1
     */
    total_points: number;
    /**
     * Number of achievements completed across all games
     *
     * @generated from protobuf field: uint32 completed_achievements = 2
     */
    completed_achievements: number;
    /**
     * Total achievements available across all games
     *
     * @generated from protobuf field: uint32 total_achievements = 3
     */
    total_achievements: number;
    /**
     * Overall completion percentage
     *
     * @generated from protobuf field: double completion_percentage = 4
     */
    completion_percentage: number;
    /**
     * Last achievement completion time (across all games)
     *
     * @generated from protobuf field: optional uint64 last_achievement_at = 5
     */
    last_achievement_at?: bigint;
    /**
     * When the stats were first created
     *
     * @generated from protobuf field: uint64 created_at = 6
     */
    created_at: bigint;
    /**
     * When the stats were last updated
     *
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updated_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementStats
 */
declare const PlayerAchievementStats: PlayerAchievementStats$Type;
declare class AchievementProgression$Type extends MessageType<AchievementProgression> {
    constructor();
    create(value?: PartialMessage<AchievementProgression>): AchievementProgression;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementProgression): AchievementProgression;
    internalBinaryWrite(message: AchievementProgression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Achievement progression for a specific player and task
 *
 * @generated from protobuf message types.AchievementProgression
 */
interface AchievementProgression {
    /**
     * Unique identifier (world:namespace:task_id:player_id)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Achievement ID this task belongs to
     *
     * @generated from protobuf field: string achievement_id = 2
     */
    achievement_id: string;
    /**
     * Task ID
     *
     * @generated from protobuf field: string task_id = 3
     */
    task_id: string;
    /**
     * World address
     *
     * @generated from protobuf field: bytes world_address = 4
     */
    world_address: Uint8Array;
    /**
     * Namespace
     *
     * @generated from protobuf field: string namespace = 5
     */
    namespace: string;
    /**
     * Player address
     *
     * @generated from protobuf field: bytes player_id = 6
     */
    player_id: Uint8Array;
    /**
     * Current count/progress
     *
     * @generated from protobuf field: uint32 count = 7
     */
    count: number;
    /**
     * Is the task completed
     *
     * @generated from protobuf field: bool completed = 8
     */
    completed: boolean;
    /**
     * When the task was completed
     *
     * @generated from protobuf field: optional uint64 completed_at = 9
     */
    completed_at?: bigint;
    /**
     * When the progression was created
     *
     * @generated from protobuf field: uint64 created_at = 10
     */
    created_at: bigint;
    /**
     * When the progression was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 11
     */
    updated_at: bigint;
}
/**
 * @generated MessageType for protobuf message types.AchievementProgression
 */
declare const AchievementProgression: AchievementProgression$Type;
declare class AchievementQuery$Type extends MessageType<AchievementQuery$1> {
    constructor();
    create(value?: PartialMessage<AchievementQuery$1>): AchievementQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementQuery$1): AchievementQuery$1;
    internalBinaryWrite(message: AchievementQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Query for achievements
 *
 * @generated from protobuf message types.AchievementQuery
 */
interface AchievementQuery$1 {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by hidden status (optional)
     *
     * @generated from protobuf field: optional bool hidden = 3
     */
    hidden?: boolean;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.AchievementQuery
 */
declare const AchievementQuery$1: AchievementQuery$Type;
declare class PlayerAchievementQuery$Type extends MessageType<PlayerAchievementQuery$1> {
    constructor();
    create(value?: PartialMessage<PlayerAchievementQuery$1>): PlayerAchievementQuery$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementQuery$1): PlayerAchievementQuery$1;
    internalBinaryWrite(message: PlayerAchievementQuery$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Query for player achievements
 *
 * @generated from protobuf message types.PlayerAchievementQuery
 */
interface PlayerAchievementQuery$1 {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by player addresses
     *
     * @generated from protobuf field: repeated bytes player_addresses = 3
     */
    player_addresses: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination$1;
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementQuery
 */
declare const PlayerAchievementQuery$1: PlayerAchievementQuery$Type;
declare class PlayerAchievementProgress$Type extends MessageType<PlayerAchievementProgress> {
    constructor();
    create(value?: PartialMessage<PlayerAchievementProgress>): PlayerAchievementProgress;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementProgress): PlayerAchievementProgress;
    internalBinaryWrite(message: PlayerAchievementProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Player's progress on a specific achievement
 *
 * @generated from protobuf message types.PlayerAchievementProgress
 */
interface PlayerAchievementProgress {
    /**
     * The achievement definition (includes task definitions)
     *
     * @generated from protobuf field: types.Achievement achievement = 1
     */
    achievement?: Achievement;
    /**
     * Progress on each task (references tasks by ID)
     *
     * @generated from protobuf field: repeated types.TaskProgress taskProgress = 2
     */
    taskProgress: TaskProgress[];
    /**
     * Is the achievement completed
     *
     * @generated from protobuf field: bool completed = 3
     */
    completed: boolean;
    /**
     * Progress percentage (0-100)
     *
     * @generated from protobuf field: double progress_percentage = 4
     */
    progress_percentage: number;
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementProgress
 */
declare const PlayerAchievementProgress: PlayerAchievementProgress$Type;
declare class TaskProgress$Type extends MessageType<TaskProgress> {
    constructor();
    create(value?: PartialMessage<TaskProgress>): TaskProgress;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskProgress): TaskProgress;
    internalBinaryWrite(message: TaskProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Progress on a specific task (reference only, no duplication)
 *
 * @generated from protobuf message types.TaskProgress
 */
interface TaskProgress {
    /**
     * Task ID reference (matches task_id in Achievement.tasks)
     *
     * @generated from protobuf field: string task_id = 1
     */
    task_id: string;
    /**
     * Current count
     *
     * @generated from protobuf field: uint32 count = 2
     */
    count: number;
    /**
     * Is the task completed
     *
     * @generated from protobuf field: bool completed = 3
     */
    completed: boolean;
}
/**
 * @generated MessageType for protobuf message types.TaskProgress
 */
declare const TaskProgress: TaskProgress$Type;
declare class PlayerAchievementEntry$Type extends MessageType<PlayerAchievementEntry> {
    constructor();
    create(value?: PartialMessage<PlayerAchievementEntry>): PlayerAchievementEntry;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementEntry): PlayerAchievementEntry;
    internalBinaryWrite(message: PlayerAchievementEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Player achievement entry (for a specific world/namespace/player combination)
 *
 * @generated from protobuf message types.PlayerAchievementEntry
 */
interface PlayerAchievementEntry {
    /**
     * Player address (global identifier)
     *
     * @generated from protobuf field: bytes player_address = 1
     */
    player_address: Uint8Array;
    /**
     * Player's overall statistics (across all worlds/namespaces)
     *
     * @generated from protobuf field: types.PlayerAchievementStats stats = 2
     */
    stats?: PlayerAchievementStats;
    /**
     * Progress on each achievement (each achievement has its own world/namespace scope)
     *
     * @generated from protobuf field: repeated types.PlayerAchievementProgress achievements = 3
     */
    achievements: PlayerAchievementProgress[];
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementEntry
 */
declare const PlayerAchievementEntry: PlayerAchievementEntry$Type;
declare class SearchQuery$Type extends MessageType<SearchQuery> {
    constructor();
    create(value?: PartialMessage<SearchQuery>): SearchQuery;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchQuery): SearchQuery;
    internalBinaryWrite(message: SearchQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Global search query
 *
 * @generated from protobuf message types.SearchQuery
 */
interface SearchQuery {
    /**
     * The search query string (FTS5 syntax supported: phrases, prefix matching, boolean operators)
     *
     * @generated from protobuf field: string query = 1
     */
    query: string;
    /**
     * Maximum results to return per table
     *
     * @generated from protobuf field: uint32 limit = 2
     */
    limit: number;
}
/**
 * @generated MessageType for protobuf message types.SearchQuery
 */
declare const SearchQuery: SearchQuery$Type;
declare class SearchMatch$Type extends MessageType<SearchMatch$1> {
    constructor();
    create(value?: PartialMessage<SearchMatch$1>): SearchMatch$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchMatch$1): SearchMatch$1;
    private binaryReadMap2;
    internalBinaryWrite(message: SearchMatch$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A single search result match
 *
 * @generated from protobuf message types.SearchMatch
 */
interface SearchMatch$1 {
    /**
     * The unique identifier of the matching record
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * The matched fields and their values
     *
     * @generated from protobuf field: map<string, string> fields = 2
     */
    fields: {
        [key: string]: string;
    };
    /**
     * Relevance score (optional, for future ranking)
     *
     * @generated from protobuf field: optional double score = 3
     */
    score?: number;
}
/**
 * @generated MessageType for protobuf message types.SearchMatch
 */
declare const SearchMatch$1: SearchMatch$Type;
declare class TableSearchResults$Type extends MessageType<TableSearchResults$1> {
    constructor();
    create(value?: PartialMessage<TableSearchResults$1>): TableSearchResults$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableSearchResults$1): TableSearchResults$1;
    internalBinaryWrite(message: TableSearchResults$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Search results grouped by table
 *
 * @generated from protobuf message types.TableSearchResults
 */
interface TableSearchResults$1 {
    /**
     * The table name
     *
     * @generated from protobuf field: string table = 1
     */
    table: string;
    /**
     * Total count of matches in this table
     *
     * @generated from protobuf field: uint32 count = 2
     */
    count: number;
    /**
     * The matching records
     *
     * @generated from protobuf field: repeated types.SearchMatch matches = 3
     */
    matches: SearchMatch$1[];
}
/**
 * @generated MessageType for protobuf message types.TableSearchResults
 */
declare const TableSearchResults$1: TableSearchResults$Type;
declare class SearchResponse$Type$1 extends MessageType<SearchResponse$1> {
    constructor();
    create(value?: PartialMessage<SearchResponse$1>): SearchResponse$1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse$1): SearchResponse$1;
    internalBinaryWrite(message: SearchResponse$1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * Global search response
 *
 * @generated from protobuf message types.SearchResponse
 */
interface SearchResponse$1 {
    /**
     * Total count across all tables
     *
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * Results grouped by table
     *
     * @generated from protobuf field: repeated types.TableSearchResults results = 2
     */
    results: TableSearchResults$1[];
}
/**
 * @generated MessageType for protobuf message types.SearchResponse
 */
declare const SearchResponse$1: SearchResponse$Type$1;

declare class SubscribeTransactionsRequest$Type extends MessageType<SubscribeTransactionsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTransactionsRequest>): SubscribeTransactionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsRequest): SubscribeTransactionsRequest;
    internalBinaryWrite(message: SubscribeTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsRequest
 */
interface SubscribeTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsRequest
 */
declare const SubscribeTransactionsRequest: SubscribeTransactionsRequest$Type;
declare class SubscribeTransactionsResponse$Type extends MessageType<SubscribeTransactionsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTransactionsResponse>): SubscribeTransactionsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsResponse): SubscribeTransactionsResponse;
    internalBinaryWrite(message: SubscribeTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsResponse
 */
interface SubscribeTransactionsResponse {
    /**
     * @generated from protobuf field: types.Transaction transaction = 1
     */
    transaction?: Transaction$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsResponse
 */
declare const SubscribeTransactionsResponse: SubscribeTransactionsResponse$Type;
declare class RetrieveControllersRequest$Type extends MessageType<RetrieveControllersRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveControllersRequest>): RetrieveControllersRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersRequest): RetrieveControllersRequest;
    internalBinaryWrite(message: RetrieveControllersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveControllersRequest
 */
interface RetrieveControllersRequest {
    /**
     * @generated from protobuf field: types.ControllerQuery query = 1
     */
    query?: ControllerQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersRequest
 */
declare const RetrieveControllersRequest: RetrieveControllersRequest$Type;
declare class RetrieveControllersResponse$Type extends MessageType<RetrieveControllersResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveControllersResponse>): RetrieveControllersResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersResponse): RetrieveControllersResponse;
    internalBinaryWrite(message: RetrieveControllersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveControllersResponse
 */
interface RetrieveControllersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Controller controllers = 2
     */
    controllers: Controller$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersResponse
 */
declare const RetrieveControllersResponse: RetrieveControllersResponse$Type;
declare class RetrieveContractsRequest$Type extends MessageType<RetrieveContractsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveContractsRequest>): RetrieveContractsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsRequest): RetrieveContractsRequest;
    internalBinaryWrite(message: RetrieveContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveContractsRequest
 */
interface RetrieveContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsRequest
 */
declare const RetrieveContractsRequest: RetrieveContractsRequest$Type;
declare class RetrieveContractsResponse$Type extends MessageType<RetrieveContractsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveContractsResponse>): RetrieveContractsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsResponse): RetrieveContractsResponse;
    internalBinaryWrite(message: RetrieveContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveContractsResponse
 */
interface RetrieveContractsResponse {
    /**
     * @generated from protobuf field: repeated types.Contract contracts = 1
     */
    contracts: Contract[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsResponse
 */
declare const RetrieveContractsResponse: RetrieveContractsResponse$Type;
declare class UpdateTokenBalancesSubscriptionRequest$Type extends MessageType<UpdateTokenBalancesSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateTokenBalancesSubscriptionRequest>): UpdateTokenBalancesSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenBalancesSubscriptionRequest): UpdateTokenBalancesSubscriptionRequest;
    internalBinaryWrite(message: UpdateTokenBalancesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update a token balance subscription
 *
 * @generated from protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
interface UpdateTokenBalancesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
declare const UpdateTokenBalancesSubscriptionRequest: UpdateTokenBalancesSubscriptionRequest$Type;
declare class SubscribeTokenBalancesResponse$Type extends MessageType<SubscribeTokenBalancesResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTokenBalancesResponse>): SubscribeTokenBalancesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesResponse): SubscribeTokenBalancesResponse;
    internalBinaryWrite(message: SubscribeTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.SubscribeTokenBalancesResponse
 */
interface SubscribeTokenBalancesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token balance
     *
     * @generated from protobuf field: types.TokenBalance balance = 2
     */
    balance?: TokenBalance$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesResponse
 */
declare const SubscribeTokenBalancesResponse: SubscribeTokenBalancesResponse$Type;
declare class RetrieveTokensRequest$Type extends MessageType<RetrieveTokensRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokensRequest>): RetrieveTokensRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensRequest): RetrieveTokensRequest;
    internalBinaryWrite(message: RetrieveTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message world.RetrieveTokensRequest
 */
interface RetrieveTokensRequest {
    /**
     * @generated from protobuf field: types.TokenQuery query = 1
     */
    query?: TokenQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensRequest
 */
declare const RetrieveTokensRequest: RetrieveTokensRequest$Type;
declare class SubscribeTokensRequest$Type extends MessageType<SubscribeTokensRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTokensRequest>): SubscribeTokensRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensRequest): SubscribeTokensRequest;
    internalBinaryWrite(message: SubscribeTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to token updates
 *
 * @generated from protobuf message world.SubscribeTokensRequest
 */
interface SubscribeTokensRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensRequest
 */
declare const SubscribeTokensRequest: SubscribeTokensRequest$Type;
declare class RetrieveTokensResponse$Type extends MessageType<RetrieveTokensResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokensResponse>): RetrieveTokensResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensResponse): RetrieveTokensResponse;
    internalBinaryWrite(message: RetrieveTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing tokens
 *
 * @generated from protobuf message world.RetrieveTokensResponse
 */
interface RetrieveTokensResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Token tokens = 2
     */
    tokens: Token$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensResponse
 */
declare const RetrieveTokensResponse: RetrieveTokensResponse$Type;
declare class SubscribeTokensResponse$Type extends MessageType<SubscribeTokensResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTokensResponse>): SubscribeTokensResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensResponse): SubscribeTokensResponse;
    internalBinaryWrite(message: SubscribeTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token updates
 *
 * @generated from protobuf message world.SubscribeTokensResponse
 */
interface SubscribeTokensResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token
     *
     * @generated from protobuf field: types.Token token = 2
     */
    token?: Token$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensResponse
 */
declare const SubscribeTokensResponse: SubscribeTokensResponse$Type;
declare class UpdateTokenSubscriptionRequest$Type extends MessageType<UpdateTokenSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateTokenSubscriptionRequest>): UpdateTokenSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenSubscriptionRequest): UpdateTokenSubscriptionRequest;
    internalBinaryWrite(message: UpdateTokenSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update a token subscription
 *
 * @generated from protobuf message world.UpdateTokenSubscriptionRequest
 */
interface UpdateTokenSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenSubscriptionRequest
 */
declare const UpdateTokenSubscriptionRequest: UpdateTokenSubscriptionRequest$Type;
declare class RetrieveTokenBalancesRequest$Type extends MessageType<RetrieveTokenBalancesRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenBalancesRequest>): RetrieveTokenBalancesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesRequest): RetrieveTokenBalancesRequest;
    internalBinaryWrite(message: RetrieveTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesRequest
 */
interface RetrieveTokenBalancesRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesRequest
 */
declare const RetrieveTokenBalancesRequest: RetrieveTokenBalancesRequest$Type;
declare class SubscribeTokenBalancesRequest$Type extends MessageType<SubscribeTokenBalancesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTokenBalancesRequest>): SubscribeTokenBalancesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesRequest): SubscribeTokenBalancesRequest;
    internalBinaryWrite(message: SubscribeTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to token balance updates
 *
 * @generated from protobuf message world.SubscribeTokenBalancesRequest
 */
interface SubscribeTokenBalancesRequest {
    /**
     * The account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesRequest
 */
declare const SubscribeTokenBalancesRequest: SubscribeTokenBalancesRequest$Type;
declare class RetrieveTokenBalancesResponse$Type extends MessageType<RetrieveTokenBalancesResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenBalancesResponse>): RetrieveTokenBalancesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesResponse): RetrieveTokenBalancesResponse;
    internalBinaryWrite(message: RetrieveTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesResponse
 */
interface RetrieveTokenBalancesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenBalance balances = 2
     */
    balances: TokenBalance$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesResponse
 */
declare const RetrieveTokenBalancesResponse: RetrieveTokenBalancesResponse$Type;
declare class RetrieveTransactionsRequest$Type extends MessageType<RetrieveTransactionsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTransactionsRequest>): RetrieveTransactionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsRequest): RetrieveTransactionsRequest;
    internalBinaryWrite(message: RetrieveTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsRequest
 */
interface RetrieveTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionQuery query = 1
     */
    query?: TransactionQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsRequest
 */
declare const RetrieveTransactionsRequest: RetrieveTransactionsRequest$Type;
declare class RetrieveTransactionsResponse$Type extends MessageType<RetrieveTransactionsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTransactionsResponse>): RetrieveTransactionsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsResponse): RetrieveTransactionsResponse;
    internalBinaryWrite(message: RetrieveTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsResponse
 */
interface RetrieveTransactionsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Transaction transactions = 2
     */
    transactions: Transaction$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsResponse
 */
declare const RetrieveTransactionsResponse: RetrieveTransactionsResponse$Type;
declare class RetrieveTokenContractsRequest$Type extends MessageType<RetrieveTokenContractsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenContractsRequest>): RetrieveTokenContractsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsRequest): RetrieveTokenContractsRequest;
    internalBinaryWrite(message: RetrieveTokenContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsRequest
 */
interface RetrieveTokenContractsRequest {
    /**
     * @generated from protobuf field: types.TokenContractQuery query = 1
     */
    query?: TokenContractQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsRequest
 */
declare const RetrieveTokenContractsRequest: RetrieveTokenContractsRequest$Type;
declare class RetrieveTokenContractsResponse$Type extends MessageType<RetrieveTokenContractsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenContractsResponse>): RetrieveTokenContractsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsResponse): RetrieveTokenContractsResponse;
    internalBinaryWrite(message: RetrieveTokenContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsResponse
 */
interface RetrieveTokenContractsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenContract token_contracts = 2
     */
    token_contracts: TokenContract$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsResponse
 */
declare const RetrieveTokenContractsResponse: RetrieveTokenContractsResponse$Type;
declare class SubscribeContractsRequest$Type extends MessageType<SubscribeContractsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeContractsRequest>): SubscribeContractsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsRequest): SubscribeContractsRequest;
    internalBinaryWrite(message: SubscribeContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsRequest
 */
interface SubscribeContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsRequest
 */
declare const SubscribeContractsRequest: SubscribeContractsRequest$Type;
declare class SubscribeContractsResponse$Type extends MessageType<SubscribeContractsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeContractsResponse>): SubscribeContractsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsResponse): SubscribeContractsResponse;
    internalBinaryWrite(message: SubscribeContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsResponse
 */
interface SubscribeContractsResponse {
    /**
     * @generated from protobuf field: types.Contract contract = 1
     */
    contract?: Contract;
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsResponse
 */
declare const SubscribeContractsResponse: SubscribeContractsResponse$Type;
declare class WorldsRequest$Type extends MessageType<WorldsRequest> {
    constructor();
    create(value?: PartialMessage<WorldsRequest>): WorldsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldsRequest): WorldsRequest;
    internalBinaryWrite(message: WorldsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve metadata for a specific world ID.
 *
 * @generated from protobuf message world.WorldsRequest
 */
interface WorldsRequest {
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.WorldsRequest
 */
declare const WorldsRequest: WorldsRequest$Type;
declare class WorldsResponse$Type extends MessageType<WorldsResponse> {
    constructor();
    create(value?: PartialMessage<WorldsResponse>): WorldsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldsResponse): WorldsResponse;
    internalBinaryWrite(message: WorldsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * The metadata response contains addresses and class hashes for the world.
 *
 * @generated from protobuf message world.WorldsResponse
 */
interface WorldsResponse {
    /**
     * @generated from protobuf field: repeated types.World worlds = 1
     */
    worlds: World$1[];
}
/**
 * @generated MessageType for protobuf message world.WorldsResponse
 */
declare const WorldsResponse: WorldsResponse$Type;
declare class SubscribeEntitiesRequest$Type extends MessageType<SubscribeEntitiesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeEntitiesRequest>): SubscribeEntitiesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntitiesRequest): SubscribeEntitiesRequest;
    internalBinaryWrite(message: SubscribeEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEntitiesRequest
 */
interface SubscribeEntitiesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause$1;
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 2
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntitiesRequest
 */
declare const SubscribeEntitiesRequest: SubscribeEntitiesRequest$Type;
declare class UpdateEntitiesSubscriptionRequest$Type extends MessageType<UpdateEntitiesSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateEntitiesSubscriptionRequest>): UpdateEntitiesSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEntitiesSubscriptionRequest): UpdateEntitiesSubscriptionRequest;
    internalBinaryWrite(message: UpdateEntitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.UpdateEntitiesSubscriptionRequest
 */
interface UpdateEntitiesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause$1;
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 3
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateEntitiesSubscriptionRequest
 */
declare const UpdateEntitiesSubscriptionRequest: UpdateEntitiesSubscriptionRequest$Type;
declare class SubscribeEntityResponse$Type extends MessageType<SubscribeEntityResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeEntityResponse>): SubscribeEntityResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntityResponse): SubscribeEntityResponse;
    internalBinaryWrite(message: SubscribeEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEntityResponse
 */
interface SubscribeEntityResponse {
    /**
     * @generated from protobuf field: types.Entity entity = 1
     */
    entity?: Entity$1;
    /**
     * @generated from protobuf field: uint64 subscription_id = 2
     */
    subscription_id: bigint;
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntityResponse
 */
declare const SubscribeEntityResponse: SubscribeEntityResponse$Type;
declare class RetrieveEntitiesRequest$Type extends MessageType<RetrieveEntitiesRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveEntitiesRequest>): RetrieveEntitiesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesRequest): RetrieveEntitiesRequest;
    internalBinaryWrite(message: RetrieveEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesRequest
 */
interface RetrieveEntitiesRequest {
    /**
     * The entities to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesRequest
 */
declare const RetrieveEntitiesRequest: RetrieveEntitiesRequest$Type;
declare class RetrieveEntitiesResponse$Type extends MessageType<RetrieveEntitiesResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveEntitiesResponse>): RetrieveEntitiesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesResponse): RetrieveEntitiesResponse;
    internalBinaryWrite(message: RetrieveEntitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesResponse
 */
interface RetrieveEntitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Entity entities = 2
     */
    entities: Entity$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesResponse
 */
declare const RetrieveEntitiesResponse: RetrieveEntitiesResponse$Type;
declare class RetrieveEventsRequest$Type extends MessageType<RetrieveEventsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveEventsRequest>): RetrieveEventsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsRequest): RetrieveEventsRequest;
    internalBinaryWrite(message: RetrieveEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEventsRequest
 */
interface RetrieveEventsRequest {
    /**
     * The events to retrieve
     *
     * @generated from protobuf field: types.EventQuery query = 1
     */
    query?: EventQuery;
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsRequest
 */
declare const RetrieveEventsRequest: RetrieveEventsRequest$Type;
declare class RetrieveEventsResponse$Type extends MessageType<RetrieveEventsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveEventsResponse>): RetrieveEventsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsResponse): RetrieveEventsResponse;
    internalBinaryWrite(message: RetrieveEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.RetrieveEventsResponse
 */
interface RetrieveEventsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Event events = 2
     */
    events: Event[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsResponse
 */
declare const RetrieveEventsResponse: RetrieveEventsResponse$Type;
declare class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest;
    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEventsRequest
 */
interface SubscribeEventsRequest {
    /**
     * @generated from protobuf field: repeated types.KeysClause keys = 1
     */
    keys: KeysClause$1[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsRequest
 */
declare const SubscribeEventsRequest: SubscribeEventsRequest$Type;
declare class SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeEventsResponse>): SubscribeEventsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsResponse): SubscribeEventsResponse;
    internalBinaryWrite(message: SubscribeEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.SubscribeEventsResponse
 */
interface SubscribeEventsResponse {
    /**
     * @generated from protobuf field: types.Event event = 1
     */
    event?: Event;
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsResponse
 */
declare const SubscribeEventsResponse: SubscribeEventsResponse$Type;
declare class PublishMessageRequest$Type extends MessageType<PublishMessageRequest> {
    constructor();
    create(value?: PartialMessage<PublishMessageRequest>): PublishMessageRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageRequest): PublishMessageRequest;
    internalBinaryWrite(message: PublishMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageRequest
 */
interface PublishMessageRequest {
    /**
     * @generated from protobuf field: repeated bytes signature = 1
     */
    signature: Uint8Array[];
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: bytes world_address = 3
     */
    world_address: Uint8Array;
}
/**
 * @generated MessageType for protobuf message world.PublishMessageRequest
 */
declare const PublishMessageRequest: PublishMessageRequest$Type;
declare class PublishMessageResponse$Type extends MessageType<PublishMessageResponse> {
    constructor();
    create(value?: PartialMessage<PublishMessageResponse>): PublishMessageResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageResponse): PublishMessageResponse;
    internalBinaryWrite(message: PublishMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageResponse
 */
interface PublishMessageResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated MessageType for protobuf message world.PublishMessageResponse
 */
declare const PublishMessageResponse: PublishMessageResponse$Type;
declare class PublishMessageBatchRequest$Type extends MessageType<PublishMessageBatchRequest> {
    constructor();
    create(value?: PartialMessage<PublishMessageBatchRequest>): PublishMessageBatchRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchRequest): PublishMessageBatchRequest;
    internalBinaryWrite(message: PublishMessageBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageBatchRequest
 */
interface PublishMessageBatchRequest {
    /**
     * @generated from protobuf field: repeated world.PublishMessageRequest messages = 1
     */
    messages: PublishMessageRequest[];
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchRequest
 */
declare const PublishMessageBatchRequest: PublishMessageBatchRequest$Type;
declare class PublishMessageBatchResponse$Type extends MessageType<PublishMessageBatchResponse> {
    constructor();
    create(value?: PartialMessage<PublishMessageBatchResponse>): PublishMessageBatchResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchResponse): PublishMessageBatchResponse;
    internalBinaryWrite(message: PublishMessageBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated from protobuf message world.PublishMessageBatchResponse
 */
interface PublishMessageBatchResponse {
    /**
     * @generated from protobuf field: repeated world.PublishMessageResponse responses = 1
     */
    responses: PublishMessageResponse[];
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchResponse
 */
declare const PublishMessageBatchResponse: PublishMessageBatchResponse$Type;
declare class SubscribeTokenTransfersRequest$Type extends MessageType<SubscribeTokenTransfersRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeTokenTransfersRequest>): SubscribeTokenTransfersRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenTransfersRequest): SubscribeTokenTransfersRequest;
    internalBinaryWrite(message: SubscribeTokenTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to token transfer updates
 *
 * @generated from protobuf message world.SubscribeTokenTransfersRequest
 */
interface SubscribeTokenTransfersRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 2
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenTransfersRequest
 */
declare const SubscribeTokenTransfersRequest: SubscribeTokenTransfersRequest$Type;
declare class SubscribeTokenTransfersResponse$Type extends MessageType<SubscribeTokenTransfersResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeTokenTransfersResponse>): SubscribeTokenTransfersResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenTransfersResponse): SubscribeTokenTransfersResponse;
    internalBinaryWrite(message: SubscribeTokenTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token transfer updates
 *
 * @generated from protobuf message world.SubscribeTokenTransfersResponse
 */
interface SubscribeTokenTransfersResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token transfer
     *
     * @generated from protobuf field: types.TokenTransfer transfer = 2
     */
    transfer?: TokenTransfer$1;
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenTransfersResponse
 */
declare const SubscribeTokenTransfersResponse: SubscribeTokenTransfersResponse$Type;
declare class UpdateTokenTransfersSubscriptionRequest$Type extends MessageType<UpdateTokenTransfersSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateTokenTransfersSubscriptionRequest>): UpdateTokenTransfersSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenTransfersSubscriptionRequest): UpdateTokenTransfersSubscriptionRequest;
    internalBinaryWrite(message: UpdateTokenTransfersSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update a token transfer subscription
 *
 * @generated from protobuf message world.UpdateTokenTransfersSubscriptionRequest
 */
interface UpdateTokenTransfersSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenTransfersSubscriptionRequest
 */
declare const UpdateTokenTransfersSubscriptionRequest: UpdateTokenTransfersSubscriptionRequest$Type;
declare class RetrieveTokenTransfersRequest$Type extends MessageType<RetrieveTokenTransfersRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenTransfersRequest>): RetrieveTokenTransfersRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenTransfersRequest): RetrieveTokenTransfersRequest;
    internalBinaryWrite(message: RetrieveTokenTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve token transfers
 *
 * @generated from protobuf message world.RetrieveTokenTransfersRequest
 */
interface RetrieveTokenTransfersRequest {
    /**
     * @generated from protobuf field: types.TokenTransferQuery query = 1
     */
    query?: TokenTransferQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenTransfersRequest
 */
declare const RetrieveTokenTransfersRequest: RetrieveTokenTransfersRequest$Type;
declare class RetrieveTokenTransfersResponse$Type extends MessageType<RetrieveTokenTransfersResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveTokenTransfersResponse>): RetrieveTokenTransfersResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenTransfersResponse): RetrieveTokenTransfersResponse;
    internalBinaryWrite(message: RetrieveTokenTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing token transfers
 *
 * @generated from protobuf message world.RetrieveTokenTransfersResponse
 */
interface RetrieveTokenTransfersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenTransfer transfers = 2
     */
    transfers: TokenTransfer$1[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenTransfersResponse
 */
declare const RetrieveTokenTransfersResponse: RetrieveTokenTransfersResponse$Type;
declare class RetrieveAggregationsRequest$Type extends MessageType<RetrieveAggregationsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveAggregationsRequest>): RetrieveAggregationsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAggregationsRequest): RetrieveAggregationsRequest;
    internalBinaryWrite(message: RetrieveAggregationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve aggregations (leaderboards, stats, rankings)
 *
 * @generated from protobuf message world.RetrieveAggregationsRequest
 */
interface RetrieveAggregationsRequest {
    /**
     * @generated from protobuf field: types.AggregationQuery query = 1
     */
    query?: AggregationQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveAggregationsRequest
 */
declare const RetrieveAggregationsRequest: RetrieveAggregationsRequest$Type;
declare class RetrieveAggregationsResponse$Type extends MessageType<RetrieveAggregationsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveAggregationsResponse>): RetrieveAggregationsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAggregationsResponse): RetrieveAggregationsResponse;
    internalBinaryWrite(message: RetrieveAggregationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing aggregation entries
 *
 * @generated from protobuf message world.RetrieveAggregationsResponse
 */
interface RetrieveAggregationsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.AggregationEntry entries = 2
     */
    entries: AggregationEntry[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveAggregationsResponse
 */
declare const RetrieveAggregationsResponse: RetrieveAggregationsResponse$Type;
declare class SubscribeAggregationsRequest$Type extends MessageType<SubscribeAggregationsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeAggregationsRequest>): SubscribeAggregationsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAggregationsRequest): SubscribeAggregationsRequest;
    internalBinaryWrite(message: SubscribeAggregationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to aggregations updates
 *
 * @generated from protobuf message world.SubscribeAggregationsRequest
 */
interface SubscribeAggregationsRequest {
    /**
     * Filter by aggregator IDs (e.g., "top_scores", "most_wins")
     *
     * @generated from protobuf field: repeated string aggregator_ids = 1
     */
    aggregator_ids: string[];
    /**
     * Filter by entity IDs (e.g., specific player addresses)
     *
     * @generated from protobuf field: repeated string entity_ids = 2
     */
    entity_ids: string[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeAggregationsRequest
 */
declare const SubscribeAggregationsRequest: SubscribeAggregationsRequest$Type;
declare class SubscribeAggregationsResponse$Type extends MessageType<SubscribeAggregationsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeAggregationsResponse>): SubscribeAggregationsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAggregationsResponse): SubscribeAggregationsResponse;
    internalBinaryWrite(message: SubscribeAggregationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing aggregation update
 *
 * @generated from protobuf message world.SubscribeAggregationsResponse
 */
interface SubscribeAggregationsResponse {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.AggregationEntry entry = 2
     */
    entry?: AggregationEntry;
}
/**
 * @generated MessageType for protobuf message world.SubscribeAggregationsResponse
 */
declare const SubscribeAggregationsResponse: SubscribeAggregationsResponse$Type;
declare class UpdateAggregationsSubscriptionRequest$Type extends MessageType<UpdateAggregationsSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateAggregationsSubscriptionRequest>): UpdateAggregationsSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAggregationsSubscriptionRequest): UpdateAggregationsSubscriptionRequest;
    internalBinaryWrite(message: UpdateAggregationsSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update an aggregations subscription
 *
 * @generated from protobuf message world.UpdateAggregationsSubscriptionRequest
 */
interface UpdateAggregationsSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * Filter by aggregator IDs
     *
     * @generated from protobuf field: repeated string aggregator_ids = 2
     */
    aggregator_ids: string[];
    /**
     * Filter by entity IDs
     *
     * @generated from protobuf field: repeated string entity_ids = 3
     */
    entity_ids: string[];
}
/**
 * @generated MessageType for protobuf message world.UpdateAggregationsSubscriptionRequest
 */
declare const UpdateAggregationsSubscriptionRequest: UpdateAggregationsSubscriptionRequest$Type;
declare class UpdateAggregationsSubscriptionResponse$Type extends MessageType<UpdateAggregationsSubscriptionResponse> {
    constructor();
    create(value?: PartialMessage<UpdateAggregationsSubscriptionResponse>): UpdateAggregationsSubscriptionResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAggregationsSubscriptionResponse): UpdateAggregationsSubscriptionResponse;
    internalBinaryWrite(message: UpdateAggregationsSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response for updating an aggregations subscription
 *
 * @generated from protobuf message world.UpdateAggregationsSubscriptionResponse
 */
interface UpdateAggregationsSubscriptionResponse {
}
/**
 * @generated MessageType for protobuf message world.UpdateAggregationsSubscriptionResponse
 */
declare const UpdateAggregationsSubscriptionResponse: UpdateAggregationsSubscriptionResponse$Type;
declare class RetrieveActivitiesRequest$Type extends MessageType<RetrieveActivitiesRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveActivitiesRequest>): RetrieveActivitiesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveActivitiesRequest): RetrieveActivitiesRequest;
    internalBinaryWrite(message: RetrieveActivitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve activities
 *
 * @generated from protobuf message world.RetrieveActivitiesRequest
 */
interface RetrieveActivitiesRequest {
    /**
     * @generated from protobuf field: types.ActivityQuery query = 1
     */
    query?: ActivityQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveActivitiesRequest
 */
declare const RetrieveActivitiesRequest: RetrieveActivitiesRequest$Type;
declare class RetrieveActivitiesResponse$Type extends MessageType<RetrieveActivitiesResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveActivitiesResponse>): RetrieveActivitiesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveActivitiesResponse): RetrieveActivitiesResponse;
    internalBinaryWrite(message: RetrieveActivitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing activities
 *
 * @generated from protobuf message world.RetrieveActivitiesResponse
 */
interface RetrieveActivitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Activity activities = 2
     */
    activities: Activity[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveActivitiesResponse
 */
declare const RetrieveActivitiesResponse: RetrieveActivitiesResponse$Type;
declare class SubscribeActivitiesRequest$Type extends MessageType<SubscribeActivitiesRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeActivitiesRequest>): SubscribeActivitiesRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeActivitiesRequest): SubscribeActivitiesRequest;
    internalBinaryWrite(message: SubscribeActivitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to activity updates
 *
 * @generated from protobuf message world.SubscribeActivitiesRequest
 */
interface SubscribeActivitiesRequest {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by caller addresses
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 3
     */
    caller_addresses: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeActivitiesRequest
 */
declare const SubscribeActivitiesRequest: SubscribeActivitiesRequest$Type;
declare class SubscribeActivitiesResponse$Type extends MessageType<SubscribeActivitiesResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeActivitiesResponse>): SubscribeActivitiesResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeActivitiesResponse): SubscribeActivitiesResponse;
    internalBinaryWrite(message: SubscribeActivitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing activity updates
 *
 * @generated from protobuf message world.SubscribeActivitiesResponse
 */
interface SubscribeActivitiesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The activity update
     *
     * @generated from protobuf field: types.Activity activity = 2
     */
    activity?: Activity;
}
/**
 * @generated MessageType for protobuf message world.SubscribeActivitiesResponse
 */
declare const SubscribeActivitiesResponse: SubscribeActivitiesResponse$Type;
declare class UpdateActivitiesSubscriptionRequest$Type extends MessageType<UpdateActivitiesSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateActivitiesSubscriptionRequest>): UpdateActivitiesSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateActivitiesSubscriptionRequest): UpdateActivitiesSubscriptionRequest;
    internalBinaryWrite(message: UpdateActivitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update an activities subscription
 *
 * @generated from protobuf message world.UpdateActivitiesSubscriptionRequest
 */
interface UpdateActivitiesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 2
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 3
     */
    namespaces: string[];
    /**
     * Filter by caller addresses
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 4
     */
    caller_addresses: Uint8Array[];
}
/**
 * @generated MessageType for protobuf message world.UpdateActivitiesSubscriptionRequest
 */
declare const UpdateActivitiesSubscriptionRequest: UpdateActivitiesSubscriptionRequest$Type;
declare class SubscribeAchievementProgressionsRequest$Type extends MessageType<SubscribeAchievementProgressionsRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeAchievementProgressionsRequest>): SubscribeAchievementProgressionsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAchievementProgressionsRequest): SubscribeAchievementProgressionsRequest;
    internalBinaryWrite(message: SubscribeAchievementProgressionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to subscribe to achievement progression updates
 *
 * @generated from protobuf message world.SubscribeAchievementProgressionsRequest
 */
interface SubscribeAchievementProgressionsRequest {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by player addresses
     *
     * @generated from protobuf field: repeated bytes player_addresses = 3
     */
    player_addresses: Uint8Array[];
    /**
     * Filter by achievement IDs
     *
     * @generated from protobuf field: repeated string achievement_ids = 4
     */
    achievement_ids: string[];
}
/**
 * @generated MessageType for protobuf message world.SubscribeAchievementProgressionsRequest
 */
declare const SubscribeAchievementProgressionsRequest: SubscribeAchievementProgressionsRequest$Type;
declare class SubscribeAchievementProgressionsResponse$Type extends MessageType<SubscribeAchievementProgressionsResponse> {
    constructor();
    create(value?: PartialMessage<SubscribeAchievementProgressionsResponse>): SubscribeAchievementProgressionsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAchievementProgressionsResponse): SubscribeAchievementProgressionsResponse;
    internalBinaryWrite(message: SubscribeAchievementProgressionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing achievement progression updates
 *
 * @generated from protobuf message world.SubscribeAchievementProgressionsResponse
 */
interface SubscribeAchievementProgressionsResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The achievement progression update
     *
     * @generated from protobuf field: types.AchievementProgression progression = 2
     */
    progression?: AchievementProgression;
}
/**
 * @generated MessageType for protobuf message world.SubscribeAchievementProgressionsResponse
 */
declare const SubscribeAchievementProgressionsResponse: SubscribeAchievementProgressionsResponse$Type;
declare class UpdateAchievementProgressionsSubscriptionRequest$Type extends MessageType<UpdateAchievementProgressionsSubscriptionRequest> {
    constructor();
    create(value?: PartialMessage<UpdateAchievementProgressionsSubscriptionRequest>): UpdateAchievementProgressionsSubscriptionRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAchievementProgressionsSubscriptionRequest): UpdateAchievementProgressionsSubscriptionRequest;
    internalBinaryWrite(message: UpdateAchievementProgressionsSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to update an achievement progressions subscription
 *
 * @generated from protobuf message world.UpdateAchievementProgressionsSubscriptionRequest
 */
interface UpdateAchievementProgressionsSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 2
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 3
     */
    namespaces: string[];
    /**
     * Filter by player addresses
     *
     * @generated from protobuf field: repeated bytes player_addresses = 4
     */
    player_addresses: Uint8Array[];
    /**
     * Filter by achievement IDs
     *
     * @generated from protobuf field: repeated string achievement_ids = 5
     */
    achievement_ids: string[];
}
/**
 * @generated MessageType for protobuf message world.UpdateAchievementProgressionsSubscriptionRequest
 */
declare const UpdateAchievementProgressionsSubscriptionRequest: UpdateAchievementProgressionsSubscriptionRequest$Type;
declare class RetrieveAchievementsRequest$Type extends MessageType<RetrieveAchievementsRequest> {
    constructor();
    create(value?: PartialMessage<RetrieveAchievementsRequest>): RetrieveAchievementsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAchievementsRequest): RetrieveAchievementsRequest;
    internalBinaryWrite(message: RetrieveAchievementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve achievements
 *
 * @generated from protobuf message world.RetrieveAchievementsRequest
 */
interface RetrieveAchievementsRequest {
    /**
     * @generated from protobuf field: types.AchievementQuery query = 1
     */
    query?: AchievementQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrieveAchievementsRequest
 */
declare const RetrieveAchievementsRequest: RetrieveAchievementsRequest$Type;
declare class RetrieveAchievementsResponse$Type extends MessageType<RetrieveAchievementsResponse> {
    constructor();
    create(value?: PartialMessage<RetrieveAchievementsResponse>): RetrieveAchievementsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAchievementsResponse): RetrieveAchievementsResponse;
    internalBinaryWrite(message: RetrieveAchievementsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing achievements
 *
 * @generated from protobuf message world.RetrieveAchievementsResponse
 */
interface RetrieveAchievementsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Achievement achievements = 2
     */
    achievements: Achievement[];
}
/**
 * @generated MessageType for protobuf message world.RetrieveAchievementsResponse
 */
declare const RetrieveAchievementsResponse: RetrieveAchievementsResponse$Type;
declare class RetrievePlayerAchievementsRequest$Type extends MessageType<RetrievePlayerAchievementsRequest> {
    constructor();
    create(value?: PartialMessage<RetrievePlayerAchievementsRequest>): RetrievePlayerAchievementsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrievePlayerAchievementsRequest): RetrievePlayerAchievementsRequest;
    internalBinaryWrite(message: RetrievePlayerAchievementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to retrieve player achievements
 *
 * @generated from protobuf message world.RetrievePlayerAchievementsRequest
 */
interface RetrievePlayerAchievementsRequest {
    /**
     * @generated from protobuf field: types.PlayerAchievementQuery query = 1
     */
    query?: PlayerAchievementQuery$1;
}
/**
 * @generated MessageType for protobuf message world.RetrievePlayerAchievementsRequest
 */
declare const RetrievePlayerAchievementsRequest: RetrievePlayerAchievementsRequest$Type;
declare class RetrievePlayerAchievementsResponse$Type extends MessageType<RetrievePlayerAchievementsResponse> {
    constructor();
    create(value?: PartialMessage<RetrievePlayerAchievementsResponse>): RetrievePlayerAchievementsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrievePlayerAchievementsResponse): RetrievePlayerAchievementsResponse;
    internalBinaryWrite(message: RetrievePlayerAchievementsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing player achievement data (paginated)
 *
 * @generated from protobuf message world.RetrievePlayerAchievementsResponse
 */
interface RetrievePlayerAchievementsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.PlayerAchievementEntry players = 2
     */
    players: PlayerAchievementEntry[];
}
/**
 * @generated MessageType for protobuf message world.RetrievePlayerAchievementsResponse
 */
declare const RetrievePlayerAchievementsResponse: RetrievePlayerAchievementsResponse$Type;
declare class SearchRequest$Type extends MessageType<SearchRequest> {
    constructor();
    create(value?: PartialMessage<SearchRequest>): SearchRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest;
    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A request to search across FTS5-indexed tables
 *
 * @generated from protobuf message world.SearchRequest
 */
interface SearchRequest {
    /**
     * @generated from protobuf field: types.SearchQuery query = 1
     */
    query?: SearchQuery;
}
/**
 * @generated MessageType for protobuf message world.SearchRequest
 */
declare const SearchRequest: SearchRequest$Type;
declare class SearchResponse$Type extends MessageType<SearchResponse> {
    constructor();
    create(value?: PartialMessage<SearchResponse>): SearchResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse;
    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A response containing search results grouped by table
 *
 * @generated from protobuf message world.SearchResponse
 */
interface SearchResponse {
    /**
     * @generated from protobuf field: types.SearchResponse response = 1
     */
    response?: SearchResponse$1;
}
/**
 * @generated MessageType for protobuf message world.SearchResponse
 */
declare const SearchResponse: SearchResponse$Type;
/**
 * @generated ServiceType for protobuf service world.World
 */
declare const World: ServiceType;

declare class Empty$Type extends MessageType<Empty> {
    constructor();
    create(value?: PartialMessage<Empty>): Empty;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty;
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 *
 * @generated from protobuf message google.protobuf.Empty
 */
interface Empty {
}
/**
 * @generated MessageType for protobuf message google.protobuf.Empty
 */
declare const Empty: Empty$Type;

/**
 * The World service provides information about the world.
 *
 * @generated from protobuf service world.World
 */
interface IWorldClient {
    /**
     * Subscribes to updates about contracts. Like the head block number, tps, etc.
     *
     * @generated from protobuf rpc: SubscribeContracts
     */
    subscribeContracts(input: SubscribeContractsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeContractsRequest, SubscribeContractsResponse>;
    /**
     * Retrieves metadata about the World including all the registered components and systems.
     *
     * @generated from protobuf rpc: Worlds
     */
    worlds(input: WorldsRequest, options?: RpcOptions): UnaryCall<WorldsRequest, WorldsResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEntities
     */
    subscribeEntities(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEntitiesSubscription
     */
    updateEntitiesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEntities
     */
    retrieveEntities(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEventMessages
     */
    subscribeEventMessages(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEventMessagesSubscription
     */
    updateEventMessagesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token balance updates.
     *
     * @generated from protobuf rpc: SubscribeTokenBalances
     */
    subscribeTokenBalances(input: SubscribeTokenBalancesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse>;
    /**
     * Update token balance subscription
     *
     * @generated from protobuf rpc: UpdateTokenBalancesSubscription
     */
    updateTokenBalancesSubscription(input: UpdateTokenBalancesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenBalancesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token updates.
     *
     * @generated from protobuf rpc: SubscribeTokens
     */
    subscribeTokens(input: SubscribeTokensRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokensRequest, SubscribeTokensResponse>;
    /**
     * Update token subscription
     *
     * @generated from protobuf rpc: UpdateTokensSubscription
     */
    updateTokensSubscription(input: UpdateTokenSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenSubscriptionRequest, Empty>;
    /**
     * Subscribe to token transfer updates.
     *
     * @generated from protobuf rpc: SubscribeTokenTransfers
     */
    subscribeTokenTransfers(input: SubscribeTokenTransfersRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenTransfersRequest, SubscribeTokenTransfersResponse>;
    /**
     * Update token transfer subscription
     *
     * @generated from protobuf rpc: UpdateTokenTransfersSubscription
     */
    updateTokenTransfersSubscription(input: UpdateTokenTransfersSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenTransfersSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEventMessages
     */
    retrieveEventMessages(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;
    /**
     * Retrieve events
     *
     * @generated from protobuf rpc: RetrieveEvents
     */
    retrieveEvents(input: RetrieveEventsRequest, options?: RpcOptions): UnaryCall<RetrieveEventsRequest, RetrieveEventsResponse>;
    /**
     * Subscribe to events
     *
     * @generated from protobuf rpc: SubscribeEvents
     */
    subscribeEvents(input: SubscribeEventsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventsRequest, SubscribeEventsResponse>;
    /**
     * Retrieve tokens
     *
     * @generated from protobuf rpc: RetrieveTokens
     */
    retrieveTokens(input: RetrieveTokensRequest, options?: RpcOptions): UnaryCall<RetrieveTokensRequest, RetrieveTokensResponse>;
    /**
     * Retrieve token transfers
     *
     * @generated from protobuf rpc: RetrieveTokenTransfers
     */
    retrieveTokenTransfers(input: RetrieveTokenTransfersRequest, options?: RpcOptions): UnaryCall<RetrieveTokenTransfersRequest, RetrieveTokenTransfersResponse>;
    /**
     * Retrieve token balances
     *
     * @generated from protobuf rpc: RetrieveTokenBalances
     */
    retrieveTokenBalances(input: RetrieveTokenBalancesRequest, options?: RpcOptions): UnaryCall<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse>;
    /**
     * Retrieve transactions
     *
     * @generated from protobuf rpc: RetrieveTransactions
     */
    retrieveTransactions(input: RetrieveTransactionsRequest, options?: RpcOptions): UnaryCall<RetrieveTransactionsRequest, RetrieveTransactionsResponse>;
    /**
     * Subscribe to transactions
     *
     * @generated from protobuf rpc: SubscribeTransactions
     */
    subscribeTransactions(input: SubscribeTransactionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTransactionsRequest, SubscribeTransactionsResponse>;
    /**
     * Retrieve controllers
     *
     * @generated from protobuf rpc: RetrieveControllers
     */
    retrieveControllers(input: RetrieveControllersRequest, options?: RpcOptions): UnaryCall<RetrieveControllersRequest, RetrieveControllersResponse>;
    /**
     * Retrieve contracts
     *
     * @generated from protobuf rpc: RetrieveContracts
     */
    retrieveContracts(input: RetrieveContractsRequest, options?: RpcOptions): UnaryCall<RetrieveContractsRequest, RetrieveContractsResponse>;
    /**
     * Retrieve token contracts
     *
     * @generated from protobuf rpc: RetrieveTokenContracts
     */
    retrieveTokenContracts(input: RetrieveTokenContractsRequest, options?: RpcOptions): UnaryCall<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse>;
    /**
     * Retrieve aggregations (leaderboards, stats, rankings)
     *
     * @generated from protobuf rpc: RetrieveAggregations
     */
    retrieveAggregations(input: RetrieveAggregationsRequest, options?: RpcOptions): UnaryCall<RetrieveAggregationsRequest, RetrieveAggregationsResponse>;
    /**
     * Subscribe to aggregation updates (leaderboards, stats, rankings)
     *
     * @generated from protobuf rpc: SubscribeAggregations
     */
    subscribeAggregations(input: SubscribeAggregationsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeAggregationsRequest, SubscribeAggregationsResponse>;
    /**
     * Update an aggregations subscription
     *
     * @generated from protobuf rpc: UpdateAggregationsSubscription
     */
    updateAggregationsSubscription(input: UpdateAggregationsSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateAggregationsSubscriptionRequest, UpdateAggregationsSubscriptionResponse>;
    /**
     * Retrieve activities (user session tracking)
     *
     * @generated from protobuf rpc: RetrieveActivities
     */
    retrieveActivities(input: RetrieveActivitiesRequest, options?: RpcOptions): UnaryCall<RetrieveActivitiesRequest, RetrieveActivitiesResponse>;
    /**
     * Subscribe to activity updates (user session tracking)
     *
     * @generated from protobuf rpc: SubscribeActivities
     */
    subscribeActivities(input: SubscribeActivitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeActivitiesRequest, SubscribeActivitiesResponse>;
    /**
     * Update an activities subscription
     *
     * @generated from protobuf rpc: UpdateActivitiesSubscription
     */
    updateActivitiesSubscription(input: UpdateActivitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateActivitiesSubscriptionRequest, Empty>;
    /**
     * Retrieve achievements
     *
     * @generated from protobuf rpc: RetrieveAchievements
     */
    retrieveAchievements(input: RetrieveAchievementsRequest, options?: RpcOptions): UnaryCall<RetrieveAchievementsRequest, RetrieveAchievementsResponse>;
    /**
     * Retrieve player achievements (stats + progress)
     *
     * @generated from protobuf rpc: RetrievePlayerAchievements
     */
    retrievePlayerAchievements(input: RetrievePlayerAchievementsRequest, options?: RpcOptions): UnaryCall<RetrievePlayerAchievementsRequest, RetrievePlayerAchievementsResponse>;
    /**
     * Global FTS5 search across indexed tables
     *
     * @generated from protobuf rpc: Search
     */
    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse>;
    /**
     * Subscribe to achievement progression updates
     *
     * @generated from protobuf rpc: SubscribeAchievementProgressions
     */
    subscribeAchievementProgressions(input: SubscribeAchievementProgressionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeAchievementProgressionsRequest, SubscribeAchievementProgressionsResponse>;
    /**
     * Update an achievement progressions subscription
     *
     * @generated from protobuf rpc: UpdateAchievementProgressionsSubscription
     */
    updateAchievementProgressionsSubscription(input: UpdateAchievementProgressionsSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateAchievementProgressionsSubscriptionRequest, Empty>;
    /**
     * Publish a torii offchain message
     *
     * @generated from protobuf rpc: PublishMessage
     */
    publishMessage(input: PublishMessageRequest, options?: RpcOptions): UnaryCall<PublishMessageRequest, PublishMessageResponse>;
    /**
     * Publish a set of torii offchain messages
     *
     * @generated from protobuf rpc: PublishMessageBatch
     */
    publishMessageBatch(input: PublishMessageBatchRequest, options?: RpcOptions): UnaryCall<PublishMessageBatchRequest, PublishMessageBatchResponse>;
    /**
     * Execute a SQL query and return results
     *
     * @generated from protobuf rpc: ExecuteSql
     */
    executeSql(input: SqlQueryRequest, options?: RpcOptions): UnaryCall<SqlQueryRequest, SqlQueryResponse$1>;
}
/**
 * The World service provides information about the world.
 *
 * @generated from protobuf service world.World
 */
declare class WorldClient implements IWorldClient, ServiceInfo {
    private readonly _transport;
    typeName: string;
    methods: _protobuf_ts_runtime_rpc.MethodInfo<any, any>[];
    options: {
        [extensionName: string]: _protobuf_ts_runtime.JsonValue;
    };
    constructor(_transport: RpcTransport);
    /**
     * Subscribes to updates about contracts. Like the head block number, tps, etc.
     *
     * @generated from protobuf rpc: SubscribeContracts
     */
    subscribeContracts(input: SubscribeContractsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeContractsRequest, SubscribeContractsResponse>;
    /**
     * Retrieves metadata about the World including all the registered components and systems.
     *
     * @generated from protobuf rpc: Worlds
     */
    worlds(input: WorldsRequest, options?: RpcOptions): UnaryCall<WorldsRequest, WorldsResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEntities
     */
    subscribeEntities(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEntitiesSubscription
     */
    updateEntitiesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEntities
     */
    retrieveEntities(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;
    /**
     * Subscribe to entity updates.
     *
     * @generated from protobuf rpc: SubscribeEventMessages
     */
    subscribeEventMessages(input: SubscribeEntitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEntitiesRequest, SubscribeEntityResponse>;
    /**
     * Update entity subscription
     *
     * @generated from protobuf rpc: UpdateEventMessagesSubscription
     */
    updateEventMessagesSubscription(input: UpdateEntitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateEntitiesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token balance updates.
     *
     * @generated from protobuf rpc: SubscribeTokenBalances
     */
    subscribeTokenBalances(input: SubscribeTokenBalancesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse>;
    /**
     * Update token balance subscription
     *
     * @generated from protobuf rpc: UpdateTokenBalancesSubscription
     */
    updateTokenBalancesSubscription(input: UpdateTokenBalancesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenBalancesSubscriptionRequest, Empty>;
    /**
     * Subscribe to token updates.
     *
     * @generated from protobuf rpc: SubscribeTokens
     */
    subscribeTokens(input: SubscribeTokensRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokensRequest, SubscribeTokensResponse>;
    /**
     * Update token subscription
     *
     * @generated from protobuf rpc: UpdateTokensSubscription
     */
    updateTokensSubscription(input: UpdateTokenSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenSubscriptionRequest, Empty>;
    /**
     * Subscribe to token transfer updates.
     *
     * @generated from protobuf rpc: SubscribeTokenTransfers
     */
    subscribeTokenTransfers(input: SubscribeTokenTransfersRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTokenTransfersRequest, SubscribeTokenTransfersResponse>;
    /**
     * Update token transfer subscription
     *
     * @generated from protobuf rpc: UpdateTokenTransfersSubscription
     */
    updateTokenTransfersSubscription(input: UpdateTokenTransfersSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateTokenTransfersSubscriptionRequest, Empty>;
    /**
     * Retrieve entities
     *
     * @generated from protobuf rpc: RetrieveEventMessages
     */
    retrieveEventMessages(input: RetrieveEntitiesRequest, options?: RpcOptions): UnaryCall<RetrieveEntitiesRequest, RetrieveEntitiesResponse>;
    /**
     * Retrieve events
     *
     * @generated from protobuf rpc: RetrieveEvents
     */
    retrieveEvents(input: RetrieveEventsRequest, options?: RpcOptions): UnaryCall<RetrieveEventsRequest, RetrieveEventsResponse>;
    /**
     * Subscribe to events
     *
     * @generated from protobuf rpc: SubscribeEvents
     */
    subscribeEvents(input: SubscribeEventsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeEventsRequest, SubscribeEventsResponse>;
    /**
     * Retrieve tokens
     *
     * @generated from protobuf rpc: RetrieveTokens
     */
    retrieveTokens(input: RetrieveTokensRequest, options?: RpcOptions): UnaryCall<RetrieveTokensRequest, RetrieveTokensResponse>;
    /**
     * Retrieve token transfers
     *
     * @generated from protobuf rpc: RetrieveTokenTransfers
     */
    retrieveTokenTransfers(input: RetrieveTokenTransfersRequest, options?: RpcOptions): UnaryCall<RetrieveTokenTransfersRequest, RetrieveTokenTransfersResponse>;
    /**
     * Retrieve token balances
     *
     * @generated from protobuf rpc: RetrieveTokenBalances
     */
    retrieveTokenBalances(input: RetrieveTokenBalancesRequest, options?: RpcOptions): UnaryCall<RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse>;
    /**
     * Retrieve transactions
     *
     * @generated from protobuf rpc: RetrieveTransactions
     */
    retrieveTransactions(input: RetrieveTransactionsRequest, options?: RpcOptions): UnaryCall<RetrieveTransactionsRequest, RetrieveTransactionsResponse>;
    /**
     * Subscribe to transactions
     *
     * @generated from protobuf rpc: SubscribeTransactions
     */
    subscribeTransactions(input: SubscribeTransactionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeTransactionsRequest, SubscribeTransactionsResponse>;
    /**
     * Retrieve controllers
     *
     * @generated from protobuf rpc: RetrieveControllers
     */
    retrieveControllers(input: RetrieveControllersRequest, options?: RpcOptions): UnaryCall<RetrieveControllersRequest, RetrieveControllersResponse>;
    /**
     * Retrieve contracts
     *
     * @generated from protobuf rpc: RetrieveContracts
     */
    retrieveContracts(input: RetrieveContractsRequest, options?: RpcOptions): UnaryCall<RetrieveContractsRequest, RetrieveContractsResponse>;
    /**
     * Retrieve token contracts
     *
     * @generated from protobuf rpc: RetrieveTokenContracts
     */
    retrieveTokenContracts(input: RetrieveTokenContractsRequest, options?: RpcOptions): UnaryCall<RetrieveTokenContractsRequest, RetrieveTokenContractsResponse>;
    /**
     * Retrieve aggregations (leaderboards, stats, rankings)
     *
     * @generated from protobuf rpc: RetrieveAggregations
     */
    retrieveAggregations(input: RetrieveAggregationsRequest, options?: RpcOptions): UnaryCall<RetrieveAggregationsRequest, RetrieveAggregationsResponse>;
    /**
     * Subscribe to aggregation updates (leaderboards, stats, rankings)
     *
     * @generated from protobuf rpc: SubscribeAggregations
     */
    subscribeAggregations(input: SubscribeAggregationsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeAggregationsRequest, SubscribeAggregationsResponse>;
    /**
     * Update an aggregations subscription
     *
     * @generated from protobuf rpc: UpdateAggregationsSubscription
     */
    updateAggregationsSubscription(input: UpdateAggregationsSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateAggregationsSubscriptionRequest, UpdateAggregationsSubscriptionResponse>;
    /**
     * Retrieve activities (user session tracking)
     *
     * @generated from protobuf rpc: RetrieveActivities
     */
    retrieveActivities(input: RetrieveActivitiesRequest, options?: RpcOptions): UnaryCall<RetrieveActivitiesRequest, RetrieveActivitiesResponse>;
    /**
     * Subscribe to activity updates (user session tracking)
     *
     * @generated from protobuf rpc: SubscribeActivities
     */
    subscribeActivities(input: SubscribeActivitiesRequest, options?: RpcOptions): ServerStreamingCall<SubscribeActivitiesRequest, SubscribeActivitiesResponse>;
    /**
     * Update an activities subscription
     *
     * @generated from protobuf rpc: UpdateActivitiesSubscription
     */
    updateActivitiesSubscription(input: UpdateActivitiesSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateActivitiesSubscriptionRequest, Empty>;
    /**
     * Retrieve achievements
     *
     * @generated from protobuf rpc: RetrieveAchievements
     */
    retrieveAchievements(input: RetrieveAchievementsRequest, options?: RpcOptions): UnaryCall<RetrieveAchievementsRequest, RetrieveAchievementsResponse>;
    /**
     * Retrieve player achievements (stats + progress)
     *
     * @generated from protobuf rpc: RetrievePlayerAchievements
     */
    retrievePlayerAchievements(input: RetrievePlayerAchievementsRequest, options?: RpcOptions): UnaryCall<RetrievePlayerAchievementsRequest, RetrievePlayerAchievementsResponse>;
    /**
     * Global FTS5 search across indexed tables
     *
     * @generated from protobuf rpc: Search
     */
    search(input: SearchRequest, options?: RpcOptions): UnaryCall<SearchRequest, SearchResponse>;
    /**
     * Subscribe to achievement progression updates
     *
     * @generated from protobuf rpc: SubscribeAchievementProgressions
     */
    subscribeAchievementProgressions(input: SubscribeAchievementProgressionsRequest, options?: RpcOptions): ServerStreamingCall<SubscribeAchievementProgressionsRequest, SubscribeAchievementProgressionsResponse>;
    /**
     * Update an achievement progressions subscription
     *
     * @generated from protobuf rpc: UpdateAchievementProgressionsSubscription
     */
    updateAchievementProgressionsSubscription(input: UpdateAchievementProgressionsSubscriptionRequest, options?: RpcOptions): UnaryCall<UpdateAchievementProgressionsSubscriptionRequest, Empty>;
    /**
     * Publish a torii offchain message
     *
     * @generated from protobuf rpc: PublishMessage
     */
    publishMessage(input: PublishMessageRequest, options?: RpcOptions): UnaryCall<PublishMessageRequest, PublishMessageResponse>;
    /**
     * Publish a set of torii offchain messages
     *
     * @generated from protobuf rpc: PublishMessageBatch
     */
    publishMessageBatch(input: PublishMessageBatchRequest, options?: RpcOptions): UnaryCall<PublishMessageBatchRequest, PublishMessageBatchResponse>;
    /**
     * Execute a SQL query and return results
     *
     * @generated from protobuf rpc: ExecuteSql
     */
    executeSql(input: SqlQueryRequest, options?: RpcOptions): UnaryCall<SqlQueryRequest, SqlQueryResponse$1>;
}

interface DojoGrpcClientConfig {
    url: string;
    options?: RpcOptions;
}
declare class DojoGrpcClient {
    private transport;
    worldClient: WorldClient;
    constructor(config: DojoGrpcClientConfig);
    destroy(): void;
}
declare function createDojoGrpcClient(config: DojoGrpcClientConfig): DojoGrpcClient;

interface Page<T> {
    items: T[];
    next_cursor: string | undefined;
}

type WasmU256 = string;

type Controllers = Page<Controller>;

interface Controller {
    address: string;
    username: string;
    deployed_at_timestamp: number;
}

type Tokens = Page<Token>;

type TokenBalances = Page<TokenBalance>;

type TokenContracts = Page<TokenContract>;

type TokenTransfers = Page<TokenTransfer>;

interface Token {
    contract_address: string;
    token_id: string | undefined;
    name: string;
    symbol: string;
    decimals: number;
    metadata: string;
    total_supply: string | undefined;
}

interface TokenContract {
    contract_address: string;
    name: string;
    symbol: string;
    decimals: number;
    metadata: string;
    token_metadata: string;
    total_supply: string | undefined;
}

interface TokenBalance {
    balance: string;
    account_address: string;
    contract_address: string;
    token_id: string | undefined;
}

interface TokenTransfer {
    id: string;
    contract_address: string;
    from_address: string;
    to_address: string;
    amount: string;
    token_id: string | undefined;
    executed_at: number;
    event_id: string | undefined;
}

interface TokenTransferQuery {
    contract_addresses: string[];
    account_addresses: string[];
    token_ids: string[];
    pagination: Pagination;
}

interface TransactionFilter {
    transaction_hashes: string[];
    caller_addresses: string[];
    contract_addresses: string[];
    entrypoints: string[];
    model_selectors: string[];
    from_block: number | undefined;
    to_block: number | undefined;
}

interface TransactionQuery {
    filter: TransactionFilter | undefined;
    pagination: Pagination;
}

type Transactions = Page<Transaction>;

interface Transaction {
    transaction_hash: string;
    sender_address: string;
    calldata: string[];
    max_fee: string;
    signature: string[];
    nonce: string;
    block_number: number;
    transaction_type: string;
    block_timestamp: number;
    calls: TransactionCall[];
    unique_models: string[];
}

type CallType = "Execute" | "ExecuteFromOutside";

interface TransactionCall {
    contract_address: string;
    entrypoint: string;
    calldata: string[];
    call_type: CallType;
    caller_address: string;
}

interface ControllerQuery {
    contract_addresses: string[];
    usernames: string[];
    pagination: Pagination;
}

interface AttributeFilter {
    trait_name: string;
    trait_value: string;
}

interface TokenQuery {
    contract_addresses: string[];
    token_ids: string[];
    attribute_filters: AttributeFilter[];
    pagination: Pagination;
}

interface TokenBalanceQuery {
    contract_addresses: string[];
    account_addresses: string[];
    token_ids: string[];
    pagination: Pagination;
}

interface TokenContractQuery {
    contract_addresses: string[];
    contract_types: ContractType[];
    pagination: Pagination;
}

type ContractType = "WORLD" | "ERC20" | "ERC721" | "ERC1155" | "UDC" | "OTHER";

interface ClientConfig {
    toriiUrl: string;
    worldAddress: string;
}

interface Ty {
    type: "primitive" | "struct" | "enum" | "array" | "tuple" | "bytearray" | "fixed_size_array";
    type_name: string;
    value: boolean | number | string | Ty | Record<string, Ty> | Array<Ty> | EnumValue | FixedSizeArray | null;
    key: boolean;
}

interface FixedSizeArray {
    array: Ty[];
    size: number;
}

interface EnumValue {
    option: string;
    value: Ty;
}

type Model = Record<string, Ty>;

interface Entity {
    world_address: string;
    hashed_keys: string;
    models: Record<string, Model>;
    created_at: number;
    updated_at: number;
    executed_at: number;
}

type Entities = Page<Entity>;

interface Query {
    world_addresses: string[];
    pagination: Pagination;
    clause: Clause | undefined;
    no_hashed_keys: boolean;
    models: string[];
    historical: boolean;
}

interface Pagination {
    limit: number | undefined;
    cursor: string | undefined;
    direction: PaginationDirection;
    order_by: OrderBy[];
}

type PaginationDirection = "Forward" | "Backward";

interface OrderBy {
    field: string;
    direction: OrderDirection;
}

type OrderDirection = "Asc" | "Desc";

type Clause = { HashedKeys: string[] } | { Keys: KeysClause } | { Member: MemberClause } | { Composite: CompositeClause };

type PatternMatching = "FixedLen" | "VariableLen";

interface KeysClause {
    keys: (string | undefined)[];
    pattern_matching: PatternMatching;
    models: string[];
}

type MemberValue = { Primitive: Primitive } | { String: string } | { List: MemberValue[] };

interface MemberClause {
    model: string;
    member: string;
    operator: ComparisonOperator;
    value: MemberValue;
}

interface CompositeClause {
    operator: LogicalOperator;
    clauses: Clause[];
}

type LogicalOperator = "And" | "Or";

type ComparisonOperator = "Eq" | "Neq" | "Gt" | "Gte" | "Lt" | "Lte" | "In" | "NotIn";

type Primitive = { I8: number | undefined } | { I16: number | undefined } | { I32: number | undefined } | { I64: number | undefined } | { I128: string | undefined } | { U8: number | undefined } | { U16: number | undefined } | { U32: number | undefined } | { U64: number | undefined } | { U128: string | undefined } | { U256: string | undefined } | { Bool: boolean | undefined } | { Felt252: string | undefined } | { ClassHash: string | undefined } | { ContractAddress: string | undefined } | { EthAddress: string | undefined };

interface Message {
    message: string;
    signature: string[];
    world_address: string;
}

interface AggregationQuery {
    aggregator_ids: string[];
    entity_ids: string[];
    pagination: Pagination;
}

interface ActivityQuery {
    world_addresses: string[];
    namespaces: string[];
    caller_addresses: string[];
    from_time: string | undefined;
    to_time: string | undefined;
    pagination: Pagination;
}

interface AchievementQuery {
    world_addresses: string[];
    namespaces: string[];
    hidden: boolean | undefined;
    pagination: Pagination;
}

interface PlayerAchievementQuery {
    world_addresses: string[];
    namespaces: string[];
    player_addresses: string[];
    pagination: Pagination;
}

interface AggregationQueryInput {
    aggregatorIds?: string[];
    entityIds?: string[];
    pagination?: Pagination;
}
interface AggregationEntryView {
    id: string;
    aggregatorId: string;
    entityId: string;
    value: string;
    displayValue: string;
    position: number;
    modelId: string;
    createdAt: number;
    updatedAt: number;
}
interface AggregationsPage {
    items: AggregationEntryView[];
    nextCursor?: string;
    next_cursor?: string;
}
interface ActivityQueryInput {
    worldAddresses?: string[];
    namespaces?: string[];
    callerAddresses?: string[];
    fromTime?: number | string;
    toTime?: number | string;
    pagination?: Pagination;
}
interface ActivitySubscriptionQuery {
    worldAddresses?: string[];
    namespaces?: string[];
    callerAddresses?: string[];
}
interface ActivityEntry {
    id: string;
    worldAddress: string;
    namespace: string;
    callerAddress: string;
    sessionStart: number;
    sessionEnd: number;
    actionCount: number;
    actions: Record<string, number>;
    updatedAt: number;
}
interface ActivitiesPage {
    items: ActivityEntry[];
    nextCursor?: string;
    next_cursor?: string;
}
interface AchievementQueryInput {
    worldAddresses?: string[];
    namespaces?: string[];
    hidden?: boolean;
    pagination?: Pagination;
}
interface PlayerAchievementQueryInput {
    worldAddresses?: string[];
    namespaces?: string[];
    playerAddresses?: string[];
    pagination?: Pagination;
}
type PlayerAchievementEntryView = PlayerAchievementEntryData;
interface AchievementsPage {
    items: AchievementData[];
    nextCursor?: string;
    next_cursor?: string;
}
interface PlayerAchievementsPage {
    items: PlayerAchievementEntryView[];
    nextCursor?: string;
    next_cursor?: string;
}
interface AchievementProgressionView {
    id: string;
    achievementId: string;
    taskId: string;
    worldAddress: string;
    namespace: string;
    playerId: string;
    count: number;
    completed: boolean;
    completedAt?: number;
    createdAt: number;
    updatedAt: number;
}
interface AchievementProgressionSubscriptionQuery {
    worldAddresses?: string[];
    namespaces?: string[];
    playerAddresses?: string[];
    achievementIds?: string[];
}
type SqlIntegerValue = bigint | string;
type SqlQueryScalar = string | number | SqlIntegerValue | null;
type SqlQueryRow = Record<string, SqlQueryScalar>;
type SqlQueryResponse = SqlQueryRow[];
interface AchievementTaskData {
    task_id: string;
    description: string;
    total: number;
    total_completions: number;
    completion_rate: number;
    created_at: number;
}
interface AchievementData {
    id: string;
    world_address: string;
    namespace: string;
    entity_id: string;
    hidden: boolean;
    index: number;
    points: number;
    start: string;
    end: string;
    group: string;
    icon: string;
    title: string;
    description: string;
    tasks: AchievementTaskData[];
    data: string;
    total_completions: number;
    completion_rate: number;
    created_at: number;
    updated_at: number;
}
interface TaskProgressData {
    task_id: string;
    count: number;
    completed: boolean;
}
interface PlayerAchievementStatsData {
    total_points: number;
    completed_achievements: number;
    total_achievements: number;
    completion_percentage: number;
    last_achievement_at?: number;
    created_at: number;
    updated_at: number;
}
interface PlayerAchievementProgressData {
    achievement: AchievementData;
    task_progress: TaskProgressData[];
    completed: boolean;
    progress_percentage: number;
}
interface PlayerAchievementEntryData {
    player_address: string;
    stats: PlayerAchievementStatsData;
    achievements: PlayerAchievementProgressData[];
}
interface SearchQueryInput {
    query: string;
    limit?: number;
}
interface SearchMatch {
    id: string;
    fields: Record<string, string>;
    score?: number;
}
interface TableSearchResults {
    table: string;
    matches: SearchMatch[];
}
interface SearchResultsView {
    total: number;
    results: TableSearchResults[];
}

interface ToriiSubscription$1 {
    id: bigint;
    stream: ServerStreamingCall<object, object>;
    cancel: () => void;
    lastMessage?: object;
}
declare class Subscription$1 {
    private _subscription;
    constructor(subscription: ToriiSubscription$1);
    cancel(): void;
    free(): void;
    [Symbol.dispose](): void;
    get id(): bigint;
}
interface ToriiGrpcClientConfig extends ClientConfig {
    useEffectSchema?: boolean;
    autoReconnect?: boolean;
    maxReconnectAttempts?: number;
}
declare class ToriiGrpcClient {
    private client;
    private nextSubscriptionId;
    private subscriptions;
    private useEffectSchema;
    private autoReconnect;
    private maxReconnectAttempts;
    private worldAddress;
    private worldAddressBytes;
    private defaultWorldAddresses;
    private mappers;
    constructor(config: ToriiGrpcClientConfig);
    private createStreamSubscription;
    private cloneWorldAddresses;
    private normalizeWorldAddresses;
    private ensureWorldAddressesList;
    private buildPagination;
    private toAchievementQueryInput;
    private toPlayerAchievementQueryInput;
    private toAchievementProgressionFilters;
    private toActivitySubscriptionFilters;
    getControllers(query: ControllerQuery): Promise<Controllers>;
    getTransactions(query: TransactionQuery): Promise<Transactions>;
    getTokens(query: TokenQuery): Promise<Tokens>;
    getTokenBalances(query: TokenBalanceQuery): Promise<TokenBalances>;
    getTokenContracts(query: TokenContractQuery): Promise<TokenContracts>;
    getTokenTransfers(query: TokenTransferQuery): Promise<TokenTransfers>;
    getAchievements(query: AchievementQuery): Promise<AchievementsPage>;
    getPlayerAchievements(query: PlayerAchievementQuery): Promise<PlayerAchievementsPage>;
    getEntities(query: Query): Promise<Entities>;
    getAllEntities(limit: number, cursor?: string | null): Promise<Entities>;
    getEventMessages(query: Query): Promise<Entities>;
    onTransaction(filter: TransactionFilter | null | undefined, callback: Function): Promise<Subscription$1>;
    onTokenUpdated(contract_addresses: string[] | null | undefined, token_ids: WasmU256[] | null | undefined, callback: Function, onError?: (error: Error) => void): Promise<Subscription$1>;
    onEntityUpdated(clause: Clause | null | undefined, world_addresses: string[] | null | undefined, callback: Function, onError?: (error: Error) => void): Promise<Subscription$1>;
    updateEntitySubscription(subscription: Subscription$1, clause?: Clause | null, world_addresses?: string[] | null): Promise<void>;
    onEventMessageUpdated(clause: Clause | null | undefined, world_addresses: string[] | null | undefined, callback: Function): Promise<Subscription$1>;
    updateEventMessageSubscription(subscription: Subscription$1, clause?: Clause | null, world_addresses?: string[] | null): Promise<void>;
    onStarknetEvent(clauses: KeysClause[], callback: Function, onError?: (error: Error) => void): Promise<Subscription$1>;
    onIndexerUpdated(contract_address: string | null | undefined, callback: Function): Promise<Subscription$1>;
    onTokenBalanceUpdated(contract_addresses: string[] | null | undefined, account_addresses: string[] | null | undefined, token_ids: WasmU256[] | null | undefined, callback: Function): Promise<Subscription$1>;
    updateTokenBalanceSubscription(subscription: Subscription$1, contract_addresses: string[], account_addresses: string[], token_ids: WasmU256[]): Promise<void>;
    onTokenTransferUpdated(contract_addresses: string[] | null | undefined, account_addresses: string[] | null | undefined, token_ids: WasmU256[] | null | undefined, callback: Function): Promise<Subscription$1>;
    updateTokenTransferSubscription(subscription: Subscription$1, contract_addresses: string[], account_addresses: string[], token_ids: WasmU256[]): Promise<void>;
    onAchievementProgressionUpdated(world_addresses: string[] | null | undefined, namespaces: string[] | null | undefined, player_addresses: string[] | null | undefined, achievement_ids: string[] | null | undefined, callback: Function): Promise<Subscription$1>;
    updateAchievementProgressionSubscription(subscription: Subscription$1, world_addresses: string[], namespaces: string[], player_addresses: string[], achievement_ids: string[]): Promise<void>;
    publishMessage(message: Message): Promise<string>;
    publishMessageBatch(messages: Message[]): Promise<string[]>;
    getWorldMetadata(): Promise<any>;
    getWorlds(worldAddresses?: string[]): Promise<any[]>;
    getEvents(query: {
        keys?: KeysClause;
        pagination?: Pagination;
    }): Promise<any>;
    getContracts(query?: {
        contract_addresses?: string[];
        contract_types?: ContractType$1[];
    }): Promise<any>;
    getAggregations(query: AggregationQuery): Promise<AggregationsPage>;
    updateTokensSubscription(subscription: Subscription$1, contractAddresses?: string[], tokenIds?: WasmU256[]): Promise<void>;
    onContractsUpdated(query: {
        contract_addresses?: string[];
        contract_types?: ContractType$1[];
    }, callback: Function): Promise<Subscription$1>;
    onAggregationUpdated(aggregator_ids: string[] | null | undefined, entity_ids: string[] | null | undefined, callback: Function): Promise<Subscription$1>;
    updateAggregationSubscription(subscription: Subscription$1, aggregator_ids: string[], entity_ids: string[]): Promise<void>;
    getActivities(query: ActivityQuery): Promise<ActivitiesPage>;
    onActivityUpdated(world_addresses: string[] | null | undefined, namespaces: string[] | null | undefined, caller_addresses: string[] | null | undefined, callback: Function): Promise<Subscription$1>;
    updateActivitySubscription(subscription: Subscription$1, world_addresses: string[], namespaces: string[], caller_addresses: string[]): Promise<void>;
    executeSql(query: string): Promise<SqlQueryResponse>;
    search(query: SearchQueryInput): Promise<SearchResultsView>;
    private findSubscription;
    destroy(): void;
}

interface ToriiSubscription {
    readonly id: bigint;
    stream?: ServerStreamingCall<object, object>;
    readonly cancel: () => void;
    lastMessage?: object;
}
declare class Subscription {
    private readonly _subscription;
    constructor(_subscription: ToriiSubscription);
    cancel(): void;
    free(): void;
    [Symbol.dispose](): void;
    get id(): bigint;
}
interface ToriiClientConfig {
    readonly toriiUrl: string;
    readonly worldAddress: string;
    readonly autoReconnect?: boolean;
    readonly maxReconnectAttempts?: number;
}
interface ToriiClient {
    readonly getEntities: (query: Query) => Promise<Entities>;
    readonly getAllEntities: (limit: number, cursor?: string | null) => Promise<Entities>;
    readonly getEventMessages: (query: Query) => Promise<Entities>;
    readonly getControllers: (query: ControllerQuery) => Promise<Controllers>;
    readonly getTransactions: (query: TransactionQuery) => Promise<Transactions>;
    readonly getTokens: (query: TokenQuery) => Promise<Tokens>;
    readonly getTokenBalances: (query: TokenBalanceQuery) => Promise<TokenBalances>;
    readonly getTokenContracts: (query: TokenContractQuery) => Promise<TokenContracts>;
    readonly getTokenTransfers: (query: TokenTransferQuery) => Promise<TokenTransfers>;
    readonly getAchievements: (query: AchievementQuery) => Promise<AchievementsPage>;
    readonly getPlayerAchievements: (query: PlayerAchievementQuery) => Promise<PlayerAchievementsPage>;
    readonly getWorldMetadata: () => Promise<any>;
    readonly getWorlds: (worldAddresses?: string[]) => Promise<any[]>;
    readonly getEvents: (query: {
        keys?: KeysClause;
        pagination?: Pagination;
    }) => Promise<any>;
    readonly getContracts: (query?: {
        contract_addresses?: string[];
        contract_types?: ContractType$1[];
    }) => Promise<any>;
    readonly getAggregations: (query: AggregationQuery) => Promise<AggregationsPage>;
    readonly getActivities: (query: ActivityQuery) => Promise<ActivitiesPage>;
    readonly search: (query: SearchQueryInput) => Promise<SearchResultsView>;
    readonly executeSql: (query: string) => Promise<SqlQueryResponse>;
    readonly publishMessage: (message: Message) => Promise<string>;
    readonly publishMessageBatch: (messages: Message[]) => Promise<string[]>;
    readonly onEntityUpdated: (clause: Clause | null | undefined, world_addresses: string[] | null | undefined, callback: Function, onError?: (error: Error) => void) => Promise<Subscription>;
    readonly onTokenUpdated: (contract_addresses: string[] | null | undefined, token_ids: WasmU256[] | null | undefined, callback: Function, onError?: (error: Error) => void) => Promise<Subscription>;
    readonly onTransaction: (filter: TransactionFilter | null | undefined, callback: Function) => Promise<Subscription>;
    readonly onStarknetEvent: (clauses: KeysClause[], callback: Function, onError?: (error: Error) => void) => Promise<Subscription>;
    readonly destroy: () => void;
}
declare const makeToriiClient: (config: ToriiClientConfig) => ToriiClient;

export { type AchievementProgressionSubscriptionQuery, type AchievementProgressionView, type AchievementQueryInput, type AchievementsPage, type ActivitiesPage, type ActivityEntry, type ActivityQueryInput, type ActivitySubscriptionQuery, type AggregationEntryView, type AggregationQueryInput, type AggregationsPage, Array$, CallType$1 as CallType, Clause$1 as Clause, ComparisonOperator$1 as ComparisonOperator, CompositeClause$1 as CompositeClause, Contract, ContractQuery, ContractType$1 as ContractType, Controller$1 as Controller, ControllerQuery$1 as ControllerQuery, DojoGrpcClient, type DojoGrpcClientConfig, Entity$1 as Entity, Enum, EnumOption, Event, EventQuery, FixedSizeArray$1 as FixedSizeArray, type ToriiClientConfig as FunctionalToriiClientConfig, HashedKeysClause, KeysClause$1 as KeysClause, LogicalOperator$1 as LogicalOperator, Member, MemberClause$1 as MemberClause, MemberValue$1 as MemberValue, MemberValueList, Model$1 as Model, OrderBy$1 as OrderBy, OrderDirection$1 as OrderDirection, Pagination$1 as Pagination, PaginationDirection$1 as PaginationDirection, PatternMatching$1 as PatternMatching, type PlayerAchievementQueryInput, type PlayerAchievementsPage, Primitive$1 as Primitive, PublishMessageBatchRequest, PublishMessageBatchResponse, PublishMessageRequest, PublishMessageResponse, Query$1 as Query, RetrieveActivitiesRequest, RetrieveActivitiesResponse, RetrieveAggregationsRequest, RetrieveAggregationsResponse, RetrieveContractsRequest, RetrieveContractsResponse, RetrieveControllersRequest, RetrieveControllersResponse, RetrieveEntitiesRequest, RetrieveEntitiesResponse, RetrieveEventsRequest, RetrieveEventsResponse, RetrieveTokenBalancesRequest, RetrieveTokenBalancesResponse, RetrieveTokenContractsRequest, RetrieveTokenContractsResponse, RetrieveTokenTransfersRequest, RetrieveTokenTransfersResponse, RetrieveTokensRequest, RetrieveTokensResponse, RetrieveTransactionsRequest, RetrieveTransactionsResponse, type SqlIntegerValue, type SqlQueryResponse, type SqlQueryRow, type SqlQueryScalar, Struct, SubscribeActivitiesRequest, SubscribeActivitiesResponse, SubscribeAggregationsRequest, SubscribeAggregationsResponse, SubscribeContractsRequest, SubscribeContractsResponse, SubscribeEntitiesRequest, SubscribeEntityResponse, SubscribeEventsRequest, SubscribeEventsResponse, SubscribeTokenBalancesRequest, SubscribeTokenBalancesResponse, SubscribeTokenTransfersRequest, SubscribeTokenTransfersResponse, SubscribeTokensRequest, SubscribeTokensResponse, SubscribeTransactionsRequest, SubscribeTransactionsResponse, Subscription$1 as Subscription, Token$1 as Token, TokenBalance$1 as TokenBalance, TokenBalanceQuery$1 as TokenBalanceQuery, TokenContract$1 as TokenContract, TokenQuery$1 as TokenQuery, TokenTransfer$1 as TokenTransfer, TokenTransferQuery$1 as TokenTransferQuery, type ToriiClient, ToriiGrpcClient, type ToriiGrpcClientConfig, Transaction$1 as Transaction, TransactionCall$1 as TransactionCall, TransactionFilter$1 as TransactionFilter, TransactionQuery$1 as TransactionQuery, Ty$1 as Ty, UpdateActivitiesSubscriptionRequest, UpdateAggregationsSubscriptionRequest, UpdateAggregationsSubscriptionResponse, UpdateEntitiesSubscriptionRequest, UpdateTokenBalancesSubscriptionRequest, UpdateTokenSubscriptionRequest, UpdateTokenTransfersSubscriptionRequest, WorldClient, World$1 as WorldMessage, World as WorldService, WorldsRequest, WorldsResponse, createDojoGrpcClient, makeToriiClient };
