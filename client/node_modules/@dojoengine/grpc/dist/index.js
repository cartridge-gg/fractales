// src/client.ts
import { GrpcWebFetchTransport } from "@protobuf-ts/grpcweb-transport";

// src/generated/types.ts
import { WireType as WireType2 } from "@protobuf-ts/runtime";
import { UnknownFieldHandler as UnknownFieldHandler2 } from "@protobuf-ts/runtime";
import { reflectionMergePartial as reflectionMergePartial2 } from "@protobuf-ts/runtime";
import { MessageType as MessageType2 } from "@protobuf-ts/runtime";

// src/generated/schema.ts
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
var EnumOption$Type = class extends MessageType {
  constructor() {
    super("types.EnumOption", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ty", kind: "message", T: () => Ty }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* types.Ty ty */
        2:
          message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.ty)
      Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var EnumOption = new EnumOption$Type();
var Enum$Type = class extends MessageType {
  constructor() {
    super("types.Enum", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "option",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "options", kind: "message", repeat: 2, T: () => EnumOption }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.option = 0;
    message.options = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* uint32 option */
        2:
          message.option = reader.uint32();
          break;
        case /* repeated types.EnumOption options */
        3:
          message.options.push(EnumOption.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.option !== 0)
      writer.tag(2, WireType.Varint).uint32(message.option);
    for (let i = 0; i < message.options.length; i++)
      EnumOption.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Enum = new Enum$Type();
var Primitive$Type = class extends MessageType {
  constructor() {
    super("types.Primitive", [
      {
        no: 1,
        name: "i8",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "i16",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "i32",
        kind: "scalar",
        oneof: "primitive_type",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "i64",
        kind: "scalar",
        oneof: "primitive_type",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "i128",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "u8",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "u16",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "u32",
        kind: "scalar",
        oneof: "primitive_type",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 9,
        name: "u64",
        kind: "scalar",
        oneof: "primitive_type",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "u128",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 11,
        name: "u256",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 12,
        name: "bool",
        kind: "scalar",
        oneof: "primitive_type",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "felt252",
        kind: "scalar",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 14,
        name: "class_hash",
        kind: "scalar",
        localName: "class_hash",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 15,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 16,
        name: "eth_address",
        kind: "scalar",
        localName: "eth_address",
        oneof: "primitive_type",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.primitive_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 i8 */
        1:
          message.primitive_type = {
            oneofKind: "i8",
            i8: reader.int32()
          };
          break;
        case /* int32 i16 */
        2:
          message.primitive_type = {
            oneofKind: "i16",
            i16: reader.int32()
          };
          break;
        case /* int32 i32 */
        3:
          message.primitive_type = {
            oneofKind: "i32",
            i32: reader.int32()
          };
          break;
        case /* int64 i64 */
        4:
          message.primitive_type = {
            oneofKind: "i64",
            i64: reader.int64().toBigInt()
          };
          break;
        case /* bytes i128 */
        5:
          message.primitive_type = {
            oneofKind: "i128",
            i128: reader.bytes()
          };
          break;
        case /* uint32 u8 */
        6:
          message.primitive_type = {
            oneofKind: "u8",
            u8: reader.uint32()
          };
          break;
        case /* uint32 u16 */
        7:
          message.primitive_type = {
            oneofKind: "u16",
            u16: reader.uint32()
          };
          break;
        case /* uint32 u32 */
        8:
          message.primitive_type = {
            oneofKind: "u32",
            u32: reader.uint32()
          };
          break;
        case /* uint64 u64 */
        9:
          message.primitive_type = {
            oneofKind: "u64",
            u64: reader.uint64().toBigInt()
          };
          break;
        case /* bytes u128 */
        10:
          message.primitive_type = {
            oneofKind: "u128",
            u128: reader.bytes()
          };
          break;
        case /* bytes u256 */
        11:
          message.primitive_type = {
            oneofKind: "u256",
            u256: reader.bytes()
          };
          break;
        case /* bool bool */
        12:
          message.primitive_type = {
            oneofKind: "bool",
            bool: reader.bool()
          };
          break;
        case /* bytes felt252 */
        13:
          message.primitive_type = {
            oneofKind: "felt252",
            felt252: reader.bytes()
          };
          break;
        case /* bytes class_hash */
        14:
          message.primitive_type = {
            oneofKind: "class_hash",
            class_hash: reader.bytes()
          };
          break;
        case /* bytes contract_address */
        15:
          message.primitive_type = {
            oneofKind: "contract_address",
            contract_address: reader.bytes()
          };
          break;
        case /* bytes eth_address */
        16:
          message.primitive_type = {
            oneofKind: "eth_address",
            eth_address: reader.bytes()
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.primitive_type.oneofKind === "i8")
      writer.tag(1, WireType.Varint).int32(message.primitive_type.i8);
    if (message.primitive_type.oneofKind === "i16")
      writer.tag(2, WireType.Varint).int32(message.primitive_type.i16);
    if (message.primitive_type.oneofKind === "i32")
      writer.tag(3, WireType.Varint).int32(message.primitive_type.i32);
    if (message.primitive_type.oneofKind === "i64")
      writer.tag(4, WireType.Varint).int64(message.primitive_type.i64);
    if (message.primitive_type.oneofKind === "i128")
      writer.tag(5, WireType.LengthDelimited).bytes(message.primitive_type.i128);
    if (message.primitive_type.oneofKind === "u8")
      writer.tag(6, WireType.Varint).uint32(message.primitive_type.u8);
    if (message.primitive_type.oneofKind === "u16")
      writer.tag(7, WireType.Varint).uint32(message.primitive_type.u16);
    if (message.primitive_type.oneofKind === "u32")
      writer.tag(8, WireType.Varint).uint32(message.primitive_type.u32);
    if (message.primitive_type.oneofKind === "u64")
      writer.tag(9, WireType.Varint).uint64(message.primitive_type.u64);
    if (message.primitive_type.oneofKind === "u128")
      writer.tag(10, WireType.LengthDelimited).bytes(message.primitive_type.u128);
    if (message.primitive_type.oneofKind === "u256")
      writer.tag(11, WireType.LengthDelimited).bytes(message.primitive_type.u256);
    if (message.primitive_type.oneofKind === "bool")
      writer.tag(12, WireType.Varint).bool(message.primitive_type.bool);
    if (message.primitive_type.oneofKind === "felt252")
      writer.tag(13, WireType.LengthDelimited).bytes(message.primitive_type.felt252);
    if (message.primitive_type.oneofKind === "class_hash")
      writer.tag(14, WireType.LengthDelimited).bytes(message.primitive_type.class_hash);
    if (message.primitive_type.oneofKind === "contract_address")
      writer.tag(15, WireType.LengthDelimited).bytes(message.primitive_type.contract_address);
    if (message.primitive_type.oneofKind === "eth_address")
      writer.tag(16, WireType.LengthDelimited).bytes(message.primitive_type.eth_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Primitive = new Primitive$Type();
var Struct$Type = class extends MessageType {
  constructor() {
    super("types.Struct", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "children", kind: "message", repeat: 2, T: () => Member }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.children = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* repeated types.Member children */
        2:
          message.children.push(Member.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    for (let i = 0; i < message.children.length; i++)
      Member.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Struct = new Struct$Type();
var Array$$Type = class extends MessageType {
  constructor() {
    super("types.Array", [
      { no: 1, name: "children", kind: "message", repeat: 2, T: () => Ty }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.children = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Ty children */
        1:
          message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.children.length; i++)
      Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Array$ = new Array$$Type();
var FixedSizeArray$Type = class extends MessageType {
  constructor() {
    super("types.FixedSizeArray", [
      { no: 1, name: "children", kind: "message", repeat: 2, T: () => Ty },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.children = [];
    message.size = 0;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Ty children */
        1:
          message.children.push(Ty.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint32 size */
        2:
          message.size = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.children.length; i++)
      Ty.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.size !== 0)
      writer.tag(2, WireType.Varint).uint32(message.size);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var FixedSizeArray = new FixedSizeArray$Type();
var Ty$Type = class extends MessageType {
  constructor() {
    super("types.Ty", [
      { no: 2, name: "primitive", kind: "message", oneof: "ty_type", T: () => Primitive },
      { no: 3, name: "enum", kind: "message", oneof: "ty_type", T: () => Enum },
      { no: 4, name: "struct", kind: "message", oneof: "ty_type", T: () => Struct },
      { no: 5, name: "tuple", kind: "message", oneof: "ty_type", T: () => Array$ },
      { no: 6, name: "array", kind: "message", oneof: "ty_type", T: () => Array$ },
      {
        no: 7,
        name: "bytearray",
        kind: "scalar",
        oneof: "ty_type",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "fixed_size_array", kind: "message", localName: "fixed_size_array", oneof: "ty_type", T: () => FixedSizeArray }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.ty_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Primitive primitive */
        2:
          message.ty_type = {
            oneofKind: "primitive",
            primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.primitive)
          };
          break;
        case /* types.Enum enum */
        3:
          message.ty_type = {
            oneofKind: "enum",
            enum: Enum.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.enum)
          };
          break;
        case /* types.Struct struct */
        4:
          message.ty_type = {
            oneofKind: "struct",
            struct: Struct.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.struct)
          };
          break;
        case /* types.Array tuple */
        5:
          message.ty_type = {
            oneofKind: "tuple",
            tuple: Array$.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.tuple)
          };
          break;
        case /* types.Array array */
        6:
          message.ty_type = {
            oneofKind: "array",
            array: Array$.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.array)
          };
          break;
        case /* string bytearray */
        7:
          message.ty_type = {
            oneofKind: "bytearray",
            bytearray: reader.string()
          };
          break;
        case /* types.FixedSizeArray fixed_size_array */
        8:
          message.ty_type = {
            oneofKind: "fixed_size_array",
            fixed_size_array: FixedSizeArray.internalBinaryRead(reader, reader.uint32(), options, message.ty_type.fixed_size_array)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ty_type.oneofKind === "primitive")
      Primitive.internalBinaryWrite(message.ty_type.primitive, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "enum")
      Enum.internalBinaryWrite(message.ty_type.enum, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "struct")
      Struct.internalBinaryWrite(message.ty_type.struct, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "tuple")
      Array$.internalBinaryWrite(message.ty_type.tuple, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "array")
      Array$.internalBinaryWrite(message.ty_type.array, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.ty_type.oneofKind === "bytearray")
      writer.tag(7, WireType.LengthDelimited).string(message.ty_type.bytearray);
    if (message.ty_type.oneofKind === "fixed_size_array")
      FixedSizeArray.internalBinaryWrite(message.ty_type.fixed_size_array, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Ty = new Ty$Type();
var Member$Type = class extends MessageType {
  constructor() {
    super("types.Member", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "ty", kind: "message", T: () => Ty },
      {
        no: 3,
        name: "key",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.name = "";
    message.key = false;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* types.Ty ty */
        2:
          message.ty = Ty.internalBinaryRead(reader, reader.uint32(), options, message.ty);
          break;
        case /* bool key */
        3:
          message.key = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.ty)
      Ty.internalBinaryWrite(message.ty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.key !== false)
      writer.tag(3, WireType.Varint).bool(message.key);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Member = new Member$Type();

// src/generated/types.ts
var PatternMatching = /* @__PURE__ */ ((PatternMatching2) => {
  PatternMatching2[PatternMatching2["FixedLen"] = 0] = "FixedLen";
  PatternMatching2[PatternMatching2["VariableLen"] = 1] = "VariableLen";
  return PatternMatching2;
})(PatternMatching || {});
var LogicalOperator = /* @__PURE__ */ ((LogicalOperator2) => {
  LogicalOperator2[LogicalOperator2["AND"] = 0] = "AND";
  LogicalOperator2[LogicalOperator2["OR"] = 1] = "OR";
  return LogicalOperator2;
})(LogicalOperator || {});
var ComparisonOperator = /* @__PURE__ */ ((ComparisonOperator2) => {
  ComparisonOperator2[ComparisonOperator2["EQ"] = 0] = "EQ";
  ComparisonOperator2[ComparisonOperator2["NEQ"] = 1] = "NEQ";
  ComparisonOperator2[ComparisonOperator2["GT"] = 2] = "GT";
  ComparisonOperator2[ComparisonOperator2["GTE"] = 3] = "GTE";
  ComparisonOperator2[ComparisonOperator2["LT"] = 4] = "LT";
  ComparisonOperator2[ComparisonOperator2["LTE"] = 5] = "LTE";
  ComparisonOperator2[ComparisonOperator2["IN"] = 6] = "IN";
  ComparisonOperator2[ComparisonOperator2["NOT_IN"] = 7] = "NOT_IN";
  ComparisonOperator2[ComparisonOperator2["CONTAINS"] = 8] = "CONTAINS";
  ComparisonOperator2[ComparisonOperator2["CONTAINS_ALL"] = 9] = "CONTAINS_ALL";
  ComparisonOperator2[ComparisonOperator2["CONTAINS_ANY"] = 10] = "CONTAINS_ANY";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_EQ"] = 11] = "ARRAY_LENGTH_EQ";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_GT"] = 12] = "ARRAY_LENGTH_GT";
  ComparisonOperator2[ComparisonOperator2["ARRAY_LENGTH_LT"] = 13] = "ARRAY_LENGTH_LT";
  return ComparisonOperator2;
})(ComparisonOperator || {});
var OrderDirection = /* @__PURE__ */ ((OrderDirection2) => {
  OrderDirection2[OrderDirection2["ASC"] = 0] = "ASC";
  OrderDirection2[OrderDirection2["DESC"] = 1] = "DESC";
  return OrderDirection2;
})(OrderDirection || {});
var PaginationDirection = /* @__PURE__ */ ((PaginationDirection2) => {
  PaginationDirection2[PaginationDirection2["FORWARD"] = 0] = "FORWARD";
  PaginationDirection2[PaginationDirection2["BACKWARD"] = 1] = "BACKWARD";
  return PaginationDirection2;
})(PaginationDirection || {});
var CallType = /* @__PURE__ */ ((CallType2) => {
  CallType2[CallType2["EXECUTE"] = 0] = "EXECUTE";
  CallType2[CallType2["EXECUTE_FROM_OUTSIDE"] = 1] = "EXECUTE_FROM_OUTSIDE";
  return CallType2;
})(CallType || {});
var ContractType = /* @__PURE__ */ ((ContractType4) => {
  ContractType4[ContractType4["WORLD"] = 0] = "WORLD";
  ContractType4[ContractType4["ERC20"] = 1] = "ERC20";
  ContractType4[ContractType4["ERC721"] = 2] = "ERC721";
  ContractType4[ContractType4["ERC1155"] = 3] = "ERC1155";
  ContractType4[ContractType4["UDC"] = 4] = "UDC";
  ContractType4[ContractType4["OTHER"] = 5] = "OTHER";
  return ContractType4;
})(ContractType || {});
var World$Type = class extends MessageType2 {
  constructor() {
    super("types.World", [
      {
        no: 1,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "models", kind: "message", repeat: 2, T: () => Model }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_address = "";
    message.models = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string world_address */
        1:
          message.world_address = reader.string();
          break;
        case /* repeated types.Model models */
        2:
          message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.world_address !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.world_address);
    for (let i = 0; i < message.models.length; i++)
      Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var World = new World$Type();
var Model$Type = class extends MessageType2 {
  constructor() {
    super("types.Model", [
      {
        no: 1,
        name: "selector",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "packed_size",
        kind: "scalar",
        localName: "packed_size",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "unpacked_size",
        kind: "scalar",
        localName: "unpacked_size",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "class_hash",
        kind: "scalar",
        localName: "class_hash",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "layout",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "schema",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 9,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 10,
        name: "use_legacy_store",
        kind: "scalar",
        localName: "use_legacy_store",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.selector = new Uint8Array(0);
    message.namespace = "";
    message.name = "";
    message.packed_size = 0;
    message.unpacked_size = 0;
    message.class_hash = new Uint8Array(0);
    message.layout = new Uint8Array(0);
    message.schema = new Uint8Array(0);
    message.contract_address = new Uint8Array(0);
    message.use_legacy_store = false;
    message.world_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes selector */
        1:
          message.selector = reader.bytes();
          break;
        case /* string namespace */
        2:
          message.namespace = reader.string();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* uint32 packed_size */
        4:
          message.packed_size = reader.uint32();
          break;
        case /* uint32 unpacked_size */
        5:
          message.unpacked_size = reader.uint32();
          break;
        case /* bytes class_hash */
        6:
          message.class_hash = reader.bytes();
          break;
        case /* bytes layout */
        7:
          message.layout = reader.bytes();
          break;
        case /* bytes schema */
        8:
          message.schema = reader.bytes();
          break;
        case /* bytes contract_address */
        9:
          message.contract_address = reader.bytes();
          break;
        case /* bool use_legacy_store */
        10:
          message.use_legacy_store = reader.bool();
          break;
        case /* bytes world_address */
        11:
          message.world_address = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.selector.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.selector);
    if (message.namespace !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.namespace);
    if (message.name !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.name);
    if (message.packed_size !== 0)
      writer.tag(4, WireType2.Varint).uint32(message.packed_size);
    if (message.unpacked_size !== 0)
      writer.tag(5, WireType2.Varint).uint32(message.unpacked_size);
    if (message.class_hash.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.class_hash);
    if (message.layout.length)
      writer.tag(7, WireType2.LengthDelimited).bytes(message.layout);
    if (message.schema.length)
      writer.tag(8, WireType2.LengthDelimited).bytes(message.schema);
    if (message.contract_address.length)
      writer.tag(9, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.use_legacy_store !== false)
      writer.tag(10, WireType2.Varint).bool(message.use_legacy_store);
    if (message.world_address.length)
      writer.tag(11, WireType2.LengthDelimited).bytes(message.world_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Model = new Model$Type();
var Entity$Type = class extends MessageType2 {
  constructor() {
    super("types.Entity", [
      {
        no: 1,
        name: "hashed_keys",
        kind: "scalar",
        localName: "hashed_keys",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "models", kind: "message", repeat: 2, T: () => Struct },
      {
        no: 3,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "executed_at",
        kind: "scalar",
        localName: "executed_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hashed_keys = new Uint8Array(0);
    message.models = [];
    message.created_at = 0n;
    message.updated_at = 0n;
    message.executed_at = 0n;
    message.world_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hashed_keys */
        1:
          message.hashed_keys = reader.bytes();
          break;
        case /* repeated types.Struct models */
        2:
          message.models.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 created_at */
        3:
          message.created_at = reader.uint64().toBigInt();
          break;
        case /* uint64 updated_at */
        4:
          message.updated_at = reader.uint64().toBigInt();
          break;
        case /* uint64 executed_at */
        5:
          message.executed_at = reader.uint64().toBigInt();
          break;
        case /* bytes world_address */
        6:
          message.world_address = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hashed_keys.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.hashed_keys);
    for (let i = 0; i < message.models.length; i++)
      Struct.internalBinaryWrite(message.models[i], writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    if (message.created_at !== 0n)
      writer.tag(3, WireType2.Varint).uint64(message.created_at);
    if (message.updated_at !== 0n)
      writer.tag(4, WireType2.Varint).uint64(message.updated_at);
    if (message.executed_at !== 0n)
      writer.tag(5, WireType2.Varint).uint64(message.executed_at);
    if (message.world_address.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.world_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Entity = new Entity$Type();
var Event$Type = class extends MessageType2 {
  constructor() {
    super("types.Event", [
      {
        no: 1,
        name: "keys",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "data",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "transaction_hash",
        kind: "scalar",
        localName: "transaction_hash",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    message.data = [];
    message.transaction_hash = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes keys */
        1:
          message.keys.push(reader.bytes());
          break;
        case /* repeated bytes data */
        2:
          message.data.push(reader.bytes());
          break;
        case /* bytes transaction_hash */
        3:
          message.transaction_hash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.keys[i]);
    for (let i = 0; i < message.data.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.data[i]);
    if (message.transaction_hash.length)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.transaction_hash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Event = new Event$Type();
var Query$Type = class extends MessageType2 {
  constructor() {
    super("types.Query", [
      { no: 1, name: "clause", kind: "message", T: () => Clause },
      {
        no: 2,
        name: "no_hashed_keys",
        kind: "scalar",
        localName: "no_hashed_keys",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "models",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination },
      {
        no: 5,
        name: "historical",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.no_hashed_keys = false;
    message.models = [];
    message.historical = false;
    message.world_addresses = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        case /* bool no_hashed_keys */
        2:
          message.no_hashed_keys = reader.bool();
          break;
        case /* repeated string models */
        3:
          message.models.push(reader.string());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        case /* bool historical */
        5:
          message.historical = reader.bool();
          break;
        case /* repeated bytes world_addresses */
        6:
          message.world_addresses.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.no_hashed_keys !== false)
      writer.tag(2, WireType2.Varint).bool(message.no_hashed_keys);
    for (let i = 0; i < message.models.length; i++)
      writer.tag(3, WireType2.LengthDelimited).string(message.models[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    if (message.historical !== false)
      writer.tag(5, WireType2.Varint).bool(message.historical);
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.world_addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Query = new Query$Type();
var EventQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.EventQuery", [
      { no: 1, name: "keys", kind: "message", T: () => KeysClause },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.KeysClause keys */
        1:
          message.keys = KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.keys);
          break;
        case /* types.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.keys)
      KeysClause.internalBinaryWrite(message.keys, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var EventQuery = new EventQuery$Type();
var Clause$Type = class extends MessageType2 {
  constructor() {
    super("types.Clause", [
      { no: 1, name: "hashed_keys", kind: "message", localName: "hashed_keys", oneof: "clause_type", T: () => HashedKeysClause },
      { no: 2, name: "keys", kind: "message", oneof: "clause_type", T: () => KeysClause },
      { no: 3, name: "member", kind: "message", oneof: "clause_type", T: () => MemberClause },
      { no: 4, name: "composite", kind: "message", oneof: "clause_type", T: () => CompositeClause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.clause_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.HashedKeysClause hashed_keys */
        1:
          message.clause_type = {
            oneofKind: "hashed_keys",
            hashed_keys: HashedKeysClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.hashed_keys)
          };
          break;
        case /* types.KeysClause keys */
        2:
          message.clause_type = {
            oneofKind: "keys",
            keys: KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.keys)
          };
          break;
        case /* types.MemberClause member */
        3:
          message.clause_type = {
            oneofKind: "member",
            member: MemberClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.member)
          };
          break;
        case /* types.CompositeClause composite */
        4:
          message.clause_type = {
            oneofKind: "composite",
            composite: CompositeClause.internalBinaryRead(reader, reader.uint32(), options, message.clause_type.composite)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause_type.oneofKind === "hashed_keys")
      HashedKeysClause.internalBinaryWrite(message.clause_type.hashed_keys, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "keys")
      KeysClause.internalBinaryWrite(message.clause_type.keys, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "member")
      MemberClause.internalBinaryWrite(message.clause_type.member, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    if (message.clause_type.oneofKind === "composite")
      CompositeClause.internalBinaryWrite(message.clause_type.composite, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Clause = new Clause$Type();
var KeysClause$Type = class extends MessageType2 {
  constructor() {
    super("types.KeysClause", [
      {
        no: 2,
        name: "keys",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "pattern_matching", kind: "enum", localName: "pattern_matching", T: () => ["types.PatternMatching", PatternMatching] },
      {
        no: 4,
        name: "models",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    message.pattern_matching = 0;
    message.models = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes keys */
        2:
          message.keys.push(reader.bytes());
          break;
        case /* types.PatternMatching pattern_matching */
        3:
          message.pattern_matching = reader.int32();
          break;
        case /* repeated string models */
        4:
          message.models.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.keys[i]);
    if (message.pattern_matching !== 0)
      writer.tag(3, WireType2.Varint).int32(message.pattern_matching);
    for (let i = 0; i < message.models.length; i++)
      writer.tag(4, WireType2.LengthDelimited).string(message.models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var KeysClause = new KeysClause$Type();
var HashedKeysClause$Type = class extends MessageType2 {
  constructor() {
    super("types.HashedKeysClause", [
      {
        no: 1,
        name: "hashed_keys",
        kind: "scalar",
        localName: "hashed_keys",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.hashed_keys = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes hashed_keys */
        1:
          message.hashed_keys.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.hashed_keys.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.hashed_keys[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var HashedKeysClause = new HashedKeysClause$Type();
var MemberValue$Type = class extends MessageType2 {
  constructor() {
    super("types.MemberValue", [
      { no: 1, name: "primitive", kind: "message", oneof: "value_type", T: () => Primitive },
      {
        no: 2,
        name: "string",
        kind: "scalar",
        oneof: "value_type",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "list", kind: "message", oneof: "value_type", T: () => MemberValueList }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Primitive primitive */
        1:
          message.value_type = {
            oneofKind: "primitive",
            primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, message.value_type.primitive)
          };
          break;
        case /* string string */
        2:
          message.value_type = {
            oneofKind: "string",
            string: reader.string()
          };
          break;
        case /* types.MemberValueList list */
        3:
          message.value_type = {
            oneofKind: "list",
            list: MemberValueList.internalBinaryRead(reader, reader.uint32(), options, message.value_type.list)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value_type.oneofKind === "primitive")
      Primitive.internalBinaryWrite(message.value_type.primitive, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.value_type.oneofKind === "string")
      writer.tag(2, WireType2.LengthDelimited).string(message.value_type.string);
    if (message.value_type.oneofKind === "list")
      MemberValueList.internalBinaryWrite(message.value_type.list, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberValue = new MemberValue$Type();
var MemberValueList$Type = class extends MessageType2 {
  constructor() {
    super("types.MemberValueList", [
      { no: 1, name: "values", kind: "message", repeat: 2, T: () => MemberValue }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.values = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.MemberValue values */
        1:
          message.values.push(MemberValue.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.values.length; i++)
      MemberValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberValueList = new MemberValueList$Type();
var MemberClause$Type = class extends MessageType2 {
  constructor() {
    super("types.MemberClause", [
      {
        no: 2,
        name: "model",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "member",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "operator", kind: "enum", T: () => ["types.ComparisonOperator", ComparisonOperator] },
      { no: 5, name: "value", kind: "message", T: () => MemberValue }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.model = "";
    message.member = "";
    message.operator = 0;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string model */
        2:
          message.model = reader.string();
          break;
        case /* string member */
        3:
          message.member = reader.string();
          break;
        case /* types.ComparisonOperator operator */
        4:
          message.operator = reader.int32();
          break;
        case /* types.MemberValue value */
        5:
          message.value = MemberValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.model !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.model);
    if (message.member !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.member);
    if (message.operator !== 0)
      writer.tag(4, WireType2.Varint).int32(message.operator);
    if (message.value)
      MemberValue.internalBinaryWrite(message.value, writer.tag(5, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var MemberClause = new MemberClause$Type();
var CompositeClause$Type = class extends MessageType2 {
  constructor() {
    super("types.CompositeClause", [
      { no: 3, name: "operator", kind: "enum", T: () => ["types.LogicalOperator", LogicalOperator] },
      { no: 4, name: "clauses", kind: "message", repeat: 2, T: () => Clause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operator = 0;
    message.clauses = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.LogicalOperator operator */
        3:
          message.operator = reader.int32();
          break;
        case /* repeated types.Clause clauses */
        4:
          message.clauses.push(Clause.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.operator !== 0)
      writer.tag(3, WireType2.Varint).int32(message.operator);
    for (let i = 0; i < message.clauses.length; i++)
      Clause.internalBinaryWrite(message.clauses[i], writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var CompositeClause = new CompositeClause$Type();
var Token$Type = class extends MessageType2 {
  constructor() {
    super("types.Token", [
      {
        no: 1,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "total_supply",
        kind: "scalar",
        localName: "total_supply",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.name = "";
    message.symbol = "";
    message.decimals = 0;
    message.metadata = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes token_id */
        1:
          message.token_id = reader.bytes();
          break;
        case /* bytes contract_address */
        2:
          message.contract_address = reader.bytes();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* uint32 decimals */
        5:
          message.decimals = reader.uint32();
          break;
        case /* bytes metadata */
        6:
          message.metadata = reader.bytes();
          break;
        case /* optional bytes total_supply */
        7:
          message.total_supply = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.token_id !== void 0)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.token_id);
    if (message.contract_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.name !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(4, WireType2.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0)
      writer.tag(5, WireType2.Varint).uint32(message.decimals);
    if (message.metadata.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.metadata);
    if (message.total_supply !== void 0)
      writer.tag(7, WireType2.LengthDelimited).bytes(message.total_supply);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Token = new Token$Type();
var TokenBalance$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenBalance", [
      {
        no: 1,
        name: "balance",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "account_address",
        kind: "scalar",
        localName: "account_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balance = new Uint8Array(0);
    message.account_address = new Uint8Array(0);
    message.contract_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes balance */
        1:
          message.balance = reader.bytes();
          break;
        case /* bytes account_address */
        2:
          message.account_address = reader.bytes();
          break;
        case /* bytes contract_address */
        3:
          message.contract_address = reader.bytes();
          break;
        case /* optional bytes token_id */
        4:
          message.token_id = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.balance);
    if (message.account_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.account_address);
    if (message.contract_address.length)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.token_id !== void 0)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.token_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenBalance = new TokenBalance$Type();
var OrderBy$Type = class extends MessageType2 {
  constructor() {
    super("types.OrderBy", [
      {
        no: 1,
        name: "field",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "direction", kind: "enum", T: () => ["types.OrderDirection", OrderDirection] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.field = "";
    message.direction = 0;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string field */
        1:
          message.field = reader.string();
          break;
        case /* types.OrderDirection direction */
        2:
          message.direction = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.field !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.field);
    if (message.direction !== 0)
      writer.tag(2, WireType2.Varint).int32(message.direction);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var OrderBy = new OrderBy$Type();
var Controller$Type = class extends MessageType2 {
  constructor() {
    super("types.Controller", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "deployed_at_timestamp",
        kind: "scalar",
        localName: "deployed_at_timestamp",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = new Uint8Array(0);
    message.username = "";
    message.deployed_at_timestamp = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes address */
        1:
          message.address = reader.bytes();
          break;
        case /* string username */
        2:
          message.username = reader.string();
          break;
        case /* uint64 deployed_at_timestamp */
        3:
          message.deployed_at_timestamp = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.address);
    if (message.username !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.username);
    if (message.deployed_at_timestamp !== 0n)
      writer.tag(3, WireType2.Varint).uint64(message.deployed_at_timestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Controller = new Controller$Type();
var Pagination$Type = class extends MessageType2 {
  constructor() {
    super("types.Pagination", [
      {
        no: 1,
        name: "cursor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "direction", kind: "enum", T: () => ["types.PaginationDirection", PaginationDirection] },
      { no: 4, name: "order_by", kind: "message", localName: "order_by", repeat: 2, T: () => OrderBy }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cursor = "";
    message.limit = 0;
    message.direction = 0;
    message.order_by = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string cursor */
        1:
          message.cursor = reader.string();
          break;
        case /* uint32 limit */
        2:
          message.limit = reader.uint32();
          break;
        case /* types.PaginationDirection direction */
        3:
          message.direction = reader.int32();
          break;
        case /* repeated types.OrderBy order_by */
        4:
          message.order_by.push(OrderBy.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.cursor !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.cursor);
    if (message.limit !== 0)
      writer.tag(2, WireType2.Varint).uint32(message.limit);
    if (message.direction !== 0)
      writer.tag(3, WireType2.Varint).int32(message.direction);
    for (let i = 0; i < message.order_by.length; i++)
      OrderBy.internalBinaryWrite(message.order_by[i], writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Pagination = new Pagination$Type();
var ControllerQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.ControllerQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "usernames",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.usernames = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated string usernames */
        2:
          message.usernames.push(reader.string());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.usernames.length; i++)
      writer.tag(2, WireType2.LengthDelimited).string(message.usernames[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ControllerQuery = new ControllerQuery$Type();
var TokenAttributeFilter$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenAttributeFilter", [
      {
        no: 1,
        name: "trait_name",
        kind: "scalar",
        localName: "trait_name",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "trait_value",
        kind: "scalar",
        localName: "trait_value",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.trait_name = "";
    message.trait_value = "";
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string trait_name */
        1:
          message.trait_name = reader.string();
          break;
        case /* string trait_value */
        2:
          message.trait_value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.trait_name !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.trait_name);
    if (message.trait_value !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.trait_value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenAttributeFilter = new TokenAttributeFilter$Type();
var TokenQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "attribute_filters", kind: "message", localName: "attribute_filters", repeat: 2, T: () => TokenAttributeFilter },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.token_ids = [];
    message.attribute_filters = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        2:
          message.token_ids.push(reader.bytes());
          break;
        case /* repeated types.TokenAttributeFilter attribute_filters */
        3:
          message.attribute_filters.push(TokenAttributeFilter.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.token_ids[i]);
    for (let i = 0; i < message.attribute_filters.length; i++)
      TokenAttributeFilter.internalBinaryWrite(message.attribute_filters[i], writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenQuery = new TokenQuery$Type();
var TokenBalanceQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenBalanceQuery", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.token_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenBalanceQuery = new TokenBalanceQuery$Type();
var TokenContractQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenContractQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1, T: () => ["types.ContractType", ContractType] },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.contract_types = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated types.ContractType contract_types */
        2:
          if (wireType === WireType2.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.contract_types.push(reader.int32());
          else
            message.contract_types.push(reader.int32());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    if (message.contract_types.length) {
      writer.tag(2, WireType2.LengthDelimited).fork();
      for (let i = 0; i < message.contract_types.length; i++)
        writer.int32(message.contract_types[i]);
      writer.join();
    }
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenContractQuery = new TokenContractQuery$Type();
var TokenTransfer$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenTransfer", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "from_address",
        kind: "scalar",
        localName: "from_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "to_address",
        kind: "scalar",
        localName: "to_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "amount",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "token_id",
        kind: "scalar",
        localName: "token_id",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "executed_at",
        kind: "scalar",
        localName: "executed_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "event_id",
        kind: "scalar",
        localName: "event_id",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.contract_address = new Uint8Array(0);
    message.from_address = new Uint8Array(0);
    message.to_address = new Uint8Array(0);
    message.amount = new Uint8Array(0);
    message.executed_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* bytes contract_address */
        2:
          message.contract_address = reader.bytes();
          break;
        case /* bytes from_address */
        3:
          message.from_address = reader.bytes();
          break;
        case /* bytes to_address */
        4:
          message.to_address = reader.bytes();
          break;
        case /* bytes amount */
        5:
          message.amount = reader.bytes();
          break;
        case /* optional bytes token_id */
        6:
          message.token_id = reader.bytes();
          break;
        case /* uint64 executed_at */
        7:
          message.executed_at = reader.uint64().toBigInt();
          break;
        case /* optional string event_id */
        8:
          message.event_id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.id);
    if (message.contract_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.from_address.length)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.from_address);
    if (message.to_address.length)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.to_address);
    if (message.amount.length)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.amount);
    if (message.token_id !== void 0)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.token_id);
    if (message.executed_at !== 0n)
      writer.tag(7, WireType2.Varint).uint64(message.executed_at);
    if (message.event_id !== void 0)
      writer.tag(8, WireType2.LengthDelimited).string(message.event_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenTransfer = new TokenTransfer$Type();
var TokenTransferQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenTransferQuery", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.token_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenTransferQuery = new TokenTransferQuery$Type();
var TransactionCall$Type = class extends MessageType2 {
  constructor() {
    super("types.TransactionCall", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "entrypoint",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "calldata",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "call_type", kind: "enum", localName: "call_type", T: () => ["types.CallType", CallType] },
      {
        no: 5,
        name: "caller_address",
        kind: "scalar",
        localName: "caller_address",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.entrypoint = "";
    message.calldata = [];
    message.call_type = 0;
    message.caller_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* string entrypoint */
        2:
          message.entrypoint = reader.string();
          break;
        case /* repeated bytes calldata */
        3:
          message.calldata.push(reader.bytes());
          break;
        case /* types.CallType call_type */
        4:
          message.call_type = reader.int32();
          break;
        case /* bytes caller_address */
        5:
          message.caller_address = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.entrypoint !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.entrypoint);
    for (let i = 0; i < message.calldata.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.calldata[i]);
    if (message.call_type !== 0)
      writer.tag(4, WireType2.Varint).int32(message.call_type);
    if (message.caller_address.length)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.caller_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionCall = new TransactionCall$Type();
var Transaction$Type = class extends MessageType2 {
  constructor() {
    super("types.Transaction", [
      {
        no: 1,
        name: "transaction_hash",
        kind: "scalar",
        localName: "transaction_hash",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "sender_address",
        kind: "scalar",
        localName: "sender_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "calldata",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "max_fee",
        kind: "scalar",
        localName: "max_fee",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "signature",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "nonce",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "block_number",
        kind: "scalar",
        localName: "block_number",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "transaction_type",
        kind: "scalar",
        localName: "transaction_type",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "block_timestamp",
        kind: "scalar",
        localName: "block_timestamp",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 10, name: "calls", kind: "message", repeat: 2, T: () => TransactionCall },
      {
        no: 11,
        name: "unique_models",
        kind: "scalar",
        localName: "unique_models",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transaction_hash = new Uint8Array(0);
    message.sender_address = new Uint8Array(0);
    message.calldata = [];
    message.max_fee = new Uint8Array(0);
    message.signature = [];
    message.nonce = new Uint8Array(0);
    message.block_number = 0n;
    message.transaction_type = "";
    message.block_timestamp = 0n;
    message.calls = [];
    message.unique_models = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes transaction_hash */
        1:
          message.transaction_hash = reader.bytes();
          break;
        case /* bytes sender_address */
        2:
          message.sender_address = reader.bytes();
          break;
        case /* repeated bytes calldata */
        3:
          message.calldata.push(reader.bytes());
          break;
        case /* bytes max_fee */
        4:
          message.max_fee = reader.bytes();
          break;
        case /* repeated bytes signature */
        5:
          message.signature.push(reader.bytes());
          break;
        case /* bytes nonce */
        6:
          message.nonce = reader.bytes();
          break;
        case /* uint64 block_number */
        7:
          message.block_number = reader.uint64().toBigInt();
          break;
        case /* string transaction_type */
        8:
          message.transaction_type = reader.string();
          break;
        case /* uint64 block_timestamp */
        9:
          message.block_timestamp = reader.uint64().toBigInt();
          break;
        case /* repeated types.TransactionCall calls */
        10:
          message.calls.push(TransactionCall.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated bytes unique_models */
        11:
          message.unique_models.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction_hash.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.transaction_hash);
    if (message.sender_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.sender_address);
    for (let i = 0; i < message.calldata.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.calldata[i]);
    if (message.max_fee.length)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.max_fee);
    for (let i = 0; i < message.signature.length; i++)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.signature[i]);
    if (message.nonce.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.nonce);
    if (message.block_number !== 0n)
      writer.tag(7, WireType2.Varint).uint64(message.block_number);
    if (message.transaction_type !== "")
      writer.tag(8, WireType2.LengthDelimited).string(message.transaction_type);
    if (message.block_timestamp !== 0n)
      writer.tag(9, WireType2.Varint).uint64(message.block_timestamp);
    for (let i = 0; i < message.calls.length; i++)
      TransactionCall.internalBinaryWrite(message.calls[i], writer.tag(10, WireType2.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.unique_models.length; i++)
      writer.tag(11, WireType2.LengthDelimited).bytes(message.unique_models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Transaction = new Transaction$Type();
var TransactionFilter$Type = class extends MessageType2 {
  constructor() {
    super("types.TransactionFilter", [
      {
        no: 1,
        name: "transaction_hashes",
        kind: "scalar",
        localName: "transaction_hashes",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "caller_addresses",
        kind: "scalar",
        localName: "caller_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "entrypoints",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "model_selectors",
        kind: "scalar",
        localName: "model_selectors",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "from_block",
        kind: "scalar",
        localName: "from_block",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "to_block",
        kind: "scalar",
        localName: "to_block",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transaction_hashes = [];
    message.caller_addresses = [];
    message.contract_addresses = [];
    message.entrypoints = [];
    message.model_selectors = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes transaction_hashes */
        1:
          message.transaction_hashes.push(reader.bytes());
          break;
        case /* repeated bytes caller_addresses */
        2:
          message.caller_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        3:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated string entrypoints */
        4:
          message.entrypoints.push(reader.string());
          break;
        case /* repeated bytes model_selectors */
        5:
          message.model_selectors.push(reader.bytes());
          break;
        case /* optional uint64 from_block */
        6:
          message.from_block = reader.uint64().toBigInt();
          break;
        case /* optional uint64 to_block */
        7:
          message.to_block = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transaction_hashes.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.transaction_hashes[i]);
    for (let i = 0; i < message.caller_addresses.length; i++)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.caller_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.entrypoints.length; i++)
      writer.tag(4, WireType2.LengthDelimited).string(message.entrypoints[i]);
    for (let i = 0; i < message.model_selectors.length; i++)
      writer.tag(5, WireType2.LengthDelimited).bytes(message.model_selectors[i]);
    if (message.from_block !== void 0)
      writer.tag(6, WireType2.Varint).uint64(message.from_block);
    if (message.to_block !== void 0)
      writer.tag(7, WireType2.Varint).uint64(message.to_block);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionFilter = new TransactionFilter$Type();
var TransactionQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.TransactionQuery", [
      { no: 1, name: "filter", kind: "message", T: () => TransactionFilter },
      { no: 2, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionFilter filter */
        1:
          message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
          break;
        case /* types.Pagination pagination */
        2:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.filter)
      TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TransactionQuery = new TransactionQuery$Type();
var Activity$Type = class extends MessageType2 {
  constructor() {
    super("types.Activity", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "namespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "caller_address",
        kind: "scalar",
        localName: "caller_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "session_start",
        kind: "scalar",
        localName: "session_start",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "session_end",
        kind: "scalar",
        localName: "session_end",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "action_count",
        kind: "scalar",
        localName: "action_count",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 8, name: "actions", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      } },
      {
        no: 9,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.world_address = new Uint8Array(0);
    message.namespace = "";
    message.caller_address = new Uint8Array(0);
    message.session_start = 0n;
    message.session_end = 0n;
    message.action_count = 0;
    message.actions = {};
    message.updated_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* bytes world_address */
        2:
          message.world_address = reader.bytes();
          break;
        case /* string namespace */
        3:
          message.namespace = reader.string();
          break;
        case /* bytes caller_address */
        4:
          message.caller_address = reader.bytes();
          break;
        case /* uint64 session_start */
        5:
          message.session_start = reader.uint64().toBigInt();
          break;
        case /* uint64 session_end */
        6:
          message.session_end = reader.uint64().toBigInt();
          break;
        case /* uint32 action_count */
        7:
          message.action_count = reader.uint32();
          break;
        case /* map<string, uint32> actions */
        8:
          this.binaryReadMap8(message.actions, reader, options);
          break;
        case /* uint64 updated_at */
        9:
          message.updated_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap8(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.uint32();
          break;
        default:
          throw new globalThis.Error("unknown map entry field for types.Activity.actions");
      }
    }
    map[key ?? ""] = val ?? 0;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.id);
    if (message.world_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.world_address);
    if (message.namespace !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.namespace);
    if (message.caller_address.length)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.caller_address);
    if (message.session_start !== 0n)
      writer.tag(5, WireType2.Varint).uint64(message.session_start);
    if (message.session_end !== 0n)
      writer.tag(6, WireType2.Varint).uint64(message.session_end);
    if (message.action_count !== 0)
      writer.tag(7, WireType2.Varint).uint32(message.action_count);
    for (let k of globalThis.Object.keys(message.actions))
      writer.tag(8, WireType2.LengthDelimited).fork().tag(1, WireType2.LengthDelimited).string(k).tag(2, WireType2.Varint).uint32(message.actions[k]).join();
    if (message.updated_at !== 0n)
      writer.tag(9, WireType2.Varint).uint64(message.updated_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Activity = new Activity$Type();
var ActivityQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.ActivityQuery", [
      {
        no: 1,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "caller_addresses",
        kind: "scalar",
        localName: "caller_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "from_time",
        kind: "scalar",
        localName: "from_time",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "to_time",
        kind: "scalar",
        localName: "to_time",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 6, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    message.namespaces = [];
    message.caller_addresses = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes world_addresses */
        1:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        2:
          message.namespaces.push(reader.string());
          break;
        case /* repeated bytes caller_addresses */
        3:
          message.caller_addresses.push(reader.bytes());
          break;
        case /* optional uint64 from_time */
        4:
          message.from_time = reader.uint64().toBigInt();
          break;
        case /* optional uint64 to_time */
        5:
          message.to_time = reader.uint64().toBigInt();
          break;
        case /* types.Pagination pagination */
        6:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(2, WireType2.LengthDelimited).string(message.namespaces[i]);
    for (let i = 0; i < message.caller_addresses.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.caller_addresses[i]);
    if (message.from_time !== void 0)
      writer.tag(4, WireType2.Varint).uint64(message.from_time);
    if (message.to_time !== void 0)
      writer.tag(5, WireType2.Varint).uint64(message.to_time);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(6, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ActivityQuery = new ActivityQuery$Type();
var SqlValue$Type = class extends MessageType2 {
  constructor() {
    super("types.SqlValue", [
      {
        no: 1,
        name: "text",
        kind: "scalar",
        oneof: "value_type",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "integer",
        kind: "scalar",
        oneof: "value_type",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "real",
        kind: "scalar",
        oneof: "value_type",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "blob",
        kind: "scalar",
        oneof: "value_type",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "null",
        kind: "scalar",
        oneof: "value_type",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value_type = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string text */
        1:
          message.value_type = {
            oneofKind: "text",
            text: reader.string()
          };
          break;
        case /* int64 integer */
        2:
          message.value_type = {
            oneofKind: "integer",
            integer: reader.int64().toBigInt()
          };
          break;
        case /* double real */
        3:
          message.value_type = {
            oneofKind: "real",
            real: reader.double()
          };
          break;
        case /* bytes blob */
        4:
          message.value_type = {
            oneofKind: "blob",
            blob: reader.bytes()
          };
          break;
        case /* bool null */
        5:
          message.value_type = {
            oneofKind: "null",
            null: reader.bool()
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value_type.oneofKind === "text")
      writer.tag(1, WireType2.LengthDelimited).string(message.value_type.text);
    if (message.value_type.oneofKind === "integer")
      writer.tag(2, WireType2.Varint).int64(message.value_type.integer);
    if (message.value_type.oneofKind === "real")
      writer.tag(3, WireType2.Bit64).double(message.value_type.real);
    if (message.value_type.oneofKind === "blob")
      writer.tag(4, WireType2.LengthDelimited).bytes(message.value_type.blob);
    if (message.value_type.oneofKind === "null")
      writer.tag(5, WireType2.Varint).bool(message.value_type.null);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SqlValue = new SqlValue$Type();
var SqlRow$Type = class extends MessageType2 {
  constructor() {
    super("types.SqlRow", [
      { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: () => SqlValue } }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fields = {};
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, types.SqlValue> fields */
        1:
          this.binaryReadMap1(message.fields, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap1(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SqlValue.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error("unknown map entry field for types.SqlRow.fields");
      }
    }
    map[key ?? ""] = val ?? SqlValue.create();
  }
  internalBinaryWrite(message, writer, options) {
    for (let k of globalThis.Object.keys(message.fields)) {
      writer.tag(1, WireType2.LengthDelimited).fork().tag(1, WireType2.LengthDelimited).string(k);
      writer.tag(2, WireType2.LengthDelimited).fork();
      SqlValue.internalBinaryWrite(message.fields[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SqlRow = new SqlRow$Type();
var SqlQueryRequest$Type = class extends MessageType2 {
  constructor() {
    super("types.SqlQueryRequest", [
      {
        no: 1,
        name: "query",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.query = "";
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string query */
        1:
          message.query = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.query);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SqlQueryRequest = new SqlQueryRequest$Type();
var SqlQueryResponse$Type = class extends MessageType2 {
  constructor() {
    super("types.SqlQueryResponse", [
      { no: 1, name: "rows", kind: "message", repeat: 2, T: () => SqlRow }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rows = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.SqlRow rows */
        1:
          message.rows.push(SqlRow.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.rows.length; i++)
      SqlRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SqlQueryResponse = new SqlQueryResponse$Type();
var Contract$Type = class extends MessageType2 {
  constructor() {
    super("types.Contract", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
      {
        no: 3,
        name: "head",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 4,
        name: "tps",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "last_block_timestamp",
        kind: "scalar",
        localName: "last_block_timestamp",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "last_pending_block_tx",
        kind: "scalar",
        localName: "last_pending_block_tx",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.contract_type = 0;
    message.updated_at = 0n;
    message.created_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* types.ContractType contract_type */
        2:
          message.contract_type = reader.int32();
          break;
        case /* optional uint64 head */
        3:
          message.head = reader.uint64().toBigInt();
          break;
        case /* optional uint64 tps */
        4:
          message.tps = reader.uint64().toBigInt();
          break;
        case /* optional uint64 last_block_timestamp */
        5:
          message.last_block_timestamp = reader.uint64().toBigInt();
          break;
        case /* optional bytes last_pending_block_tx */
        6:
          message.last_pending_block_tx = reader.bytes();
          break;
        case /* uint64 updated_at */
        7:
          message.updated_at = reader.uint64().toBigInt();
          break;
        case /* uint64 created_at */
        8:
          message.created_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.contract_type !== 0)
      writer.tag(2, WireType2.Varint).int32(message.contract_type);
    if (message.head !== void 0)
      writer.tag(3, WireType2.Varint).uint64(message.head);
    if (message.tps !== void 0)
      writer.tag(4, WireType2.Varint).uint64(message.tps);
    if (message.last_block_timestamp !== void 0)
      writer.tag(5, WireType2.Varint).uint64(message.last_block_timestamp);
    if (message.last_pending_block_tx !== void 0)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.last_pending_block_tx);
    if (message.updated_at !== 0n)
      writer.tag(7, WireType2.Varint).uint64(message.updated_at);
    if (message.created_at !== 0n)
      writer.tag(8, WireType2.Varint).uint64(message.created_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Contract = new Contract$Type();
var ContractQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.ContractQuery", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1, T: () => ["types.ContractType", ContractType] }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.contract_types = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated types.ContractType contract_types */
        2:
          if (wireType === WireType2.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.contract_types.push(reader.int32());
          else
            message.contract_types.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_addresses[i]);
    if (message.contract_types.length) {
      writer.tag(2, WireType2.LengthDelimited).fork();
      for (let i = 0; i < message.contract_types.length; i++)
        writer.int32(message.contract_types[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var ContractQuery = new ContractQuery$Type();
var TokenContract$Type = class extends MessageType2 {
  constructor() {
    super("types.TokenContract", [
      {
        no: 1,
        name: "contract_address",
        kind: "scalar",
        localName: "contract_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "decimals",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "metadata",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "total_supply",
        kind: "scalar",
        localName: "total_supply",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "traits",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "token_metadata",
        kind: "scalar",
        localName: "token_metadata",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_address = new Uint8Array(0);
    message.contract_type = 0;
    message.name = "";
    message.symbol = "";
    message.decimals = 0;
    message.metadata = new Uint8Array(0);
    message.traits = "";
    message.token_metadata = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes contract_address */
        1:
          message.contract_address = reader.bytes();
          break;
        case /* types.ContractType contract_type */
        2:
          message.contract_type = reader.int32();
          break;
        case /* string name */
        3:
          message.name = reader.string();
          break;
        case /* string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* uint32 decimals */
        5:
          message.decimals = reader.uint32();
          break;
        case /* bytes metadata */
        6:
          message.metadata = reader.bytes();
          break;
        case /* optional bytes total_supply */
        7:
          message.total_supply = reader.bytes();
          break;
        case /* string traits */
        8:
          message.traits = reader.string();
          break;
        case /* bytes token_metadata */
        9:
          message.token_metadata = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract_address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.contract_address);
    if (message.contract_type !== 0)
      writer.tag(2, WireType2.Varint).int32(message.contract_type);
    if (message.name !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.name);
    if (message.symbol !== "")
      writer.tag(4, WireType2.LengthDelimited).string(message.symbol);
    if (message.decimals !== 0)
      writer.tag(5, WireType2.Varint).uint32(message.decimals);
    if (message.metadata.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.metadata);
    if (message.total_supply !== void 0)
      writer.tag(7, WireType2.LengthDelimited).bytes(message.total_supply);
    if (message.traits !== "")
      writer.tag(8, WireType2.LengthDelimited).string(message.traits);
    if (message.token_metadata.length)
      writer.tag(9, WireType2.LengthDelimited).bytes(message.token_metadata);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TokenContract = new TokenContract$Type();
var AggregationQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.AggregationQuery", [
      {
        no: 1,
        name: "aggregator_ids",
        kind: "scalar",
        localName: "aggregator_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "entity_ids",
        kind: "scalar",
        localName: "entity_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.aggregator_ids = [];
    message.entity_ids = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string aggregator_ids */
        1:
          message.aggregator_ids.push(reader.string());
          break;
        case /* repeated string entity_ids */
        2:
          message.entity_ids.push(reader.string());
          break;
        case /* types.Pagination pagination */
        3:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.aggregator_ids.length; i++)
      writer.tag(1, WireType2.LengthDelimited).string(message.aggregator_ids[i]);
    for (let i = 0; i < message.entity_ids.length; i++)
      writer.tag(2, WireType2.LengthDelimited).string(message.entity_ids[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var AggregationQuery = new AggregationQuery$Type();
var AggregationEntry$Type = class extends MessageType2 {
  constructor() {
    super("types.AggregationEntry", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "aggregator_id",
        kind: "scalar",
        localName: "aggregator_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "entity_id",
        kind: "scalar",
        localName: "entity_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "value",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "display_value",
        kind: "scalar",
        localName: "display_value",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "position",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "model_id",
        kind: "scalar",
        localName: "model_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.aggregator_id = "";
    message.entity_id = "";
    message.value = new Uint8Array(0);
    message.display_value = "";
    message.position = 0n;
    message.model_id = "";
    message.created_at = "";
    message.updated_at = "";
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string aggregator_id */
        2:
          message.aggregator_id = reader.string();
          break;
        case /* string entity_id */
        3:
          message.entity_id = reader.string();
          break;
        case /* bytes value */
        4:
          message.value = reader.bytes();
          break;
        case /* string display_value */
        5:
          message.display_value = reader.string();
          break;
        case /* uint64 position */
        6:
          message.position = reader.uint64().toBigInt();
          break;
        case /* string model_id */
        7:
          message.model_id = reader.string();
          break;
        case /* string created_at */
        8:
          message.created_at = reader.string();
          break;
        case /* string updated_at */
        9:
          message.updated_at = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.id);
    if (message.aggregator_id !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.aggregator_id);
    if (message.entity_id !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.entity_id);
    if (message.value.length)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.value);
    if (message.display_value !== "")
      writer.tag(5, WireType2.LengthDelimited).string(message.display_value);
    if (message.position !== 0n)
      writer.tag(6, WireType2.Varint).uint64(message.position);
    if (message.model_id !== "")
      writer.tag(7, WireType2.LengthDelimited).string(message.model_id);
    if (message.created_at !== "")
      writer.tag(8, WireType2.LengthDelimited).string(message.created_at);
    if (message.updated_at !== "")
      writer.tag(9, WireType2.LengthDelimited).string(message.updated_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var AggregationEntry = new AggregationEntry$Type();
var Achievement$Type = class extends MessageType2 {
  constructor() {
    super("types.Achievement", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "namespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "entity_id",
        kind: "scalar",
        localName: "entity_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "hidden",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "index",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 7,
        name: "points",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "start",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "end",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "group",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "icon",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 14, name: "tasks", kind: "message", repeat: 2, T: () => AchievementTask },
      {
        no: 15,
        name: "data",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "total_completions",
        kind: "scalar",
        localName: "total_completions",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 17,
        name: "completion_rate",
        kind: "scalar",
        localName: "completion_rate",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 18,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 19,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.world_address = new Uint8Array(0);
    message.namespace = "";
    message.entity_id = "";
    message.hidden = false;
    message.index = 0;
    message.points = 0;
    message.start = "";
    message.end = "";
    message.group = "";
    message.icon = "";
    message.title = "";
    message.description = "";
    message.tasks = [];
    message.total_completions = 0;
    message.completion_rate = 0;
    message.created_at = 0n;
    message.updated_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* bytes world_address */
        2:
          message.world_address = reader.bytes();
          break;
        case /* string namespace */
        3:
          message.namespace = reader.string();
          break;
        case /* string entity_id */
        4:
          message.entity_id = reader.string();
          break;
        case /* bool hidden */
        5:
          message.hidden = reader.bool();
          break;
        case /* uint32 index */
        6:
          message.index = reader.uint32();
          break;
        case /* uint32 points */
        7:
          message.points = reader.uint32();
          break;
        case /* string start */
        8:
          message.start = reader.string();
          break;
        case /* string end */
        9:
          message.end = reader.string();
          break;
        case /* string group */
        10:
          message.group = reader.string();
          break;
        case /* string icon */
        11:
          message.icon = reader.string();
          break;
        case /* string title */
        12:
          message.title = reader.string();
          break;
        case /* string description */
        13:
          message.description = reader.string();
          break;
        case /* repeated types.AchievementTask tasks */
        14:
          message.tasks.push(AchievementTask.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional string data */
        15:
          message.data = reader.string();
          break;
        case /* uint32 total_completions */
        16:
          message.total_completions = reader.uint32();
          break;
        case /* double completion_rate */
        17:
          message.completion_rate = reader.double();
          break;
        case /* uint64 created_at */
        18:
          message.created_at = reader.uint64().toBigInt();
          break;
        case /* uint64 updated_at */
        19:
          message.updated_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.id);
    if (message.world_address.length)
      writer.tag(2, WireType2.LengthDelimited).bytes(message.world_address);
    if (message.namespace !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.namespace);
    if (message.entity_id !== "")
      writer.tag(4, WireType2.LengthDelimited).string(message.entity_id);
    if (message.hidden !== false)
      writer.tag(5, WireType2.Varint).bool(message.hidden);
    if (message.index !== 0)
      writer.tag(6, WireType2.Varint).uint32(message.index);
    if (message.points !== 0)
      writer.tag(7, WireType2.Varint).uint32(message.points);
    if (message.start !== "")
      writer.tag(8, WireType2.LengthDelimited).string(message.start);
    if (message.end !== "")
      writer.tag(9, WireType2.LengthDelimited).string(message.end);
    if (message.group !== "")
      writer.tag(10, WireType2.LengthDelimited).string(message.group);
    if (message.icon !== "")
      writer.tag(11, WireType2.LengthDelimited).string(message.icon);
    if (message.title !== "")
      writer.tag(12, WireType2.LengthDelimited).string(message.title);
    if (message.description !== "")
      writer.tag(13, WireType2.LengthDelimited).string(message.description);
    for (let i = 0; i < message.tasks.length; i++)
      AchievementTask.internalBinaryWrite(message.tasks[i], writer.tag(14, WireType2.LengthDelimited).fork(), options).join();
    if (message.data !== void 0)
      writer.tag(15, WireType2.LengthDelimited).string(message.data);
    if (message.total_completions !== 0)
      writer.tag(16, WireType2.Varint).uint32(message.total_completions);
    if (message.completion_rate !== 0)
      writer.tag(17, WireType2.Bit64).double(message.completion_rate);
    if (message.created_at !== 0n)
      writer.tag(18, WireType2.Varint).uint64(message.created_at);
    if (message.updated_at !== 0n)
      writer.tag(19, WireType2.Varint).uint64(message.updated_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Achievement = new Achievement$Type();
var AchievementTask$Type = class extends MessageType2 {
  constructor() {
    super("types.AchievementTask", [
      {
        no: 1,
        name: "task_id",
        kind: "scalar",
        localName: "task_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "total",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "total_completions",
        kind: "scalar",
        localName: "total_completions",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "completion_rate",
        kind: "scalar",
        localName: "completion_rate",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 6,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.task_id = "";
    message.description = "";
    message.total = 0;
    message.total_completions = 0;
    message.completion_rate = 0;
    message.created_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string task_id */
        1:
          message.task_id = reader.string();
          break;
        case /* string description */
        2:
          message.description = reader.string();
          break;
        case /* uint32 total */
        3:
          message.total = reader.uint32();
          break;
        case /* uint32 total_completions */
        4:
          message.total_completions = reader.uint32();
          break;
        case /* double completion_rate */
        5:
          message.completion_rate = reader.double();
          break;
        case /* uint64 created_at */
        6:
          message.created_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.task_id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.task_id);
    if (message.description !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.description);
    if (message.total !== 0)
      writer.tag(3, WireType2.Varint).uint32(message.total);
    if (message.total_completions !== 0)
      writer.tag(4, WireType2.Varint).uint32(message.total_completions);
    if (message.completion_rate !== 0)
      writer.tag(5, WireType2.Bit64).double(message.completion_rate);
    if (message.created_at !== 0n)
      writer.tag(6, WireType2.Varint).uint64(message.created_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var AchievementTask = new AchievementTask$Type();
var PlayerAchievementStats$Type = class extends MessageType2 {
  constructor() {
    super("types.PlayerAchievementStats", [
      {
        no: 1,
        name: "total_points",
        kind: "scalar",
        localName: "total_points",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "completed_achievements",
        kind: "scalar",
        localName: "completed_achievements",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "total_achievements",
        kind: "scalar",
        localName: "total_achievements",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "completion_percentage",
        kind: "scalar",
        localName: "completion_percentage",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 5,
        name: "last_achievement_at",
        kind: "scalar",
        localName: "last_achievement_at",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 6,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 7,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total_points = 0;
    message.completed_achievements = 0;
    message.total_achievements = 0;
    message.completion_percentage = 0;
    message.created_at = 0n;
    message.updated_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 total_points */
        1:
          message.total_points = reader.uint32();
          break;
        case /* uint32 completed_achievements */
        2:
          message.completed_achievements = reader.uint32();
          break;
        case /* uint32 total_achievements */
        3:
          message.total_achievements = reader.uint32();
          break;
        case /* double completion_percentage */
        4:
          message.completion_percentage = reader.double();
          break;
        case /* optional uint64 last_achievement_at */
        5:
          message.last_achievement_at = reader.uint64().toBigInt();
          break;
        case /* uint64 created_at */
        6:
          message.created_at = reader.uint64().toBigInt();
          break;
        case /* uint64 updated_at */
        7:
          message.updated_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total_points !== 0)
      writer.tag(1, WireType2.Varint).uint32(message.total_points);
    if (message.completed_achievements !== 0)
      writer.tag(2, WireType2.Varint).uint32(message.completed_achievements);
    if (message.total_achievements !== 0)
      writer.tag(3, WireType2.Varint).uint32(message.total_achievements);
    if (message.completion_percentage !== 0)
      writer.tag(4, WireType2.Bit64).double(message.completion_percentage);
    if (message.last_achievement_at !== void 0)
      writer.tag(5, WireType2.Varint).uint64(message.last_achievement_at);
    if (message.created_at !== 0n)
      writer.tag(6, WireType2.Varint).uint64(message.created_at);
    if (message.updated_at !== 0n)
      writer.tag(7, WireType2.Varint).uint64(message.updated_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PlayerAchievementStats = new PlayerAchievementStats$Type();
var AchievementProgression$Type = class extends MessageType2 {
  constructor() {
    super("types.AchievementProgression", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "achievement_id",
        kind: "scalar",
        localName: "achievement_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "task_id",
        kind: "scalar",
        localName: "task_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "namespace",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "player_id",
        kind: "scalar",
        localName: "player_id",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 8,
        name: "completed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 9,
        name: "completed_at",
        kind: "scalar",
        localName: "completed_at",
        opt: true,
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "created_at",
        kind: "scalar",
        localName: "created_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "updated_at",
        kind: "scalar",
        localName: "updated_at",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.achievement_id = "";
    message.task_id = "";
    message.world_address = new Uint8Array(0);
    message.namespace = "";
    message.player_id = new Uint8Array(0);
    message.count = 0;
    message.completed = false;
    message.created_at = 0n;
    message.updated_at = 0n;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string achievement_id */
        2:
          message.achievement_id = reader.string();
          break;
        case /* string task_id */
        3:
          message.task_id = reader.string();
          break;
        case /* bytes world_address */
        4:
          message.world_address = reader.bytes();
          break;
        case /* string namespace */
        5:
          message.namespace = reader.string();
          break;
        case /* bytes player_id */
        6:
          message.player_id = reader.bytes();
          break;
        case /* uint32 count */
        7:
          message.count = reader.uint32();
          break;
        case /* bool completed */
        8:
          message.completed = reader.bool();
          break;
        case /* optional uint64 completed_at */
        9:
          message.completed_at = reader.uint64().toBigInt();
          break;
        case /* uint64 created_at */
        10:
          message.created_at = reader.uint64().toBigInt();
          break;
        case /* uint64 updated_at */
        11:
          message.updated_at = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.id);
    if (message.achievement_id !== "")
      writer.tag(2, WireType2.LengthDelimited).string(message.achievement_id);
    if (message.task_id !== "")
      writer.tag(3, WireType2.LengthDelimited).string(message.task_id);
    if (message.world_address.length)
      writer.tag(4, WireType2.LengthDelimited).bytes(message.world_address);
    if (message.namespace !== "")
      writer.tag(5, WireType2.LengthDelimited).string(message.namespace);
    if (message.player_id.length)
      writer.tag(6, WireType2.LengthDelimited).bytes(message.player_id);
    if (message.count !== 0)
      writer.tag(7, WireType2.Varint).uint32(message.count);
    if (message.completed !== false)
      writer.tag(8, WireType2.Varint).bool(message.completed);
    if (message.completed_at !== void 0)
      writer.tag(9, WireType2.Varint).uint64(message.completed_at);
    if (message.created_at !== 0n)
      writer.tag(10, WireType2.Varint).uint64(message.created_at);
    if (message.updated_at !== 0n)
      writer.tag(11, WireType2.Varint).uint64(message.updated_at);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var AchievementProgression = new AchievementProgression$Type();
var AchievementQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.AchievementQuery", [
      {
        no: 1,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "hidden",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    message.namespaces = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes world_addresses */
        1:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        2:
          message.namespaces.push(reader.string());
          break;
        case /* optional bool hidden */
        3:
          message.hidden = reader.bool();
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(2, WireType2.LengthDelimited).string(message.namespaces[i]);
    if (message.hidden !== void 0)
      writer.tag(3, WireType2.Varint).bool(message.hidden);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var AchievementQuery = new AchievementQuery$Type();
var PlayerAchievementQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.PlayerAchievementQuery", [
      {
        no: 1,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "player_addresses",
        kind: "scalar",
        localName: "player_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "pagination", kind: "message", T: () => Pagination }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    message.namespaces = [];
    message.player_addresses = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes world_addresses */
        1:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        2:
          message.namespaces.push(reader.string());
          break;
        case /* repeated bytes player_addresses */
        3:
          message.player_addresses.push(reader.bytes());
          break;
        case /* types.Pagination pagination */
        4:
          message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(2, WireType2.LengthDelimited).string(message.namespaces[i]);
    for (let i = 0; i < message.player_addresses.length; i++)
      writer.tag(3, WireType2.LengthDelimited).bytes(message.player_addresses[i]);
    if (message.pagination)
      Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PlayerAchievementQuery = new PlayerAchievementQuery$Type();
var PlayerAchievementProgress$Type = class extends MessageType2 {
  constructor() {
    super("types.PlayerAchievementProgress", [
      { no: 1, name: "achievement", kind: "message", T: () => Achievement },
      { no: 2, name: "taskProgress", kind: "message", repeat: 2, T: () => TaskProgress },
      {
        no: 3,
        name: "completed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "progress_percentage",
        kind: "scalar",
        localName: "progress_percentage",
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.taskProgress = [];
    message.completed = false;
    message.progress_percentage = 0;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Achievement achievement */
        1:
          message.achievement = Achievement.internalBinaryRead(reader, reader.uint32(), options, message.achievement);
          break;
        case /* repeated types.TaskProgress taskProgress */
        2:
          message.taskProgress.push(TaskProgress.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bool completed */
        3:
          message.completed = reader.bool();
          break;
        case /* double progress_percentage */
        4:
          message.progress_percentage = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.achievement)
      Achievement.internalBinaryWrite(message.achievement, writer.tag(1, WireType2.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.taskProgress.length; i++)
      TaskProgress.internalBinaryWrite(message.taskProgress[i], writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    if (message.completed !== false)
      writer.tag(3, WireType2.Varint).bool(message.completed);
    if (message.progress_percentage !== 0)
      writer.tag(4, WireType2.Bit64).double(message.progress_percentage);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PlayerAchievementProgress = new PlayerAchievementProgress$Type();
var TaskProgress$Type = class extends MessageType2 {
  constructor() {
    super("types.TaskProgress", [
      {
        no: 1,
        name: "task_id",
        kind: "scalar",
        localName: "task_id",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "completed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.task_id = "";
    message.count = 0;
    message.completed = false;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string task_id */
        1:
          message.task_id = reader.string();
          break;
        case /* uint32 count */
        2:
          message.count = reader.uint32();
          break;
        case /* bool completed */
        3:
          message.completed = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.task_id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.task_id);
    if (message.count !== 0)
      writer.tag(2, WireType2.Varint).uint32(message.count);
    if (message.completed !== false)
      writer.tag(3, WireType2.Varint).bool(message.completed);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TaskProgress = new TaskProgress$Type();
var PlayerAchievementEntry$Type = class extends MessageType2 {
  constructor() {
    super("types.PlayerAchievementEntry", [
      {
        no: 1,
        name: "player_address",
        kind: "scalar",
        localName: "player_address",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "stats", kind: "message", T: () => PlayerAchievementStats },
      { no: 3, name: "achievements", kind: "message", repeat: 2, T: () => PlayerAchievementProgress }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.player_address = new Uint8Array(0);
    message.achievements = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes player_address */
        1:
          message.player_address = reader.bytes();
          break;
        case /* types.PlayerAchievementStats stats */
        2:
          message.stats = PlayerAchievementStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
          break;
        case /* repeated types.PlayerAchievementProgress achievements */
        3:
          message.achievements.push(PlayerAchievementProgress.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.player_address.length)
      writer.tag(1, WireType2.LengthDelimited).bytes(message.player_address);
    if (message.stats)
      PlayerAchievementStats.internalBinaryWrite(message.stats, writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.achievements.length; i++)
      PlayerAchievementProgress.internalBinaryWrite(message.achievements[i], writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PlayerAchievementEntry = new PlayerAchievementEntry$Type();
var SearchQuery$Type = class extends MessageType2 {
  constructor() {
    super("types.SearchQuery", [
      {
        no: 1,
        name: "query",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.query = "";
    message.limit = 0;
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string query */
        1:
          message.query = reader.string();
          break;
        case /* uint32 limit */
        2:
          message.limit = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.query);
    if (message.limit !== 0)
      writer.tag(2, WireType2.Varint).uint32(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SearchQuery = new SearchQuery$Type();
var SearchMatch$Type = class extends MessageType2 {
  constructor() {
    super("types.SearchMatch", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "fields", kind: "map", K: 9, V: {
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      } },
      {
        no: 3,
        name: "score",
        kind: "scalar",
        opt: true,
        T: 1
        /*ScalarType.DOUBLE*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    message.fields = {};
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* map<string, string> fields */
        2:
          this.binaryReadMap2(message.fields, reader, options);
          break;
        case /* optional double score */
        3:
          message.score = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  binaryReadMap2(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.string();
          break;
        default:
          throw new globalThis.Error("unknown map entry field for types.SearchMatch.fields");
      }
    }
    map[key ?? ""] = val ?? "";
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.id);
    for (let k of globalThis.Object.keys(message.fields))
      writer.tag(2, WireType2.LengthDelimited).fork().tag(1, WireType2.LengthDelimited).string(k).tag(2, WireType2.LengthDelimited).string(message.fields[k]).join();
    if (message.score !== void 0)
      writer.tag(3, WireType2.Bit64).double(message.score);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SearchMatch = new SearchMatch$Type();
var TableSearchResults$Type = class extends MessageType2 {
  constructor() {
    super("types.TableSearchResults", [
      {
        no: 1,
        name: "table",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "matches", kind: "message", repeat: 2, T: () => SearchMatch }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.table = "";
    message.count = 0;
    message.matches = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string table */
        1:
          message.table = reader.string();
          break;
        case /* uint32 count */
        2:
          message.count = reader.uint32();
          break;
        case /* repeated types.SearchMatch matches */
        3:
          message.matches.push(SearchMatch.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.table !== "")
      writer.tag(1, WireType2.LengthDelimited).string(message.table);
    if (message.count !== 0)
      writer.tag(2, WireType2.Varint).uint32(message.count);
    for (let i = 0; i < message.matches.length; i++)
      SearchMatch.internalBinaryWrite(message.matches[i], writer.tag(3, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var TableSearchResults = new TableSearchResults$Type();
var SearchResponse$Type = class extends MessageType2 {
  constructor() {
    super("types.SearchResponse", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 2, name: "results", kind: "message", repeat: 2, T: () => TableSearchResults }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.total = 0;
    message.results = [];
    if (value !== void 0)
      reflectionMergePartial2(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 total */
        1:
          message.total = reader.uint32();
          break;
        case /* repeated types.TableSearchResults results */
        2:
          message.results.push(TableSearchResults.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler2.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.total !== 0)
      writer.tag(1, WireType2.Varint).uint32(message.total);
    for (let i = 0; i < message.results.length; i++)
      TableSearchResults.internalBinaryWrite(message.results[i], writer.tag(2, WireType2.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler2.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SearchResponse = new SearchResponse$Type();

// src/generated/google/protobuf/empty.ts
import { UnknownFieldHandler as UnknownFieldHandler3 } from "@protobuf-ts/runtime";
import { reflectionMergePartial as reflectionMergePartial3 } from "@protobuf-ts/runtime";
import { MessageType as MessageType3 } from "@protobuf-ts/runtime";
var Empty$Type = class extends MessageType3 {
  constructor() {
    super("google.protobuf.Empty", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial3(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler3.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler3.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var Empty = new Empty$Type();

// src/generated/world.ts
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType as WireType3 } from "@protobuf-ts/runtime";
import { UnknownFieldHandler as UnknownFieldHandler4 } from "@protobuf-ts/runtime";
import { reflectionMergePartial as reflectionMergePartial4 } from "@protobuf-ts/runtime";
import { MessageType as MessageType4 } from "@protobuf-ts/runtime";
var SubscribeTransactionsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTransactionsRequest", [
      { no: 1, name: "filter", kind: "message", T: () => TransactionFilter }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionFilter filter */
        1:
          message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.filter)
      TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTransactionsRequest = new SubscribeTransactionsRequest$Type();
var SubscribeTransactionsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTransactionsResponse", [
      { no: 1, name: "transaction", kind: "message", T: () => Transaction }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Transaction transaction */
        1:
          message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTransactionsResponse = new SubscribeTransactionsResponse$Type();
var RetrieveControllersRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveControllersRequest", [
      { no: 1, name: "query", kind: "message", T: () => ControllerQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ControllerQuery query */
        1:
          message.query = ControllerQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ControllerQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveControllersRequest = new RetrieveControllersRequest$Type();
var RetrieveControllersResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveControllersResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "controllers", kind: "message", repeat: 2, T: () => Controller }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.controllers = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Controller controllers */
        2:
          message.controllers.push(Controller.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.controllers.length; i++)
      Controller.internalBinaryWrite(message.controllers[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveControllersResponse = new RetrieveControllersResponse$Type();
var RetrieveContractsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => ContractQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ContractQuery query */
        1:
          message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveContractsRequest = new RetrieveContractsRequest$Type();
var RetrieveContractsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveContractsResponse", [
      { no: 1, name: "contracts", kind: "message", repeat: 2, T: () => Contract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contracts = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.Contract contracts */
        1:
          message.contracts.push(Contract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contracts.length; i++)
      Contract.internalBinaryWrite(message.contracts[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveContractsResponse = new RetrieveContractsResponse$Type();
var UpdateTokenBalancesSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateTokenBalancesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.account_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes account_addresses */
        3:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        4:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(4, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenBalancesSubscriptionRequest = new UpdateTokenBalancesSubscriptionRequest$Type();
var SubscribeTokenBalancesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokenBalancesResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "balance", kind: "message", T: () => TokenBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.TokenBalance balance */
        2:
          message.balance = TokenBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.balance)
      TokenBalance.internalBinaryWrite(message.balance, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenBalancesResponse = new SubscribeTokenBalancesResponse$Type();
var RetrieveTokensRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokensRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenQuery query */
        1:
          message.query = TokenQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokensRequest = new RetrieveTokensRequest$Type();
var SubscribeTokensRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokensRequest", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        2:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokensRequest = new SubscribeTokensRequest$Type();
var RetrieveTokensResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokensResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tokens", kind: "message", repeat: 2, T: () => Token }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.tokens = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Token tokens */
        2:
          message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.tokens.length; i++)
      Token.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokensResponse = new RetrieveTokensResponse$Type();
var SubscribeTokensResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokensResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "token", kind: "message", T: () => Token }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Token token */
        2:
          message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.token)
      Token.internalBinaryWrite(message.token, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokensResponse = new SubscribeTokensResponse$Type();
var UpdateTokenSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateTokenSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenSubscriptionRequest = new UpdateTokenSubscriptionRequest$Type();
var RetrieveTokenBalancesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenBalancesRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenBalanceQuery query */
        1:
          message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenBalancesRequest = new RetrieveTokenBalancesRequest$Type();
var SubscribeTokenBalancesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokenBalancesRequest", [
      {
        no: 1,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.account_addresses = [];
    message.contract_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes account_addresses */
        1:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenBalancesRequest = new SubscribeTokenBalancesRequest$Type();
var RetrieveTokenBalancesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenBalancesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "balances", kind: "message", repeat: 2, T: () => TokenBalance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.balances = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenBalance balances */
        2:
          message.balances.push(TokenBalance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.balances.length; i++)
      TokenBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenBalancesResponse = new RetrieveTokenBalancesResponse$Type();
var RetrieveTransactionsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTransactionsRequest", [
      { no: 1, name: "query", kind: "message", T: () => TransactionQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TransactionQuery query */
        1:
          message.query = TransactionQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TransactionQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTransactionsRequest = new RetrieveTransactionsRequest$Type();
var RetrieveTransactionsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTransactionsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transactions", kind: "message", repeat: 2, T: () => Transaction }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.transactions = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Transaction transactions */
        2:
          message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.transactions.length; i++)
      Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTransactionsResponse = new RetrieveTransactionsResponse$Type();
var RetrieveTokenContractsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenContractQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenContractQuery query */
        1:
          message.query = TokenContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenContractsRequest = new RetrieveTokenContractsRequest$Type();
var RetrieveTokenContractsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenContractsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "token_contracts", kind: "message", localName: "token_contracts", repeat: 2, T: () => TokenContract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.token_contracts = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenContract token_contracts */
        2:
          message.token_contracts.push(TokenContract.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.token_contracts.length; i++)
      TokenContract.internalBinaryWrite(message.token_contracts[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenContractsResponse = new RetrieveTokenContractsResponse$Type();
var SubscribeContractsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeContractsRequest", [
      { no: 1, name: "query", kind: "message", T: () => ContractQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ContractQuery query */
        1:
          message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeContractsRequest = new SubscribeContractsRequest$Type();
var SubscribeContractsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeContractsResponse", [
      { no: 1, name: "contract", kind: "message", T: () => Contract }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Contract contract */
        1:
          message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.contract)
      Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeContractsResponse = new SubscribeContractsResponse$Type();
var WorldsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.WorldsRequest", [
      {
        no: 1,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes world_addresses */
        1:
          message.world_addresses.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var WorldsRequest = new WorldsRequest$Type();
var WorldsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.WorldsResponse", [
      { no: 1, name: "worlds", kind: "message", repeat: 2, T: () => World }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.worlds = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.World worlds */
        1:
          message.worlds.push(World.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.worlds.length; i++)
      World.internalBinaryWrite(message.worlds[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var WorldsResponse = new WorldsResponse$Type();
var SubscribeEntitiesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEntitiesRequest", [
      { no: 1, name: "clause", kind: "message", T: () => Clause },
      {
        no: 2,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Clause clause */
        1:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        case /* repeated bytes world_addresses */
        2:
          message.world_addresses.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();
var UpdateEntitiesSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateEntitiesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "clause", kind: "message", T: () => Clause },
      {
        no: 3,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.world_addresses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Clause clause */
        2:
          message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
          break;
        case /* repeated bytes world_addresses */
        3:
          message.world_addresses.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.clause)
      Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateEntitiesSubscriptionRequest = new UpdateEntitiesSubscriptionRequest$Type();
var SubscribeEntityResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEntityResponse", [
      { no: 1, name: "entity", kind: "message", T: () => Entity },
      {
        no: 2,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Entity entity */
        1:
          message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
          break;
        case /* uint64 subscription_id */
        2:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.entity)
      Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    if (message.subscription_id !== 0n)
      writer.tag(2, WireType3.Varint).uint64(message.subscription_id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEntityResponse = new SubscribeEntityResponse$Type();
var RetrieveEntitiesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEntitiesRequest", [
      { no: 1, name: "query", kind: "message", T: () => Query }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Query query */
        1:
          message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      Query.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();
var RetrieveEntitiesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEntitiesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "entities", kind: "message", repeat: 2, T: () => Entity }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.entities = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Entity entities */
        2:
          message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.entities.length; i++)
      Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();
var RetrieveEventsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEventsRequest", [
      { no: 1, name: "query", kind: "message", T: () => EventQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.EventQuery query */
        1:
          message.query = EventQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      EventQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventsRequest = new RetrieveEventsRequest$Type();
var RetrieveEventsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveEventsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "events", kind: "message", repeat: 2, T: () => Event }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.events = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Event events */
        2:
          message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.events.length; i++)
      Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveEventsResponse = new RetrieveEventsResponse$Type();
var SubscribeEventsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEventsRequest", [
      { no: 1, name: "keys", kind: "message", repeat: 2, T: () => KeysClause }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.keys = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated types.KeysClause keys */
        1:
          message.keys.push(KeysClause.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.keys.length; i++)
      KeysClause.internalBinaryWrite(message.keys[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventsRequest = new SubscribeEventsRequest$Type();
var SubscribeEventsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeEventsResponse", [
      { no: 1, name: "event", kind: "message", T: () => Event }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.Event event */
        1:
          message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.event)
      Event.internalBinaryWrite(message.event, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeEventsResponse = new SubscribeEventsResponse$Type();
var PublishMessageRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageRequest", [
      {
        no: 1,
        name: "signature",
        kind: "scalar",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "world_address",
        kind: "scalar",
        localName: "world_address",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signature = [];
    message.message = "";
    message.world_address = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes signature */
        1:
          message.signature.push(reader.bytes());
          break;
        case /* string message */
        2:
          message.message = reader.string();
          break;
        case /* bytes world_address */
        3:
          message.world_address = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.signature.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.signature[i]);
    if (message.message !== "")
      writer.tag(2, WireType3.LengthDelimited).string(message.message);
    if (message.world_address.length)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.world_address);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageRequest = new PublishMessageRequest$Type();
var PublishMessageResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageResponse", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.id = "";
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageResponse = new PublishMessageResponse$Type();
var PublishMessageBatchRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageBatchRequest", [
      { no: 1, name: "messages", kind: "message", repeat: 2, T: () => PublishMessageRequest }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messages = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated world.PublishMessageRequest messages */
        1:
          message.messages.push(PublishMessageRequest.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.messages.length; i++)
      PublishMessageRequest.internalBinaryWrite(message.messages[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();
var PublishMessageBatchResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.PublishMessageBatchResponse", [
      { no: 1, name: "responses", kind: "message", repeat: 2, T: () => PublishMessageResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.responses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated world.PublishMessageResponse responses */
        1:
          message.responses.push(PublishMessageResponse.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.responses.length; i++)
      PublishMessageResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var PublishMessageBatchResponse = new PublishMessageBatchResponse$Type();
var SubscribeTokenTransfersRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokenTransfersRequest", [
      {
        no: 1,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.contract_addresses = [];
    message.account_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes contract_addresses */
        1:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes account_addresses */
        2:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        3:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenTransfersRequest = new SubscribeTokenTransfersRequest$Type();
var SubscribeTokenTransfersResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeTokenTransfersResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "transfer", kind: "message", T: () => TokenTransfer }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.TokenTransfer transfer */
        2:
          message.transfer = TokenTransfer.internalBinaryRead(reader, reader.uint32(), options, message.transfer);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.transfer)
      TokenTransfer.internalBinaryWrite(message.transfer, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeTokenTransfersResponse = new SubscribeTokenTransfersResponse$Type();
var UpdateTokenTransfersSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateTokenTransfersSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "contract_addresses",
        kind: "scalar",
        localName: "contract_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "account_addresses",
        kind: "scalar",
        localName: "account_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "token_ids",
        kind: "scalar",
        localName: "token_ids",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.contract_addresses = [];
    message.account_addresses = [];
    message.token_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes contract_addresses */
        2:
          message.contract_addresses.push(reader.bytes());
          break;
        case /* repeated bytes account_addresses */
        3:
          message.account_addresses.push(reader.bytes());
          break;
        case /* repeated bytes token_ids */
        4:
          message.token_ids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.contract_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.contract_addresses[i]);
    for (let i = 0; i < message.account_addresses.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.account_addresses[i]);
    for (let i = 0; i < message.token_ids.length; i++)
      writer.tag(4, WireType3.LengthDelimited).bytes(message.token_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateTokenTransfersSubscriptionRequest = new UpdateTokenTransfersSubscriptionRequest$Type();
var RetrieveTokenTransfersRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenTransfersRequest", [
      { no: 1, name: "query", kind: "message", T: () => TokenTransferQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.TokenTransferQuery query */
        1:
          message.query = TokenTransferQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      TokenTransferQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenTransfersRequest = new RetrieveTokenTransfersRequest$Type();
var RetrieveTokenTransfersResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveTokenTransfersResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transfers", kind: "message", repeat: 2, T: () => TokenTransfer }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.transfers = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.TokenTransfer transfers */
        2:
          message.transfers.push(TokenTransfer.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.transfers.length; i++)
      TokenTransfer.internalBinaryWrite(message.transfers[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveTokenTransfersResponse = new RetrieveTokenTransfersResponse$Type();
var RetrieveAggregationsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveAggregationsRequest", [
      { no: 1, name: "query", kind: "message", T: () => AggregationQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.AggregationQuery query */
        1:
          message.query = AggregationQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      AggregationQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveAggregationsRequest = new RetrieveAggregationsRequest$Type();
var RetrieveAggregationsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveAggregationsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "entries", kind: "message", repeat: 2, T: () => AggregationEntry }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.entries = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.AggregationEntry entries */
        2:
          message.entries.push(AggregationEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.entries.length; i++)
      AggregationEntry.internalBinaryWrite(message.entries[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveAggregationsResponse = new RetrieveAggregationsResponse$Type();
var SubscribeAggregationsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeAggregationsRequest", [
      {
        no: 1,
        name: "aggregator_ids",
        kind: "scalar",
        localName: "aggregator_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "entity_ids",
        kind: "scalar",
        localName: "entity_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.aggregator_ids = [];
    message.entity_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string aggregator_ids */
        1:
          message.aggregator_ids.push(reader.string());
          break;
        case /* repeated string entity_ids */
        2:
          message.entity_ids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.aggregator_ids.length; i++)
      writer.tag(1, WireType3.LengthDelimited).string(message.aggregator_ids[i]);
    for (let i = 0; i < message.entity_ids.length; i++)
      writer.tag(2, WireType3.LengthDelimited).string(message.entity_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeAggregationsRequest = new SubscribeAggregationsRequest$Type();
var SubscribeAggregationsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeAggregationsResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "entry", kind: "message", T: () => AggregationEntry }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.AggregationEntry entry */
        2:
          message.entry = AggregationEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.entry)
      AggregationEntry.internalBinaryWrite(message.entry, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeAggregationsResponse = new SubscribeAggregationsResponse$Type();
var UpdateAggregationsSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateAggregationsSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "aggregator_ids",
        kind: "scalar",
        localName: "aggregator_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "entity_ids",
        kind: "scalar",
        localName: "entity_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.aggregator_ids = [];
    message.entity_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated string aggregator_ids */
        2:
          message.aggregator_ids.push(reader.string());
          break;
        case /* repeated string entity_ids */
        3:
          message.entity_ids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.aggregator_ids.length; i++)
      writer.tag(2, WireType3.LengthDelimited).string(message.aggregator_ids[i]);
    for (let i = 0; i < message.entity_ids.length; i++)
      writer.tag(3, WireType3.LengthDelimited).string(message.entity_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateAggregationsSubscriptionRequest = new UpdateAggregationsSubscriptionRequest$Type();
var UpdateAggregationsSubscriptionResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateAggregationsSubscriptionResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateAggregationsSubscriptionResponse = new UpdateAggregationsSubscriptionResponse$Type();
var RetrieveActivitiesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveActivitiesRequest", [
      { no: 1, name: "query", kind: "message", T: () => ActivityQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.ActivityQuery query */
        1:
          message.query = ActivityQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      ActivityQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveActivitiesRequest = new RetrieveActivitiesRequest$Type();
var RetrieveActivitiesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveActivitiesResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "activities", kind: "message", repeat: 2, T: () => Activity }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.activities = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Activity activities */
        2:
          message.activities.push(Activity.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.activities.length; i++)
      Activity.internalBinaryWrite(message.activities[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveActivitiesResponse = new RetrieveActivitiesResponse$Type();
var SubscribeActivitiesRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeActivitiesRequest", [
      {
        no: 1,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "caller_addresses",
        kind: "scalar",
        localName: "caller_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    message.namespaces = [];
    message.caller_addresses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes world_addresses */
        1:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        2:
          message.namespaces.push(reader.string());
          break;
        case /* repeated bytes caller_addresses */
        3:
          message.caller_addresses.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(2, WireType3.LengthDelimited).string(message.namespaces[i]);
    for (let i = 0; i < message.caller_addresses.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.caller_addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeActivitiesRequest = new SubscribeActivitiesRequest$Type();
var SubscribeActivitiesResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeActivitiesResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "activity", kind: "message", T: () => Activity }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.Activity activity */
        2:
          message.activity = Activity.internalBinaryRead(reader, reader.uint32(), options, message.activity);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.activity)
      Activity.internalBinaryWrite(message.activity, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeActivitiesResponse = new SubscribeActivitiesResponse$Type();
var UpdateActivitiesSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateActivitiesSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "caller_addresses",
        kind: "scalar",
        localName: "caller_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.world_addresses = [];
    message.namespaces = [];
    message.caller_addresses = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes world_addresses */
        2:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        3:
          message.namespaces.push(reader.string());
          break;
        case /* repeated bytes caller_addresses */
        4:
          message.caller_addresses.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(3, WireType3.LengthDelimited).string(message.namespaces[i]);
    for (let i = 0; i < message.caller_addresses.length; i++)
      writer.tag(4, WireType3.LengthDelimited).bytes(message.caller_addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateActivitiesSubscriptionRequest = new UpdateActivitiesSubscriptionRequest$Type();
var SubscribeAchievementProgressionsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeAchievementProgressionsRequest", [
      {
        no: 1,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "player_addresses",
        kind: "scalar",
        localName: "player_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "achievement_ids",
        kind: "scalar",
        localName: "achievement_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.world_addresses = [];
    message.namespaces = [];
    message.player_addresses = [];
    message.achievement_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes world_addresses */
        1:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        2:
          message.namespaces.push(reader.string());
          break;
        case /* repeated bytes player_addresses */
        3:
          message.player_addresses.push(reader.bytes());
          break;
        case /* repeated string achievement_ids */
        4:
          message.achievement_ids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(1, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(2, WireType3.LengthDelimited).string(message.namespaces[i]);
    for (let i = 0; i < message.player_addresses.length; i++)
      writer.tag(3, WireType3.LengthDelimited).bytes(message.player_addresses[i]);
    for (let i = 0; i < message.achievement_ids.length; i++)
      writer.tag(4, WireType3.LengthDelimited).string(message.achievement_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeAchievementProgressionsRequest = new SubscribeAchievementProgressionsRequest$Type();
var SubscribeAchievementProgressionsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.SubscribeAchievementProgressionsResponse", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 2, name: "progression", kind: "message", T: () => AchievementProgression }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* types.AchievementProgression progression */
        2:
          message.progression = AchievementProgression.internalBinaryRead(reader, reader.uint32(), options, message.progression);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    if (message.progression)
      AchievementProgression.internalBinaryWrite(message.progression, writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SubscribeAchievementProgressionsResponse = new SubscribeAchievementProgressionsResponse$Type();
var UpdateAchievementProgressionsSubscriptionRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.UpdateAchievementProgressionsSubscriptionRequest", [
      {
        no: 1,
        name: "subscription_id",
        kind: "scalar",
        localName: "subscription_id",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "world_addresses",
        kind: "scalar",
        localName: "world_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "namespaces",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "player_addresses",
        kind: "scalar",
        localName: "player_addresses",
        repeat: 2,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 5,
        name: "achievement_ids",
        kind: "scalar",
        localName: "achievement_ids",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.subscription_id = 0n;
    message.world_addresses = [];
    message.namespaces = [];
    message.player_addresses = [];
    message.achievement_ids = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 subscription_id */
        1:
          message.subscription_id = reader.uint64().toBigInt();
          break;
        case /* repeated bytes world_addresses */
        2:
          message.world_addresses.push(reader.bytes());
          break;
        case /* repeated string namespaces */
        3:
          message.namespaces.push(reader.string());
          break;
        case /* repeated bytes player_addresses */
        4:
          message.player_addresses.push(reader.bytes());
          break;
        case /* repeated string achievement_ids */
        5:
          message.achievement_ids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.subscription_id !== 0n)
      writer.tag(1, WireType3.Varint).uint64(message.subscription_id);
    for (let i = 0; i < message.world_addresses.length; i++)
      writer.tag(2, WireType3.LengthDelimited).bytes(message.world_addresses[i]);
    for (let i = 0; i < message.namespaces.length; i++)
      writer.tag(3, WireType3.LengthDelimited).string(message.namespaces[i]);
    for (let i = 0; i < message.player_addresses.length; i++)
      writer.tag(4, WireType3.LengthDelimited).bytes(message.player_addresses[i]);
    for (let i = 0; i < message.achievement_ids.length; i++)
      writer.tag(5, WireType3.LengthDelimited).string(message.achievement_ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var UpdateAchievementProgressionsSubscriptionRequest = new UpdateAchievementProgressionsSubscriptionRequest$Type();
var RetrieveAchievementsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveAchievementsRequest", [
      { no: 1, name: "query", kind: "message", T: () => AchievementQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.AchievementQuery query */
        1:
          message.query = AchievementQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      AchievementQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveAchievementsRequest = new RetrieveAchievementsRequest$Type();
var RetrieveAchievementsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrieveAchievementsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "achievements", kind: "message", repeat: 2, T: () => Achievement }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.achievements = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.Achievement achievements */
        2:
          message.achievements.push(Achievement.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.achievements.length; i++)
      Achievement.internalBinaryWrite(message.achievements[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrieveAchievementsResponse = new RetrieveAchievementsResponse$Type();
var RetrievePlayerAchievementsRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrievePlayerAchievementsRequest", [
      { no: 1, name: "query", kind: "message", T: () => PlayerAchievementQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.PlayerAchievementQuery query */
        1:
          message.query = PlayerAchievementQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      PlayerAchievementQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrievePlayerAchievementsRequest = new RetrievePlayerAchievementsRequest$Type();
var RetrievePlayerAchievementsResponse$Type = class extends MessageType4 {
  constructor() {
    super("world.RetrievePlayerAchievementsResponse", [
      {
        no: 1,
        name: "next_cursor",
        kind: "scalar",
        localName: "next_cursor",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "players", kind: "message", repeat: 2, T: () => PlayerAchievementEntry }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.next_cursor = "";
    message.players = [];
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string next_cursor */
        1:
          message.next_cursor = reader.string();
          break;
        case /* repeated types.PlayerAchievementEntry players */
        2:
          message.players.push(PlayerAchievementEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.next_cursor !== "")
      writer.tag(1, WireType3.LengthDelimited).string(message.next_cursor);
    for (let i = 0; i < message.players.length; i++)
      PlayerAchievementEntry.internalBinaryWrite(message.players[i], writer.tag(2, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var RetrievePlayerAchievementsResponse = new RetrievePlayerAchievementsResponse$Type();
var SearchRequest$Type = class extends MessageType4 {
  constructor() {
    super("world.SearchRequest", [
      { no: 1, name: "query", kind: "message", T: () => SearchQuery }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.SearchQuery query */
        1:
          message.query = SearchQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.query)
      SearchQuery.internalBinaryWrite(message.query, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SearchRequest = new SearchRequest$Type();
var SearchResponse$Type2 = class extends MessageType4 {
  constructor() {
    super("world.SearchResponse", [
      { no: 1, name: "response", kind: "message", T: () => SearchResponse }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial4(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* types.SearchResponse response */
        1:
          message.response = SearchResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler4.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.response)
      SearchResponse.internalBinaryWrite(message.response, writer.tag(1, WireType3.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler4.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
};
var SearchResponse2 = new SearchResponse$Type2();
var World2 = new ServiceType("world.World", [
  { name: "SubscribeContracts", serverStreaming: true, options: {}, I: SubscribeContractsRequest, O: SubscribeContractsResponse },
  { name: "Worlds", options: {}, I: WorldsRequest, O: WorldsResponse },
  { name: "SubscribeEntities", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
  { name: "UpdateEntitiesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
  { name: "RetrieveEntities", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
  { name: "SubscribeEventMessages", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
  { name: "UpdateEventMessagesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
  { name: "SubscribeTokenBalances", serverStreaming: true, options: {}, I: SubscribeTokenBalancesRequest, O: SubscribeTokenBalancesResponse },
  { name: "UpdateTokenBalancesSubscription", options: {}, I: UpdateTokenBalancesSubscriptionRequest, O: Empty },
  { name: "SubscribeTokens", serverStreaming: true, options: {}, I: SubscribeTokensRequest, O: SubscribeTokensResponse },
  { name: "UpdateTokensSubscription", options: {}, I: UpdateTokenSubscriptionRequest, O: Empty },
  { name: "SubscribeTokenTransfers", serverStreaming: true, options: {}, I: SubscribeTokenTransfersRequest, O: SubscribeTokenTransfersResponse },
  { name: "UpdateTokenTransfersSubscription", options: {}, I: UpdateTokenTransfersSubscriptionRequest, O: Empty },
  { name: "RetrieveEventMessages", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
  { name: "RetrieveEvents", options: {}, I: RetrieveEventsRequest, O: RetrieveEventsResponse },
  { name: "SubscribeEvents", serverStreaming: true, options: {}, I: SubscribeEventsRequest, O: SubscribeEventsResponse },
  { name: "RetrieveTokens", options: {}, I: RetrieveTokensRequest, O: RetrieveTokensResponse },
  { name: "RetrieveTokenTransfers", options: {}, I: RetrieveTokenTransfersRequest, O: RetrieveTokenTransfersResponse },
  { name: "RetrieveTokenBalances", options: {}, I: RetrieveTokenBalancesRequest, O: RetrieveTokenBalancesResponse },
  { name: "RetrieveTransactions", options: {}, I: RetrieveTransactionsRequest, O: RetrieveTransactionsResponse },
  { name: "SubscribeTransactions", serverStreaming: true, options: {}, I: SubscribeTransactionsRequest, O: SubscribeTransactionsResponse },
  { name: "RetrieveControllers", options: {}, I: RetrieveControllersRequest, O: RetrieveControllersResponse },
  { name: "RetrieveContracts", options: {}, I: RetrieveContractsRequest, O: RetrieveContractsResponse },
  { name: "RetrieveTokenContracts", options: {}, I: RetrieveTokenContractsRequest, O: RetrieveTokenContractsResponse },
  { name: "RetrieveAggregations", options: {}, I: RetrieveAggregationsRequest, O: RetrieveAggregationsResponse },
  { name: "SubscribeAggregations", serverStreaming: true, options: {}, I: SubscribeAggregationsRequest, O: SubscribeAggregationsResponse },
  { name: "UpdateAggregationsSubscription", options: {}, I: UpdateAggregationsSubscriptionRequest, O: UpdateAggregationsSubscriptionResponse },
  { name: "RetrieveActivities", options: {}, I: RetrieveActivitiesRequest, O: RetrieveActivitiesResponse },
  { name: "SubscribeActivities", serverStreaming: true, options: {}, I: SubscribeActivitiesRequest, O: SubscribeActivitiesResponse },
  { name: "UpdateActivitiesSubscription", options: {}, I: UpdateActivitiesSubscriptionRequest, O: Empty },
  { name: "RetrieveAchievements", options: {}, I: RetrieveAchievementsRequest, O: RetrieveAchievementsResponse },
  { name: "RetrievePlayerAchievements", options: {}, I: RetrievePlayerAchievementsRequest, O: RetrievePlayerAchievementsResponse },
  { name: "Search", options: {}, I: SearchRequest, O: SearchResponse2 },
  { name: "SubscribeAchievementProgressions", serverStreaming: true, options: {}, I: SubscribeAchievementProgressionsRequest, O: SubscribeAchievementProgressionsResponse },
  { name: "UpdateAchievementProgressionsSubscription", options: {}, I: UpdateAchievementProgressionsSubscriptionRequest, O: Empty },
  { name: "PublishMessage", options: {}, I: PublishMessageRequest, O: PublishMessageResponse },
  { name: "PublishMessageBatch", options: {}, I: PublishMessageBatchRequest, O: PublishMessageBatchResponse },
  { name: "ExecuteSql", options: {}, I: SqlQueryRequest, O: SqlQueryResponse }
]);

// src/generated/world.client.ts
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
var WorldClient = class {
  constructor(_transport) {
    this._transport = _transport;
  }
  typeName = World2.typeName;
  methods = World2.methods;
  options = World2.options;
  /**
   * Subscribes to updates about contracts. Like the head block number, tps, etc.
   *
   * @generated from protobuf rpc: SubscribeContracts
   */
  subscribeContracts(input, options) {
    const method = this.methods[0], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieves metadata about the World including all the registered components and systems.
   *
   * @generated from protobuf rpc: Worlds
   */
  worlds(input, options) {
    const method = this.methods[1], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to entity updates.
   *
   * @generated from protobuf rpc: SubscribeEntities
   */
  subscribeEntities(input, options) {
    const method = this.methods[2], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update entity subscription
   *
   * @generated from protobuf rpc: UpdateEntitiesSubscription
   */
  updateEntitiesSubscription(input, options) {
    const method = this.methods[3], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve entities
   *
   * @generated from protobuf rpc: RetrieveEntities
   */
  retrieveEntities(input, options) {
    const method = this.methods[4], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to entity updates.
   *
   * @generated from protobuf rpc: SubscribeEventMessages
   */
  subscribeEventMessages(input, options) {
    const method = this.methods[5], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update entity subscription
   *
   * @generated from protobuf rpc: UpdateEventMessagesSubscription
   */
  updateEventMessagesSubscription(input, options) {
    const method = this.methods[6], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token balance updates.
   *
   * @generated from protobuf rpc: SubscribeTokenBalances
   */
  subscribeTokenBalances(input, options) {
    const method = this.methods[7], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token balance subscription
   *
   * @generated from protobuf rpc: UpdateTokenBalancesSubscription
   */
  updateTokenBalancesSubscription(input, options) {
    const method = this.methods[8], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token updates.
   *
   * @generated from protobuf rpc: SubscribeTokens
   */
  subscribeTokens(input, options) {
    const method = this.methods[9], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token subscription
   *
   * @generated from protobuf rpc: UpdateTokensSubscription
   */
  updateTokensSubscription(input, options) {
    const method = this.methods[10], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to token transfer updates.
   *
   * @generated from protobuf rpc: SubscribeTokenTransfers
   */
  subscribeTokenTransfers(input, options) {
    const method = this.methods[11], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update token transfer subscription
   *
   * @generated from protobuf rpc: UpdateTokenTransfersSubscription
   */
  updateTokenTransfersSubscription(input, options) {
    const method = this.methods[12], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve entities
   *
   * @generated from protobuf rpc: RetrieveEventMessages
   */
  retrieveEventMessages(input, options) {
    const method = this.methods[13], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve events
   *
   * @generated from protobuf rpc: RetrieveEvents
   */
  retrieveEvents(input, options) {
    const method = this.methods[14], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to events
   *
   * @generated from protobuf rpc: SubscribeEvents
   */
  subscribeEvents(input, options) {
    const method = this.methods[15], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieve tokens
   *
   * @generated from protobuf rpc: RetrieveTokens
   */
  retrieveTokens(input, options) {
    const method = this.methods[16], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve token transfers
   *
   * @generated from protobuf rpc: RetrieveTokenTransfers
   */
  retrieveTokenTransfers(input, options) {
    const method = this.methods[17], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve token balances
   *
   * @generated from protobuf rpc: RetrieveTokenBalances
   */
  retrieveTokenBalances(input, options) {
    const method = this.methods[18], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve transactions
   *
   * @generated from protobuf rpc: RetrieveTransactions
   */
  retrieveTransactions(input, options) {
    const method = this.methods[19], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to transactions
   *
   * @generated from protobuf rpc: SubscribeTransactions
   */
  subscribeTransactions(input, options) {
    const method = this.methods[20], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Retrieve controllers
   *
   * @generated from protobuf rpc: RetrieveControllers
   */
  retrieveControllers(input, options) {
    const method = this.methods[21], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve contracts
   *
   * @generated from protobuf rpc: RetrieveContracts
   */
  retrieveContracts(input, options) {
    const method = this.methods[22], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve token contracts
   *
   * @generated from protobuf rpc: RetrieveTokenContracts
   */
  retrieveTokenContracts(input, options) {
    const method = this.methods[23], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve aggregations (leaderboards, stats, rankings)
   *
   * @generated from protobuf rpc: RetrieveAggregations
   */
  retrieveAggregations(input, options) {
    const method = this.methods[24], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to aggregation updates (leaderboards, stats, rankings)
   *
   * @generated from protobuf rpc: SubscribeAggregations
   */
  subscribeAggregations(input, options) {
    const method = this.methods[25], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update an aggregations subscription
   *
   * @generated from protobuf rpc: UpdateAggregationsSubscription
   */
  updateAggregationsSubscription(input, options) {
    const method = this.methods[26], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve activities (user session tracking)
   *
   * @generated from protobuf rpc: RetrieveActivities
   */
  retrieveActivities(input, options) {
    const method = this.methods[27], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to activity updates (user session tracking)
   *
   * @generated from protobuf rpc: SubscribeActivities
   */
  subscribeActivities(input, options) {
    const method = this.methods[28], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update an activities subscription
   *
   * @generated from protobuf rpc: UpdateActivitiesSubscription
   */
  updateActivitiesSubscription(input, options) {
    const method = this.methods[29], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve achievements
   *
   * @generated from protobuf rpc: RetrieveAchievements
   */
  retrieveAchievements(input, options) {
    const method = this.methods[30], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Retrieve player achievements (stats + progress)
   *
   * @generated from protobuf rpc: RetrievePlayerAchievements
   */
  retrievePlayerAchievements(input, options) {
    const method = this.methods[31], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Global FTS5 search across indexed tables
   *
   * @generated from protobuf rpc: Search
   */
  search(input, options) {
    const method = this.methods[32], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Subscribe to achievement progression updates
   *
   * @generated from protobuf rpc: SubscribeAchievementProgressions
   */
  subscribeAchievementProgressions(input, options) {
    const method = this.methods[33], opt = this._transport.mergeOptions(options);
    return stackIntercept("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Update an achievement progressions subscription
   *
   * @generated from protobuf rpc: UpdateAchievementProgressionsSubscription
   */
  updateAchievementProgressionsSubscription(input, options) {
    const method = this.methods[34], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Publish a torii offchain message
   *
   * @generated from protobuf rpc: PublishMessage
   */
  publishMessage(input, options) {
    const method = this.methods[35], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Publish a set of torii offchain messages
   *
   * @generated from protobuf rpc: PublishMessageBatch
   */
  publishMessageBatch(input, options) {
    const method = this.methods[36], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * Execute a SQL query and return results
   *
   * @generated from protobuf rpc: ExecuteSql
   */
  executeSql(input, options) {
    const method = this.methods[37], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
};

// src/client.ts
var DojoGrpcClient = class {
  transport;
  worldClient;
  constructor(config) {
    this.transport = new GrpcWebFetchTransport({
      baseUrl: config.url,
      format: "binary"
    });
    this.worldClient = new WorldClient(this.transport);
  }
  destroy() {
  }
};
function createDojoGrpcClient(config) {
  return new DojoGrpcClient(config);
}

// src/mappings/query.ts
import { addAddressPadding } from "starknet";
function hexToBuffer(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
var grpcContractTypeByName = Object.fromEntries(
  Object.entries(ContractType).filter(
    ([, value]) => typeof value === "number"
  )
);
var grpcContractTypeValues = new Set(
  Object.values(grpcContractTypeByName)
);
function normalizeGrpcContractTypeValue(value) {
  if (typeof value === "number") {
    if (grpcContractTypeValues.has(value)) {
      return value;
    }
  } else if (typeof value === "string") {
    const normalized = value.replace(/^contracttype\./i, "").replace(/\s+/g, "").toUpperCase();
    const byName = grpcContractTypeByName[normalized];
    if (byName !== void 0) {
      return byName;
    }
    const numeric = Number(value);
    if (!Number.isNaN(numeric) && grpcContractTypeValues.has(numeric)) {
      return numeric;
    }
  }
  throw new Error(`Unsupported contract type value: ${String(value)}`);
}
function normalizeGrpcContractTypes(contractTypes) {
  if (contractTypes == null) {
    return [];
  }
  const values = Array.isArray(contractTypes) ? contractTypes : [contractTypes];
  if (values.length === 0) {
    return [];
  }
  return values.map((value) => normalizeGrpcContractTypeValue(value));
}
function mapOrderDirection(direction) {
  switch (direction) {
    case "Asc":
      return 0 /* ASC */;
    case "Desc":
      return 1 /* DESC */;
    default:
      return 0 /* ASC */;
  }
}
function mapPaginationDirection(direction) {
  switch (direction) {
    case "Forward":
      return 0 /* FORWARD */;
    case "Backward":
      return 1 /* BACKWARD */;
    default:
      return 0 /* FORWARD */;
  }
}
function mapOrderBy(orderBy) {
  return {
    field: orderBy.field,
    direction: mapOrderDirection(orderBy.direction)
  };
}
function mapPagination(pagination) {
  return {
    limit: pagination.limit || 0,
    cursor: pagination.cursor || "",
    direction: mapPaginationDirection(pagination.direction),
    order_by: pagination.order_by.map(mapOrderBy)
  };
}
function mapPatternMatching(pattern) {
  switch (pattern) {
    case "FixedLen":
      return 0 /* FixedLen */;
    case "VariableLen":
      return 1 /* VariableLen */;
    default:
      return 0 /* FixedLen */;
  }
}
function mapComparisonOperator(op) {
  switch (op) {
    case "Eq":
      return 0 /* EQ */;
    case "Neq":
      return 1 /* NEQ */;
    case "Gt":
      return 2 /* GT */;
    case "Gte":
      return 3 /* GTE */;
    case "Lt":
      return 4 /* LT */;
    case "Lte":
      return 5 /* LTE */;
    case "In":
      return 6 /* IN */;
    case "NotIn":
      return 7 /* NOT_IN */;
    default:
      return 0 /* EQ */;
  }
}
function mapLogicalOperator(op) {
  switch (op) {
    case "And":
      return 0 /* AND */;
    case "Or":
      return 1 /* OR */;
    default:
      return 0 /* AND */;
  }
}
function mapMemberValue(value) {
  if (typeof value === "string") {
    return { value_type: { oneofKind: "string", string: value } };
  } else if (Array.isArray(value)) {
    return {
      value_type: {
        oneofKind: "list",
        list: { values: value.map(mapMemberValue) }
      }
    };
  } else if (value && typeof value === "object" && "Primitive" in value) {
    return {
      value_type: {
        oneofKind: "primitive",
        primitive: value.Primitive
      }
    };
  }
  return {
    value_type: { oneofKind: "string", string: String(value) }
  };
}
function mapClause(clause) {
  if ("HashedKeys" in clause) {
    const hashedKeysClause = {
      hashed_keys: clause.HashedKeys.map(hexToBuffer)
    };
    return {
      clause_type: {
        oneofKind: "hashed_keys",
        hashed_keys: hashedKeysClause
      }
    };
  } else if ("Keys" in clause) {
    const keysClause = {
      keys: clause.Keys.keys.map(
        (k) => k ? hexToBuffer(k) : new Uint8Array()
      ),
      pattern_matching: mapPatternMatching(clause.Keys.pattern_matching),
      models: clause.Keys.models
    };
    return {
      clause_type: { oneofKind: "keys", keys: keysClause }
    };
  } else if ("Member" in clause) {
    const memberClause = {
      model: clause.Member.model,
      member: clause.Member.member,
      operator: mapComparisonOperator(clause.Member.operator),
      value: mapMemberValue(clause.Member.value)
    };
    return {
      clause_type: { oneofKind: "member", member: memberClause }
    };
  } else if ("Composite" in clause) {
    const compositeClause = {
      operator: mapLogicalOperator(clause.Composite.operator),
      clauses: clause.Composite.clauses.map(mapClause)
    };
    return {
      clause_type: {
        oneofKind: "composite",
        composite: compositeClause
      }
    };
  }
  throw new Error("Unknown clause type");
}
function mapWorldAddresses(addresses) {
  if (!addresses || addresses.length === 0) {
    return [];
  }
  return addresses.map((address) => hexToBuffer(addAddressPadding(address)));
}
function mapQuery(query) {
  const queryWithWorlds = query;
  const worldAddresses = queryWithWorlds.world_addresses ?? queryWithWorlds.worldAddresses;
  return {
    pagination: mapPagination(query.pagination),
    clause: query.clause ? mapClause(query.clause) : void 0,
    no_hashed_keys: query.no_hashed_keys,
    models: query.models,
    historical: query.historical,
    world_addresses: mapWorldAddresses(worldAddresses)
  };
}
function mapControllerQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    usernames: query.usernames,
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    attribute_filters: mapTokenAttributeFilters(query.attribute_filters),
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenAttributeFilters(filters) {
  if (!filters) {
    return [];
  }
  return filters.map((filter) => ({
    trait_name: filter.trait_name,
    trait_value: filter.trait_value
  }));
}
function mapTokenBalanceQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    account_addresses: query.account_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenContractQuery(query) {
  return {
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    contract_types: normalizeGrpcContractTypes(query.contract_types),
    pagination: mapPagination(query.pagination)
  };
}
function mapTokenTransferQuery(query) {
  return {
    account_addresses: query.account_addresses.map(hexToBuffer),
    contract_addresses: query.contract_addresses.map(hexToBuffer),
    token_ids: query.token_ids.map(hexToBuffer),
    pagination: mapPagination(query.pagination)
  };
}
function mapTransactionFilter(filter) {
  return {
    transaction_hashes: filter.transaction_hashes.map(hexToBuffer),
    caller_addresses: filter.caller_addresses.map(hexToBuffer),
    contract_addresses: filter.contract_addresses.map(hexToBuffer),
    entrypoints: filter.entrypoints,
    model_selectors: filter.model_selectors.map(hexToBuffer),
    from_block: filter.from_block ? BigInt(filter.from_block) : void 0,
    to_block: filter.to_block ? BigInt(filter.to_block) : void 0
  };
}
function mapTransactionQuery(query) {
  return {
    filter: query.filter ? mapTransactionFilter(query.filter) : void 0,
    pagination: mapPagination(query.pagination)
  };
}
function createRetrieveEntitiesRequest(query) {
  return {
    query: mapQuery(query)
  };
}
function createRetrieveEventMessagesRequest(query) {
  return {
    query: mapQuery(query)
  };
}
function createRetrieveTokensRequest(query) {
  return {
    query: mapTokenQuery(query)
  };
}
function createRetrieveTokenBalancesRequest(query) {
  return {
    query: mapTokenBalanceQuery(query)
  };
}
function createRetrieveTokenContractsRequest(query) {
  return {
    query: mapTokenContractQuery(query)
  };
}
function createRetrieveTokenTransfersRequest(query) {
  return {
    query: mapTokenTransferQuery(query)
  };
}
function createRetrieveControllersRequest(query) {
  return {
    query: mapControllerQuery(query)
  };
}
function createRetrieveTransactionsRequest(query) {
  return {
    query: mapTransactionQuery(query)
  };
}
function createRetrieveEventsRequest(query) {
  return {
    query: {
      keys: query.keys ? {
        keys: query.keys.keys.map(
          (k) => k ? hexToBuffer(k) : new Uint8Array()
        ),
        pattern_matching: query.keys.pattern_matching === "FixedLen" ? 0 /* FixedLen */ : 1 /* VariableLen */,
        models: query.keys.models || []
      } : void 0,
      pagination: query.pagination ? mapPagination(query.pagination) : void 0
    }
  };
}
function createRetrieveContractsRequest(query) {
  return {
    query: {
      contract_addresses: query.contract_addresses?.map(hexToBuffer) || [],
      contract_types: normalizeGrpcContractTypes(query.contract_types)
    }
  };
}
function mapAggregationQuery(query) {
  if (!query) {
    return void 0;
  }
  return {
    aggregator_ids: query.aggregator_ids ?? [],
    entity_ids: query.entity_ids ?? [],
    pagination: query.pagination ? mapPagination(query.pagination) : void 0
  };
}
function createRetrieveAggregationsRequest(query) {
  return {
    query: mapAggregationQuery(query)
  };
}
function mapActivityQuery(query) {
  if (!query) {
    return void 0;
  }
  const toOptionalBigInt = (value) => {
    if (value === void 0 || value === null) {
      return void 0;
    }
    return BigInt(value);
  };
  return {
    world_addresses: (query.world_addresses ?? []).map(hexToBuffer),
    namespaces: query.namespaces ?? [],
    caller_addresses: (query.caller_addresses ?? []).map(hexToBuffer),
    from_time: toOptionalBigInt(query.from_time),
    to_time: toOptionalBigInt(query.to_time),
    pagination: query.pagination ? mapPagination(query.pagination) : void 0
  };
}
function createRetrieveActivitiesRequest(query) {
  return {
    query: mapActivityQuery(query)
  };
}
function mapAchievementQuery(query) {
  if (!query) {
    return void 0;
  }
  return {
    world_addresses: (query.world_addresses ?? []).map(hexToBuffer),
    namespaces: query.namespaces ?? [],
    hidden: query.hidden,
    pagination: query.pagination ? mapPagination(query.pagination) : void 0
  };
}
function createRetrieveAchievementsRequest(query) {
  return {
    query: mapAchievementQuery(query)
  };
}
function mapPlayerAchievementQuery(query) {
  if (!query) {
    return void 0;
  }
  return {
    world_addresses: (query.world_addresses ?? []).map(hexToBuffer),
    namespaces: query.namespaces ?? [],
    player_addresses: (query.player_addresses ?? []).map(hexToBuffer),
    pagination: query.pagination ? mapPagination(query.pagination) : void 0
  };
}
function createRetrievePlayerAchievementsRequest(query) {
  return {
    query: mapPlayerAchievementQuery(query)
  };
}
function createSubscribeAchievementProgressionsRequest(filters) {
  return {
    world_addresses: (filters.worldAddresses ?? []).map(hexToBuffer),
    namespaces: filters.namespaces ?? [],
    player_addresses: (filters.playerAddresses ?? []).map(hexToBuffer),
    achievement_ids: filters.achievementIds ?? []
  };
}
function createUpdateAchievementProgressionsSubscriptionRequest(subscriptionId, filters) {
  return {
    subscription_id: subscriptionId,
    world_addresses: (filters.worldAddresses ?? []).map(hexToBuffer),
    namespaces: filters.namespaces ?? [],
    player_addresses: (filters.playerAddresses ?? []).map(hexToBuffer),
    achievement_ids: filters.achievementIds ?? []
  };
}
function createSearchRequest(query, limit) {
  const searchQuery = {
    query,
    limit: limit ?? 10
  };
  return {
    query: searchQuery
  };
}

// src/mappings/types.ts
var textDecoder = void 0;
function bufferToHex(buffer) {
  return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function toOptionalNumber(value) {
  return value === void 0 ? void 0 : Number(value);
}
function hexToBuffer2(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function parseTimestampToSeconds(value) {
  if (!value) {
    return 0;
  }
  const numeric = Number(value);
  if (!Number.isNaN(numeric)) {
    return numeric;
  }
  const parsed = Date.parse(value);
  if (!Number.isNaN(parsed)) {
    return Math.floor(parsed / 1e3);
  }
  return 0;
}
function mapCallType(callType) {
  switch (callType) {
    case 0 /* EXECUTE */:
      return "Execute";
    case 1 /* EXECUTE_FROM_OUTSIDE */:
      return "ExecuteFromOutside";
    default:
      return "Execute";
  }
}
function mapTransactionCall(call) {
  return {
    contract_address: bufferToHex(call.contract_address),
    entrypoint: call.entrypoint,
    calldata: call.calldata.map(bufferToHex),
    call_type: mapCallType(call.call_type),
    caller_address: bufferToHex(call.caller_address)
  };
}
function mapTransaction(tx) {
  return {
    transaction_hash: bufferToHex(tx.transaction_hash),
    sender_address: bufferToHex(tx.sender_address),
    calldata: tx.calldata.map(bufferToHex),
    max_fee: bufferToHex(tx.max_fee),
    signature: tx.signature.map(bufferToHex),
    nonce: bufferToHex(tx.nonce),
    block_number: Number(tx.block_number),
    transaction_type: tx.transaction_type,
    block_timestamp: Number(tx.block_timestamp),
    calls: tx.calls.map(mapTransactionCall),
    unique_models: tx.unique_models.map(bufferToHex)
  };
}
function mapTransactionsResponse(response) {
  return {
    items: response.transactions.map(mapTransaction),
    next_cursor: response.next_cursor || void 0
  };
}
function mapController(controller) {
  return {
    address: bufferToHex(controller.address),
    username: controller.username,
    deployed_at_timestamp: Number(controller.deployed_at_timestamp)
  };
}
function mapControllersResponse(response) {
  return {
    items: response.controllers.map(mapController),
    next_cursor: response.next_cursor || void 0
  };
}
function uint8ArrayToString(input) {
  if (textDecoder) {
    return textDecoder.decode(input);
  }
  textDecoder = new TextDecoder();
  return textDecoder.decode(input);
}
function parseJsonMetadata(input) {
  try {
    return JSON.parse(uint8ArrayToString(input));
  } catch (_err) {
    return uint8ArrayToString(input);
  }
}
function mapToken(token) {
  return {
    contract_address: bufferToHex(token.contract_address),
    token_id: token.token_id ? bufferToHex(token.token_id) : void 0,
    name: token.name,
    symbol: token.symbol,
    decimals: token.decimals,
    metadata: parseJsonMetadata(token.metadata),
    total_supply: token.total_supply ? bufferToHex(token.total_supply) : void 0
  };
}
function mapTokensResponse(response) {
  return {
    items: response.tokens.map(mapToken),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenBalance(balance) {
  return {
    balance: bufferToHex(balance.balance),
    account_address: bufferToHex(balance.account_address),
    contract_address: bufferToHex(balance.contract_address),
    token_id: balance.token_id ? bufferToHex(balance.token_id) : void 0
  };
}
function mapTokenBalancesResponse(response) {
  return {
    items: response.balances.map(mapTokenBalance),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenContract(collection) {
  return {
    contract_address: bufferToHex(collection.contract_address),
    name: collection.name,
    symbol: collection.symbol,
    decimals: collection.decimals,
    total_supply: collection.total_supply ? bufferToHex(collection.total_supply) : void 0,
    metadata: parseJsonMetadata(collection.metadata),
    traits: JSON.parse(collection.traits),
    token_metadata: parseJsonMetadata(collection.token_metadata),
    contract_type: collection.contract_type
  };
}
function mapTokenContractsResponse(response) {
  return {
    items: response.token_contracts.map(mapTokenContract),
    next_cursor: response.next_cursor || void 0
  };
}
function mapTokenTransfer(transfer) {
  return {
    id: transfer.id,
    contract_address: bufferToHex(transfer.contract_address),
    from_address: bufferToHex(transfer.from_address),
    to_address: bufferToHex(transfer.to_address),
    amount: bufferToHex(transfer.amount),
    token_id: transfer.token_id ? bufferToHex(transfer.token_id) : void 0,
    executed_at: Number(transfer.executed_at),
    event_id: transfer.event_id || void 0
  };
}
function mapTokenTransfersResponse(response) {
  return {
    items: response.transfers.map(mapTokenTransfer),
    next_cursor: response.next_cursor || void 0
  };
}
function mapPrimitive(primitive) {
  if (!primitive.primitive_type) return null;
  switch (primitive.primitive_type.oneofKind) {
    case "i8":
      return primitive.primitive_type.i8;
    case "i16":
      return primitive.primitive_type.i16;
    case "i32":
      return primitive.primitive_type.i32;
    case "i64":
      return Number(primitive.primitive_type.i64);
    case "i128":
      return bufferToHex(primitive.primitive_type.i128);
    case "u8":
      return primitive.primitive_type.u8;
    case "u16":
      return primitive.primitive_type.u16;
    case "u32":
      return primitive.primitive_type.u32;
    case "u64":
      return Number(primitive.primitive_type.u64);
    case "u128":
      return bufferToHex(primitive.primitive_type.u128);
    case "u256":
      return bufferToHex(primitive.primitive_type.u256);
    case "bool":
      return primitive.primitive_type.bool;
    case "felt252":
      return bufferToHex(primitive.primitive_type.felt252);
    case "class_hash":
      return bufferToHex(primitive.primitive_type.class_hash);
    case "contract_address":
      return bufferToHex(primitive.primitive_type.contract_address);
    case "eth_address":
      return bufferToHex(primitive.primitive_type.eth_address);
    default:
      return null;
  }
}
function getPrimitiveTypeName(primitive) {
  if (!primitive.primitive_type) return "";
  return primitive.primitive_type.oneofKind || "";
}
function mapTy(ty, isKey = false) {
  if (!ty.ty_type) {
    return {
      type: "primitive",
      type_name: "",
      value: null,
      key: isKey
    };
  }
  switch (ty.ty_type.oneofKind) {
    case "primitive": {
      return {
        type: "primitive",
        type_name: getPrimitiveTypeName(ty.ty_type.primitive),
        value: mapPrimitive(ty.ty_type.primitive),
        key: isKey
      };
    }
    case "struct": {
      const struct = ty.ty_type.struct;
      const structValue = {};
      for (const member of struct.children) {
        if (member.ty) {
          structValue[member.name] = mapTy(member.ty, member.key);
        }
      }
      return {
        type: "struct",
        type_name: struct.name,
        value: structValue,
        key: isKey
      };
    }
    case "enum": {
      const enumType = ty.ty_type.enum;
      const selectedOption = enumType.options[enumType.option];
      return {
        type: "enum",
        type_name: enumType.name,
        value: selectedOption && selectedOption.ty ? {
          option: selectedOption.name,
          value: mapTy(selectedOption.ty)
        } : null,
        key: isKey
      };
    }
    case "array": {
      const array = ty.ty_type.array;
      return {
        type: "array",
        type_name: "array",
        value: array.children.map((child) => mapTy(child)),
        key: isKey
      };
    }
    case "tuple": {
      const tuple = ty.ty_type.tuple;
      return {
        type: "tuple",
        type_name: "tuple",
        value: tuple.children.map((child) => mapTy(child)),
        key: isKey
      };
    }
    case "bytearray": {
      return {
        type: "bytearray",
        type_name: "bytearray",
        value: ty.ty_type.bytearray,
        key: isKey
      };
    }
    default:
      return {
        type: "primitive",
        type_name: "",
        value: null,
        key: isKey
      };
  }
}
function mapModel(model) {
  const mappedModel = {};
  if (model && Array.isArray(model)) {
    for (const member of model) {
      if (member.ty) {
        mappedModel[member.name] = mapTy(member.ty, member.key);
      }
    }
  }
  return mappedModel;
}
function mapEntity(entity) {
  const models = {};
  for (const model of entity.models) {
    models[model.name] = mapModel(model.children);
  }
  return {
    hashed_keys: bufferToHex(entity.hashed_keys),
    models,
    created_at: Number(entity.created_at),
    updated_at: Number(entity.updated_at),
    executed_at: Number(entity.executed_at),
    world_address: bufferToHex(entity.world_address)
  };
}
function mapEntitiesResponse(response) {
  return {
    items: response.entities.map(mapEntity),
    next_cursor: response.next_cursor || void 0
  };
}
function mapMessage(message) {
  return {
    message: message.message,
    signature: message.signature.map(hexToBuffer2)
  };
}
function mapEvent(event) {
  return {
    keys: event.keys.map(bufferToHex),
    data: event.data.map(bufferToHex),
    transaction_hash: bufferToHex(event.transaction_hash)
  };
}
function mapEventsResponse(response) {
  return {
    items: response.events.map(mapEvent),
    next_cursor: response.next_cursor || void 0
  };
}
function mapContract(contract) {
  return {
    contract_address: bufferToHex(contract.contract_address),
    contract_type: contract.contract_type,
    head: contract.head ? Number(contract.head) : void 0,
    tps: contract.tps ? Number(contract.tps) : void 0,
    last_block_timestamp: contract.last_block_timestamp ? Number(contract.last_block_timestamp) : void 0,
    last_pending_block_tx: contract.last_pending_block_tx ? bufferToHex(contract.last_pending_block_tx) : void 0,
    updated_at: Number(contract.updated_at),
    created_at: Number(contract.created_at)
  };
}
function mapContractsResponse(response) {
  return {
    items: response.contracts.map(mapContract)
  };
}
function mapWorldModel(model) {
  return {
    selector: bufferToHex(model.selector),
    namespace: model.namespace,
    name: model.name,
    packed_size: model.packed_size,
    unpacked_size: model.unpacked_size,
    class_hash: bufferToHex(model.class_hash),
    layout: bufferToHex(model.layout),
    schema: bufferToHex(model.schema),
    contract_address: bufferToHex(model.contract_address),
    use_legacy_store: model.use_legacy_store,
    world_address: bufferToHex(model.world_address)
  };
}
function mapWorld(world) {
  return {
    world_address: world.world_address,
    models: world.models.map(mapWorldModel)
  };
}
function mapWorldMetadataResponse(response, preferredWorldAddress) {
  if (!response.worlds || response.worlds.length === 0) {
    return null;
  }
  const normalizedPreferred = preferredWorldAddress ? preferredWorldAddress.toLowerCase() : void 0;
  const world = (normalizedPreferred ? response.worlds.find(
    (candidate) => candidate.world_address.toLowerCase() === normalizedPreferred
  ) : void 0) ?? response.worlds[0];
  return mapWorld(world);
}
function mapWorldsResponse(response) {
  if (!response.worlds) {
    return [];
  }
  return response.worlds.map(mapWorld);
}
function mapAggregationEntry(entry) {
  return {
    id: entry.id,
    aggregatorId: entry.aggregator_id,
    entityId: entry.entity_id,
    value: bufferToHex(entry.value),
    displayValue: entry.display_value,
    position: Number(entry.position),
    modelId: entry.model_id,
    createdAt: parseTimestampToSeconds(entry.created_at),
    updatedAt: parseTimestampToSeconds(entry.updated_at)
  };
}
function mapAggregationsResponse(response) {
  const nextCursor = response.next_cursor || void 0;
  return {
    items: response.entries.map(mapAggregationEntry),
    nextCursor,
    next_cursor: nextCursor
  };
}
function mapActivity(activity) {
  return {
    id: activity.id,
    worldAddress: bufferToHex(activity.world_address),
    namespace: activity.namespace,
    callerAddress: bufferToHex(activity.caller_address),
    sessionStart: Number(activity.session_start),
    sessionEnd: Number(activity.session_end),
    actionCount: activity.action_count,
    actions: activity.actions,
    updatedAt: Number(activity.updated_at)
  };
}
function mapActivitiesResponse(response) {
  const nextCursor = response.next_cursor || void 0;
  return {
    items: response.activities.map(mapActivity),
    nextCursor,
    next_cursor: nextCursor
  };
}
function mapAchievementTask(task) {
  return {
    task_id: task.task_id,
    description: task.description,
    total: task.total,
    total_completions: task.total_completions,
    completion_rate: task.completion_rate,
    created_at: Number(task.created_at)
  };
}
function mapTaskProgress(task) {
  return {
    task_id: task.task_id,
    count: task.count,
    completed: task.completed
  };
}
function mapPlayerAchievementStats(stats) {
  return {
    total_points: stats.total_points,
    completed_achievements: stats.completed_achievements,
    total_achievements: stats.total_achievements,
    completion_percentage: stats.completion_percentage,
    last_achievement_at: toOptionalNumber(stats.last_achievement_at),
    created_at: Number(stats.created_at),
    updated_at: Number(stats.updated_at)
  };
}
function mapAchievement(achievement) {
  if (!achievement) {
    return {
      id: "",
      world_address: "0x0",
      namespace: "",
      entity_id: "",
      hidden: false,
      index: 0,
      points: 0,
      start: "",
      end: "",
      group: "",
      icon: "",
      title: "",
      description: "",
      tasks: [],
      data: "",
      total_completions: 0,
      completion_rate: 0,
      created_at: 0,
      updated_at: 0
    };
  }
  return {
    id: achievement.id,
    world_address: bufferToHex(achievement.world_address),
    namespace: achievement.namespace,
    entity_id: achievement.entity_id,
    hidden: achievement.hidden,
    index: achievement.index,
    points: achievement.points,
    start: achievement.start,
    end: achievement.end,
    group: achievement.group,
    icon: achievement.icon,
    title: achievement.title,
    description: achievement.description,
    tasks: achievement.tasks.map(mapAchievementTask),
    data: achievement.data ?? "",
    total_completions: achievement.total_completions,
    completion_rate: achievement.completion_rate,
    created_at: Number(achievement.created_at),
    updated_at: Number(achievement.updated_at)
  };
}
function mapPlayerAchievementProgress(progress) {
  return {
    achievement: mapAchievement(progress.achievement),
    task_progress: progress.taskProgress.map(mapTaskProgress),
    completed: progress.completed,
    progress_percentage: progress.progress_percentage
  };
}
function mapPlayerAchievementEntry(entry) {
  const stats = entry.stats ? mapPlayerAchievementStats(entry.stats) : {
    total_points: 0,
    completed_achievements: 0,
    total_achievements: 0,
    completion_percentage: 0,
    last_achievement_at: void 0,
    created_at: 0,
    updated_at: 0
  };
  return {
    player_address: bufferToHex(entry.player_address),
    stats,
    achievements: entry.achievements.map(mapPlayerAchievementProgress)
  };
}
function mapAchievementsResponse(response) {
  const nextCursor = response.next_cursor || void 0;
  return {
    items: response.achievements.map(mapAchievement),
    nextCursor,
    next_cursor: nextCursor
  };
}
function mapPlayerAchievementsResponse(response) {
  const nextCursor = response.next_cursor || void 0;
  return {
    items: response.players.map(mapPlayerAchievementEntry),
    nextCursor,
    next_cursor: nextCursor
  };
}
function mapAchievementProgression(progression) {
  if (!progression) {
    return {
      id: "",
      achievementId: "",
      taskId: "",
      worldAddress: "0x0",
      namespace: "",
      playerId: "0x0",
      count: 0,
      completed: false,
      completedAt: void 0,
      createdAt: 0,
      updatedAt: 0
    };
  }
  return {
    id: progression.id,
    achievementId: progression.achievement_id,
    taskId: progression.task_id,
    worldAddress: bufferToHex(progression.world_address),
    namespace: progression.namespace,
    playerId: bufferToHex(progression.player_id),
    count: progression.count,
    completed: progression.completed,
    completedAt: toOptionalNumber(progression.completed_at),
    createdAt: Number(progression.created_at),
    updatedAt: Number(progression.updated_at)
  };
}
function mapSqlValue(value) {
  if (!value.value_type || value.value_type.oneofKind === void 0) {
    return null;
  }
  switch (value.value_type.oneofKind) {
    case "text":
      return value.value_type.text;
    case "integer":
      return value.value_type.integer;
    case "real":
      return value.value_type.real;
    case "blob":
      return bufferToHex(value.value_type.blob);
    case "null":
      return null;
    default:
      return null;
  }
}
function mapSqlQueryResponse(response) {
  return response.rows.map((row) => {
    const mapped = {};
    for (const [column, value] of Object.entries(row.fields)) {
      mapped[column] = mapSqlValue(value);
    }
    return mapped;
  });
}
function mapSearchResponse(response) {
  if (!response.response) {
    return {
      total: 0,
      results: []
    };
  }
  return {
    total: response.response.total,
    results: response.response.results
  };
}

// src/mappings/effect-schema/transformers.ts
import { Schema as Schema4 } from "effect";

// src/mappings/effect-schema/entity-schemas.ts
import { Schema as Schema2 } from "effect";

// src/mappings/effect-schema/base-schemas.ts
import { Schema } from "effect";
var HexString = Schema.String.pipe(
  Schema.pattern(/^0x[0-9a-fA-F]*$/, {
    message: () => "Invalid hex string format"
  })
);
var BufferToHex = Schema.transform(
  Schema.Uint8ArrayFromSelf,
  HexString,
  {
    decode: (buffer) => {
      return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
    },
    encode: (hex) => {
      const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
      }
      return bytes;
    }
  }
);
var OptionalBufferToHex = Schema.optional(BufferToHex);
var BufferArrayToHexArray = Schema.transform(
  Schema.Array(Schema.Uint8ArrayFromSelf),
  Schema.Array(HexString),
  {
    decode: (buffers) => buffers.map(
      (buffer) => "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("")
    ),
    encode: (hexStrings) => hexStrings.map((hex) => {
      const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
      }
      return bytes;
    })
  }
);
var BigIntToNumber = Schema.transform(
  Schema.BigIntFromSelf,
  Schema.Number,
  {
    decode: (bigint) => Number(bigint),
    encode: (number) => BigInt(number)
  }
);
var OptionalString = Schema.optional(Schema.String);
var OptionalNumber = Schema.optional(Schema.Number);
var textDecoder2 = void 0;
var Uint8ArrayToString = Schema.transform(
  Schema.Uint8ArrayFromSelf,
  Schema.String,
  {
    decode: (input) => {
      if (!textDecoder2) {
        textDecoder2 = new TextDecoder();
      }
      return textDecoder2.decode(input);
    },
    encode: (str) => new TextEncoder().encode(str)
  }
);
var JsonMetadata = Schema.transform(
  Schema.Uint8ArrayFromSelf,
  Schema.Unknown,
  {
    decode: (input) => {
      if (!textDecoder2) {
        textDecoder2 = new TextDecoder();
      }
      const str = textDecoder2.decode(input);
      try {
        return JSON.parse(str);
      } catch (_err) {
        return str;
      }
    },
    encode: (value) => {
      const str = typeof value === "string" ? value : JSON.stringify(value);
      return new TextEncoder().encode(str);
    }
  }
);

// src/mappings/effect-schema/entity-schemas.ts
var CallTypeSchema = Schema2.transform(
  Schema2.Enums({
    EXECUTE: 0,
    EXECUTE_FROM_OUTSIDE: 1
  }),
  Schema2.Literal("Execute", "ExecuteFromOutside"),
  {
    decode: (grpcCallType) => {
      switch (grpcCallType) {
        case 0:
          return "Execute";
        case 1:
          return "ExecuteFromOutside";
        default:
          return "Execute";
      }
    },
    encode: (toriiCallType) => {
      switch (toriiCallType) {
        case "Execute":
          return 0;
        case "ExecuteFromOutside":
          return 1;
        default:
          return 0;
      }
    }
  }
);
var TransactionCallSchema = Schema2.transform(
  Schema2.Struct({
    contract_address: Schema2.Uint8ArrayFromSelf,
    entrypoint: Schema2.String,
    calldata: Schema2.Array(Schema2.Uint8ArrayFromSelf),
    call_type: Schema2.Enums({
      EXECUTE: 0,
      EXECUTE_FROM_OUTSIDE: 1
    }),
    caller_address: Schema2.Uint8ArrayFromSelf
  }),
  Schema2.Struct({
    contract_address: BufferToHex,
    entrypoint: Schema2.String,
    calldata: BufferArrayToHexArray,
    call_type: CallTypeSchema,
    caller_address: BufferToHex
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      entrypoint: grpc.entrypoint,
      calldata: grpc.calldata,
      call_type: grpc.call_type,
      caller_address: grpc.caller_address
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      entrypoint: torii.entrypoint,
      calldata: torii.calldata,
      call_type: torii.call_type,
      caller_address: torii.caller_address
    })
  }
);
var TransactionSchema = Schema2.transform(
  Schema2.Struct({
    transaction_hash: Schema2.Uint8ArrayFromSelf,
    sender_address: Schema2.Uint8ArrayFromSelf,
    calldata: Schema2.Array(Schema2.Uint8ArrayFromSelf),
    max_fee: Schema2.Uint8ArrayFromSelf,
    signature: Schema2.Array(Schema2.Uint8ArrayFromSelf),
    nonce: Schema2.Uint8ArrayFromSelf,
    block_number: Schema2.BigIntFromSelf,
    block_timestamp: Schema2.BigIntFromSelf,
    transaction_type: Schema2.String,
    calls: Schema2.Array(TransactionCallSchema),
    unique_models: Schema2.Array(Schema2.Uint8ArrayFromSelf)
  }),
  Schema2.Struct({
    transaction_hash: BufferToHex,
    sender_address: BufferToHex,
    calldata: BufferArrayToHexArray,
    max_fee: BufferToHex,
    signature: BufferArrayToHexArray,
    nonce: BufferToHex,
    block_number: BigIntToNumber,
    block_timestamp: BigIntToNumber,
    transaction_type: Schema2.String,
    calls: Schema2.Array(TransactionCallSchema),
    unique_models: BufferArrayToHexArray
  }),
  {
    decode: (grpc) => ({
      transaction_hash: grpc.transaction_hash,
      sender_address: grpc.sender_address,
      calldata: grpc.calldata,
      max_fee: grpc.max_fee,
      signature: grpc.signature,
      nonce: grpc.nonce,
      block_number: grpc.block_number,
      block_timestamp: grpc.block_timestamp,
      transaction_type: grpc.transaction_type,
      calls: grpc.calls,
      unique_models: grpc.unique_models
    }),
    encode: (torii) => ({
      transaction_hash: torii.transaction_hash,
      sender_address: torii.sender_address,
      calldata: torii.calldata,
      max_fee: torii.max_fee,
      signature: torii.signature,
      nonce: torii.nonce,
      block_number: BigInt(torii.block_number),
      block_timestamp: BigInt(torii.block_timestamp),
      transaction_type: torii.transaction_type,
      calls: torii.calls,
      unique_models: torii.unique_models
    })
  }
);
var ControllerSchema = Schema2.transform(
  Schema2.Struct({
    address: Schema2.Uint8ArrayFromSelf,
    username: Schema2.String,
    deployed_at_timestamp: Schema2.BigIntFromSelf
  }),
  Schema2.Struct({
    address: BufferToHex,
    username: Schema2.String,
    deployed_at_timestamp: BigIntToNumber
  }),
  {
    decode: (grpc) => ({
      address: grpc.address,
      username: grpc.username,
      deployed_at_timestamp: grpc.deployed_at_timestamp
    }),
    encode: (torii) => ({
      address: torii.address,
      username: torii.username,
      deployed_at_timestamp: BigInt(torii.deployed_at_timestamp)
    })
  }
);
var TokenSchema = Schema2.transform(
  Schema2.Struct({
    contract_address: Schema2.Uint8ArrayFromSelf,
    token_id: Schema2.optional(Schema2.Uint8ArrayFromSelf),
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    metadata: Schema2.Uint8ArrayFromSelf
  }),
  Schema2.Struct({
    contract_address: BufferToHex,
    token_id: OptionalBufferToHex,
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    metadata: JsonMetadata
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      token_id: grpc.token_id,
      name: grpc.name,
      symbol: grpc.symbol,
      decimals: grpc.decimals,
      metadata: grpc.metadata
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      token_id: torii.token_id,
      name: torii.name,
      symbol: torii.symbol,
      decimals: torii.decimals,
      metadata: torii.metadata
    })
  }
);
var TokenBalanceSchema = Schema2.transform(
  Schema2.Struct({
    balance: Schema2.Uint8ArrayFromSelf,
    account_address: Schema2.Uint8ArrayFromSelf,
    contract_address: Schema2.Uint8ArrayFromSelf,
    token_id: Schema2.optional(Schema2.Uint8ArrayFromSelf)
  }),
  Schema2.Struct({
    balance: BufferToHex,
    account_address: BufferToHex,
    contract_address: BufferToHex,
    token_id: OptionalBufferToHex
  }),
  {
    decode: (grpc) => ({
      balance: grpc.balance,
      account_address: grpc.account_address,
      contract_address: grpc.contract_address,
      token_id: grpc.token_id
    }),
    encode: (torii) => ({
      balance: torii.balance,
      account_address: torii.account_address,
      contract_address: torii.contract_address,
      token_id: torii.token_id
    })
  }
);
var TokenContractSchema = Schema2.transform(
  Schema2.Struct({
    contract_address: Schema2.Uint8ArrayFromSelf,
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    count: Schema2.BigIntFromSelf,
    metadata: Schema2.Uint8ArrayFromSelf
  }),
  Schema2.Struct({
    contract_address: BufferToHex,
    name: Schema2.String,
    symbol: Schema2.String,
    decimals: Schema2.Number,
    count: Schema2.Number,
    metadata: JsonMetadata
  }),
  {
    decode: (grpc) => ({
      contract_address: grpc.contract_address,
      name: grpc.name,
      symbol: grpc.symbol,
      decimals: grpc.decimals,
      count: grpc.count,
      metadata: grpc.metadata
    }),
    encode: (torii) => ({
      contract_address: torii.contract_address,
      name: torii.name,
      symbol: torii.symbol,
      decimals: torii.decimals,
      count: BigInt(torii.count),
      metadata: torii.metadata
    })
  }
);
var TokenTransferSchema = Schema2.transform(
  Schema2.Struct({
    id: Schema2.String,
    contract_address: Schema2.Uint8ArrayFromSelf,
    from_address: Schema2.Uint8ArrayFromSelf,
    to_address: Schema2.Uint8ArrayFromSelf,
    amount: Schema2.Uint8ArrayFromSelf,
    token_id: Schema2.optional(Schema2.Uint8ArrayFromSelf),
    executed_at: Schema2.BigIntFromSelf,
    event_id: Schema2.optional(Schema2.String)
  }),
  Schema2.Struct({
    id: Schema2.String,
    contract_address: BufferToHex,
    from_address: BufferToHex,
    to_address: BufferToHex,
    amount: BufferToHex,
    token_id: OptionalBufferToHex,
    executed_at: BigIntToNumber,
    event_id: OptionalString
  }),
  {
    decode: (grpc) => ({
      id: grpc.id,
      contract_address: grpc.contract_address,
      from_address: grpc.from_address,
      to_address: grpc.to_address,
      amount: grpc.amount,
      token_id: grpc.token_id,
      executed_at: grpc.executed_at,
      event_id: grpc.event_id
    }),
    encode: (torii) => ({
      id: torii.id,
      contract_address: torii.contract_address,
      from_address: torii.from_address,
      to_address: torii.to_address,
      amount: torii.amount,
      token_id: torii.token_id,
      executed_at: BigInt(torii.executed_at),
      event_id: torii.event_id
    })
  }
);
var TransactionsResponseSchema = Schema2.transform(
  Schema2.Struct({
    transactions: Schema2.Array(TransactionSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TransactionSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.transactions,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      transactions: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var ControllersResponseSchema = Schema2.transform(
  Schema2.Struct({
    controllers: Schema2.Array(ControllerSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(ControllerSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.controllers,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      controllers: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokensResponseSchema = Schema2.transform(
  Schema2.Struct({
    tokens: Schema2.Array(TokenSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.tokens,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      tokens: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenBalancesResponseSchema = Schema2.transform(
  Schema2.Struct({
    balances: Schema2.Array(TokenBalanceSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenBalanceSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.balances,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      balances: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenTransfersResponseSchema = Schema2.transform(
  Schema2.Struct({
    transfers: Schema2.Array(TokenTransferSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenTransferSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.transfers,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      transfers: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var TokenContractsResponseSchema = Schema2.transform(
  Schema2.Struct({
    tokens: Schema2.Array(TokenContractSchema),
    next_cursor: OptionalString
  }),
  Schema2.Struct({
    items: Schema2.Array(TokenContractSchema),
    next_cursor: Schema2.optional(Schema2.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.tokens,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      tokens: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);

// src/mappings/effect-schema/model-schemas.ts
import { Schema as Schema3 } from "effect";
var parseTimestampString = (value) => {
  if (value === null || value === void 0 || value === "") {
    return 0;
  }
  const numeric = Number(value);
  if (!Number.isNaN(numeric)) {
    return numeric;
  }
  const parsed = Date.parse(String(value));
  return Number.isNaN(parsed) ? 0 : Math.floor(parsed / 1e3);
};
var PrimitiveSchema = Schema3.transform(
  Schema3.Struct({
    primitive_type: Schema3.Union(
      Schema3.Struct({
        oneofKind: Schema3.Literal("i8"),
        i8: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i16"),
        i16: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i32"),
        i32: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i64"),
        i64: Schema3.BigIntFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("i128"),
        i128: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u8"),
        u8: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u16"),
        u16: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u32"),
        u32: Schema3.Number
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u64"),
        u64: Schema3.BigIntFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u128"),
        u128: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("u256"),
        u256: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("bool"),
        bool: Schema3.Boolean
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("felt252"),
        felt252: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("class_hash"),
        class_hash: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("contract_address"),
        contract_address: Schema3.Uint8ArrayFromSelf
      }),
      Schema3.Struct({
        oneofKind: Schema3.Literal("eth_address"),
        eth_address: Schema3.Uint8ArrayFromSelf
      })
    ).pipe(Schema3.optional)
  }),
  Schema3.Unknown,
  {
    decode: (primitive) => {
      if (!primitive.primitive_type) return null;
      switch (primitive.primitive_type.oneofKind) {
        case "i8":
          return primitive.primitive_type.i8;
        case "i16":
          return primitive.primitive_type.i16;
        case "i32":
          return primitive.primitive_type.i32;
        case "i64":
          return Number(primitive.primitive_type.i64);
        case "i128":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.i128
          );
        case "u8":
          return primitive.primitive_type.u8;
        case "u16":
          return primitive.primitive_type.u16;
        case "u32":
          return primitive.primitive_type.u32;
        case "u64":
          return Number(primitive.primitive_type.u64);
        case "u128":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.u128
          );
        case "u256":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.u256
          );
        case "bool":
          return primitive.primitive_type.bool;
        case "felt252":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.felt252
          );
        case "class_hash":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.class_hash
          );
        case "contract_address":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.contract_address
          );
        case "eth_address":
          return BufferToHex.pipe(Schema3.decodeSync)(
            primitive.primitive_type.eth_address
          );
        default:
          return null;
      }
    },
    encode: (value) => {
      throw new Error("Encoding not implemented for PrimitiveSchema");
    }
  }
);
var TySchema = Schema3.suspend(
  () => Schema3.transform(
    Schema3.Struct({
      ty_type: Schema3.Union(
        Schema3.Struct({
          oneofKind: Schema3.Literal("primitive"),
          primitive: PrimitiveSchema
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("struct"),
          struct: Schema3.Struct({
            name: Schema3.String,
            children: Schema3.Array(MemberSchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("enum"),
          enum: Schema3.Struct({
            name: Schema3.String,
            option: Schema3.Number,
            options: Schema3.Array(MemberSchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("array"),
          array: Schema3.Struct({
            children: Schema3.Array(TySchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("tuple"),
          tuple: Schema3.Struct({
            children: Schema3.Array(TySchema)
          })
        }),
        Schema3.Struct({
          oneofKind: Schema3.Literal("bytearray"),
          bytearray: Schema3.String
        })
      ).pipe(Schema3.optional)
    }),
    Schema3.Struct({
      type: Schema3.String,
      type_name: Schema3.String,
      value: Schema3.Unknown,
      key: Schema3.Boolean
    }),
    {
      decode: (ty, isKey = false) => {
        if (!ty.ty_type) {
          return {
            type: "primitive",
            type_name: "",
            value: null,
            key: isKey
          };
        }
        switch (ty.ty_type.oneofKind) {
          case "primitive": {
            const primitiveValue = PrimitiveSchema.pipe(
              Schema3.decodeSync
            )(ty.ty_type.primitive);
            return {
              type: "primitive",
              type_name: ty.ty_type.primitive.primitive_type?.oneofKind || "",
              value: primitiveValue,
              key: isKey
            };
          }
          case "struct": {
            const struct = ty.ty_type.struct;
            const structValue = {};
            for (const member of struct.children) {
              if (member.ty) {
                structValue[member.name] = TySchema.pipe(
                  Schema3.decodeSync
                )(member.ty);
              }
            }
            return {
              type: "struct",
              type_name: struct.name,
              value: structValue,
              key: isKey
            };
          }
          case "enum": {
            const enumType = ty.ty_type.enum;
            const selectedOption = enumType.options[enumType.option];
            return {
              type: "enum",
              type_name: enumType.name,
              value: selectedOption && selectedOption.ty ? {
                option: selectedOption.name,
                value: TySchema.pipe(
                  Schema3.decodeSync
                )(selectedOption.ty)
              } : null,
              key: isKey
            };
          }
          case "array": {
            const array = ty.ty_type.array;
            return {
              type: "array",
              type_name: "array",
              value: array.children.map(
                (child) => TySchema.pipe(Schema3.decodeSync)(child)
              ),
              key: isKey
            };
          }
          case "tuple": {
            const tuple = ty.ty_type.tuple;
            return {
              type: "tuple",
              type_name: "tuple",
              value: tuple.children.map(
                (child) => TySchema.pipe(Schema3.decodeSync)(child)
              ),
              key: isKey
            };
          }
          case "bytearray": {
            return {
              type: "bytearray",
              type_name: "bytearray",
              value: ty.ty_type.bytearray,
              key: isKey
            };
          }
          default:
            return {
              type: "primitive",
              type_name: "",
              value: null,
              key: isKey
            };
        }
      },
      encode: (torii) => {
        throw new Error("Encoding not implemented for TySchema");
      }
    }
  )
);
var MemberSchema = Schema3.suspend(
  () => Schema3.Struct({
    name: Schema3.String,
    ty: Schema3.optional(TySchema),
    key: Schema3.Boolean
  })
);
var ModelSchema = Schema3.transform(
  Schema3.Array(MemberSchema),
  Schema3.Record({ key: Schema3.String, value: TySchema }),
  {
    decode: (members) => {
      const model = {};
      if (members && Array.isArray(members)) {
        for (const member of members) {
          if (member.ty) {
            const ty = TySchema.pipe(Schema3.decodeSync)(member.ty);
            model[member.name] = { ...ty, key: member.key };
          }
        }
      }
      return model;
    },
    encode: (model) => {
      throw new Error("Encoding not implemented for ModelSchema");
    }
  }
);
var EntitySchema = Schema3.transform(
  Schema3.Struct({
    hashed_keys: Schema3.Uint8ArrayFromSelf,
    created_at: Schema3.BigIntFromSelf,
    updated_at: Schema3.BigIntFromSelf,
    executed_at: Schema3.BigIntFromSelf,
    world_address: Schema3.Uint8ArrayFromSelf,
    models: Schema3.Array(
      Schema3.Struct({
        name: Schema3.String,
        children: Schema3.Array(MemberSchema)
      })
    )
  }),
  Schema3.Struct({
    hashed_keys: BufferToHex,
    created_at: BigIntToNumber,
    updated_at: BigIntToNumber,
    executed_at: BigIntToNumber,
    world_address: BufferToHex,
    models: Schema3.Record({ key: Schema3.String, value: ModelSchema })
  }),
  {
    decode: (grpc) => {
      const models = {};
      for (const model of grpc.models) {
        models[model.name] = ModelSchema.pipe(Schema3.decodeSync)(
          model.children
        );
      }
      return {
        hashed_keys: BufferToHex.pipe(Schema3.decodeSync)(
          grpc.hashed_keys
        ),
        created_at: parseTimestampString(grpc.created_at),
        updated_at: parseTimestampString(grpc.updated_at),
        executed_at: parseTimestampString(grpc.executed_at),
        world_address: BufferToHex.pipe(Schema3.decodeSync)(
          grpc.world_address
        ),
        models
      };
    },
    encode: (torii) => {
      throw new Error("Encoding not implemented for EntitySchema");
    }
  }
);
var EntitiesResponseSchema = Schema3.transform(
  Schema3.Struct({
    entities: Schema3.Array(EntitySchema),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  Schema3.Struct({
    items: Schema3.Array(EntitySchema),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.entities,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      entities: torii.items,
      next_cursor: torii.next_cursor
    })
  }
);
var AggregationEntrySchema = Schema3.transform(
  Schema3.Struct({
    id: Schema3.String,
    aggregator_id: Schema3.String,
    entity_id: Schema3.String,
    value: Schema3.Uint8ArrayFromSelf,
    display_value: Schema3.String,
    position: Schema3.BigIntFromSelf,
    model_id: Schema3.String,
    created_at: Schema3.String,
    updated_at: Schema3.String
  }),
  Schema3.Struct({
    id: Schema3.String,
    aggregatorId: Schema3.String,
    entityId: Schema3.String,
    value: Schema3.String,
    displayValue: Schema3.String,
    position: Schema3.Number,
    modelId: Schema3.String,
    createdAt: Schema3.Number,
    updatedAt: Schema3.Number
  }),
  {
    decode: (grpc) => ({
      id: grpc.id,
      aggregatorId: grpc.aggregator_id,
      entityId: grpc.entity_id,
      value: BufferToHex.pipe(Schema3.decodeSync)(grpc.value),
      displayValue: grpc.display_value,
      position: Number(grpc.position),
      modelId: grpc.model_id,
      createdAt: parseTimestampString(grpc.created_at),
      updatedAt: parseTimestampString(grpc.updated_at)
    }),
    encode: () => {
      throw new Error(
        "Encoding not implemented for AggregationEntrySchema"
      );
    }
  }
);
var AggregationsResponseSchema = Schema3.transform(
  Schema3.Struct({
    entries: Schema3.Array(AggregationEntrySchema),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  Schema3.Struct({
    items: Schema3.Array(AggregationEntrySchema),
    nextCursor: Schema3.optional(Schema3.String),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.entries,
      nextCursor: grpc.next_cursor,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      entries: torii.items,
      next_cursor: torii.nextCursor
    })
  }
);
var ActivitySchema = Schema3.transform(
  Schema3.Struct({
    id: Schema3.String,
    world_address: Schema3.Uint8ArrayFromSelf,
    namespace: Schema3.String,
    caller_address: Schema3.Uint8ArrayFromSelf,
    session_start: Schema3.BigIntFromSelf,
    session_end: Schema3.BigIntFromSelf,
    action_count: Schema3.Number,
    actions: Schema3.Record({
      key: Schema3.String,
      value: Schema3.Number
    }),
    updated_at: Schema3.BigIntFromSelf
  }),
  Schema3.Struct({
    id: Schema3.String,
    worldAddress: Schema3.String,
    namespace: Schema3.String,
    callerAddress: Schema3.String,
    sessionStart: Schema3.Number,
    sessionEnd: Schema3.Number,
    actionCount: Schema3.Number,
    actions: Schema3.Record({
      key: Schema3.String,
      value: Schema3.Number
    }),
    updatedAt: Schema3.Number
  }),
  {
    decode: (grpc) => ({
      id: grpc.id,
      worldAddress: BufferToHex.pipe(Schema3.decodeSync)(
        grpc.world_address
      ),
      namespace: grpc.namespace,
      callerAddress: BufferToHex.pipe(Schema3.decodeSync)(
        grpc.caller_address
      ),
      sessionStart: Number(grpc.session_start),
      sessionEnd: Number(grpc.session_end),
      actionCount: grpc.action_count,
      actions: grpc.actions,
      updatedAt: parseTimestampString(grpc.updated_at)
    }),
    encode: () => {
      throw new Error("Encoding not implemented for ActivitySchema");
    }
  }
);
var ActivitiesResponseSchema = Schema3.transform(
  Schema3.Struct({
    activities: Schema3.Array(ActivitySchema),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  Schema3.Struct({
    items: Schema3.Array(ActivitySchema),
    nextCursor: Schema3.optional(Schema3.String),
    next_cursor: Schema3.optional(Schema3.String)
  }),
  {
    decode: (grpc) => ({
      items: grpc.activities,
      nextCursor: grpc.next_cursor,
      next_cursor: grpc.next_cursor
    }),
    encode: (torii) => ({
      activities: torii.items,
      next_cursor: torii.nextCursor
    })
  }
);

// src/mappings/effect-schema/transformers.ts
function transformTransaction(tx) {
  return Schema4.decodeSync(TransactionSchema)(tx);
}
function transformTransactionsResponse(response) {
  return Schema4.decodeSync(TransactionsResponseSchema)(response);
}
function transformControllersResponse(response) {
  return Schema4.decodeSync(ControllersResponseSchema)(response);
}
function transformToken(token) {
  return Schema4.decodeSync(TokenSchema)(token);
}
function transformTokensResponse(response) {
  return Schema4.decodeSync(TokensResponseSchema)(response);
}
function transformTokenBalance(balance) {
  return Schema4.decodeSync(TokenBalanceSchema)(balance);
}
function transformTokenBalancesResponse(response) {
  return Schema4.decodeSync(TokenBalancesResponseSchema)(response);
}
function transformTokenContractsResponse(response) {
  return Schema4.decodeSync(TokenContractsResponseSchema)(response);
}
function transformTokenTransfer(transfer) {
  return Schema4.decodeSync(TokenTransferSchema)(transfer);
}
function transformTokenTransfersResponse(response) {
  return Schema4.decodeSync(TokenTransfersResponseSchema)(response);
}
function transformEntity(entity) {
  return Schema4.decodeSync(EntitySchema)(entity);
}
function transformEntitiesResponse(response) {
  return Schema4.decodeSync(EntitiesResponseSchema)(response);
}
function transformAggregationEntry(entry) {
  return Schema4.decodeSync(AggregationEntrySchema)(entry);
}
function transformAggregationsResponse(response) {
  return Schema4.decodeSync(AggregationsResponseSchema)(response);
}
function transformActivity(activity) {
  return Schema4.decodeSync(ActivitySchema)(activity);
}
function transformActivitiesResponse(response) {
  return Schema4.decodeSync(ActivitiesResponseSchema)(response);
}
function transformMessage(message) {
  return {
    message: message.message,
    signature: message.signature.map(
      (sig) => Schema4.encodeSync(BufferToHex)(sig)
    )
  };
}
function transformEvent(event) {
  return {
    keys: event.keys.map(
      (key) => Schema4.decodeSync(BufferToHex)(key)
    ),
    data: event.data.map(
      (d) => Schema4.decodeSync(BufferToHex)(d)
    ),
    transaction_hash: Schema4.decodeSync(BufferToHex)(
      event.transaction_hash
    )
  };
}
function transformEventsResponse(response) {
  return {
    items: response.events.map(transformEvent),
    next_cursor: response.next_cursor || void 0
  };
}
function transformContract(contract) {
  return {
    contract_address: Schema4.decodeSync(BufferToHex)(
      contract.contract_address
    ),
    contract_type: contract.contract_type,
    head: contract.head ? Number(contract.head) : void 0,
    tps: contract.tps ? Number(contract.tps) : void 0,
    last_block_timestamp: contract.last_block_timestamp ? Number(contract.last_block_timestamp) : void 0,
    last_pending_block_tx: contract.last_pending_block_tx ? Schema4.decodeSync(BufferToHex)(contract.last_pending_block_tx) : void 0,
    updated_at: Number(contract.updated_at),
    created_at: Number(contract.created_at)
  };
}
function transformContractsResponse(response) {
  return {
    items: response.contracts.map(transformContract)
  };
}
function transformWorldMetadataResponse(response, preferredWorldAddress) {
  if (!response.worlds || response.worlds.length === 0) {
    return null;
  }
  const normalizedPreferred = preferredWorldAddress ? preferredWorldAddress.toLowerCase() : void 0;
  const world = (normalizedPreferred ? response.worlds.find(
    (candidate) => candidate.world_address.toLowerCase() === normalizedPreferred
  ) : void 0) ?? response.worlds[0];
  return {
    world_address: world.world_address,
    models: world.models.map((model) => ({
      selector: Schema4.decodeSync(BufferToHex)(model.selector),
      namespace: model.namespace,
      name: model.name,
      packed_size: model.packed_size,
      unpacked_size: model.unpacked_size,
      class_hash: Schema4.decodeSync(BufferToHex)(model.class_hash),
      layout: Schema4.decodeSync(BufferToHex)(model.layout),
      schema: Schema4.decodeSync(BufferToHex)(model.schema),
      contract_address: Schema4.decodeSync(BufferToHex)(
        model.contract_address
      ),
      use_legacy_store: model.use_legacy_store,
      world_address: Schema4.decodeSync(BufferToHex)(model.world_address)
    }))
  };
}

// src/torii-client.ts
import { Schema as Schema5 } from "effect";
import { addAddressPadding as addAddressPadding2 } from "starknet";
function hexToBuffer3(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function bufferToHex2(buffer) {
  return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Subscription = class {
  _subscription;
  constructor(subscription) {
    this._subscription = subscription;
  }
  cancel() {
    this._subscription.cancel();
  }
  free() {
    this._subscription.cancel();
  }
  [Symbol.dispose]() {
    this._subscription.cancel();
  }
  get id() {
    return this._subscription.id;
  }
};
var ToriiGrpcClient = class {
  client;
  nextSubscriptionId = 1n;
  subscriptions = /* @__PURE__ */ new Map();
  useEffectSchema;
  autoReconnect;
  maxReconnectAttempts;
  worldAddress;
  worldAddressBytes;
  defaultWorldAddresses;
  mappers;
  constructor(config) {
    this.client = new DojoGrpcClient({
      url: config.toriiUrl
    });
    this.worldAddress = addAddressPadding2(config.worldAddress) ?? void 0;
    this.worldAddressBytes = this.worldAddress ? hexToBuffer3(this.worldAddress) : void 0;
    this.defaultWorldAddresses = this.worldAddressBytes ? [this.worldAddressBytes] : [];
    this.useEffectSchema = config.useEffectSchema ?? false;
    this.autoReconnect = config.autoReconnect ?? true;
    this.maxReconnectAttempts = config.maxReconnectAttempts ?? 5;
    this.mappers = this.useEffectSchema ? {
      entitiesResponse: transformEntitiesResponse,
      controllersResponse: transformControllersResponse,
      tokensResponse: transformTokensResponse,
      tokenBalancesResponse: transformTokenBalancesResponse,
      tokenContractsResponse: transformTokenContractsResponse,
      tokenTransfersResponse: transformTokenTransfersResponse,
      transactionsResponse: transformTransactionsResponse,
      message: transformMessage,
      transaction: transformTransaction,
      entity: transformEntity,
      token: transformToken,
      tokenBalance: transformTokenBalance,
      tokenTransfer: transformTokenTransfer,
      eventsResponse: transformEventsResponse,
      contractsResponse: transformContractsResponse,
      worldMetadataResponse: transformWorldMetadataResponse,
      event: transformEvent,
      contract: transformContract,
      aggregationsResponse: transformAggregationsResponse,
      aggregationEntry: transformAggregationEntry,
      activitiesResponse: transformActivitiesResponse,
      activity: transformActivity,
      achievementsResponse: mapAchievementsResponse,
      playerAchievementsResponse: mapPlayerAchievementsResponse,
      achievementProgression: mapAchievementProgression,
      sqlQueryResponse: mapSqlQueryResponse,
      searchResponse: mapSearchResponse
    } : {
      entitiesResponse: mapEntitiesResponse,
      controllersResponse: mapControllersResponse,
      tokensResponse: mapTokensResponse,
      tokenBalancesResponse: mapTokenBalancesResponse,
      tokenContractsResponse: mapTokenContractsResponse,
      tokenTransfersResponse: mapTokenTransfersResponse,
      transactionsResponse: mapTransactionsResponse,
      message: mapMessage,
      transaction: mapTransaction,
      entity: mapEntity,
      token: mapToken,
      tokenBalance: mapTokenBalance,
      tokenTransfer: mapTokenTransfer,
      eventsResponse: mapEventsResponse,
      contractsResponse: mapContractsResponse,
      worldMetadataResponse: mapWorldMetadataResponse,
      event: mapEvent,
      contract: mapContract,
      aggregationsResponse: mapAggregationsResponse,
      aggregationEntry: mapAggregationEntry,
      activitiesResponse: mapActivitiesResponse,
      activity: mapActivity,
      achievementsResponse: mapAchievementsResponse,
      playerAchievementsResponse: mapPlayerAchievementsResponse,
      achievementProgression: mapAchievementProgression,
      sqlQueryResponse: mapSqlQueryResponse,
      searchResponse: mapSearchResponse
    };
  }
  createStreamSubscription(options) {
    const subscriptionId = this.nextSubscriptionId++;
    let isCancelled = false;
    let reconnectAttempts = 0;
    const subscription = {
      id: subscriptionId,
      stream: null,
      cancel: () => {
        isCancelled = true;
        this.subscriptions.delete(subscriptionId);
      }
    };
    this.subscriptions.set(subscriptionId, subscription);
    const setupStream = (isReconnect = false) => {
      if (isCancelled) return;
      const stream = options.createStream();
      subscription.stream = stream;
      if (isReconnect) {
        if (options.onReconnect) {
          options.onReconnect();
        }
        if (subscription.lastMessage) {
          options.onMessage(subscription.lastMessage);
        }
      }
      stream.responses.onMessage((response) => {
        reconnectAttempts = 0;
        subscription.lastMessage = response;
        options.onMessage(response);
      });
      const handleError = (error) => {
        if (isCancelled) return;
        const isNetworkError3 = error.message.includes("network") || error.message.includes("fetch") || error.message.includes("body stream") || error.message.includes("connection");
        if (isNetworkError3 && this.autoReconnect && reconnectAttempts < this.maxReconnectAttempts) {
          reconnectAttempts++;
          const delay = Math.pow(2, reconnectAttempts) * 1e3;
          setTimeout(() => setupStream(true), delay);
        } else {
          if (options.onError) {
            options.onError(error);
          } else {
            console.error(
              `Stream error (subscription ${subscriptionId}):`,
              error
            );
          }
        }
      };
      stream.responses.onError(handleError);
      const handleComplete = () => {
        if (isCancelled) return;
        if (options.onComplete) {
          options.onComplete();
        }
        this.subscriptions.delete(subscriptionId);
      };
      stream.responses.onComplete(handleComplete);
    };
    setupStream(false);
    return new Subscription(subscription);
  }
  cloneWorldAddresses(addresses) {
    return addresses.map((addr) => new Uint8Array(addr));
  }
  normalizeWorldAddresses(addresses) {
    if (addresses && addresses.length > 0) {
      return addresses.map((address) => hexToBuffer3(address));
    }
    return this.cloneWorldAddresses(this.defaultWorldAddresses);
  }
  ensureWorldAddressesList(list) {
    if (list && list.length > 0) {
      return list;
    }
    return this.cloneWorldAddresses(this.defaultWorldAddresses);
  }
  buildPagination(pagination) {
    return pagination ?? {
      limit: void 0,
      cursor: void 0,
      direction: "Forward",
      order_by: []
    };
  }
  toAchievementQueryInput(query) {
    const worldAddresses = query?.worldAddresses && query.worldAddresses.length > 0 ? query.worldAddresses : this.worldAddress ? [this.worldAddress] : [];
    const namespaces = query?.namespaces ?? [];
    const hidden = query?.hidden;
    const pagination = this.buildPagination(query?.pagination);
    if (worldAddresses.length === 0 && namespaces.length === 0 && hidden === void 0 && query?.pagination === void 0) {
      return this.worldAddress ? {
        world_addresses: [this.worldAddress],
        namespaces: [],
        hidden: void 0,
        pagination
      } : void 0;
    }
    return {
      world_addresses: worldAddresses,
      namespaces,
      hidden,
      pagination
    };
  }
  toPlayerAchievementQueryInput(query) {
    const worldAddresses = query?.worldAddresses && query.worldAddresses.length > 0 ? query.worldAddresses : this.worldAddress ? [this.worldAddress] : [];
    const namespaces = query?.namespaces ?? [];
    const playerAddresses = query?.playerAddresses ?? [];
    const pagination = this.buildPagination(query?.pagination);
    if (worldAddresses.length === 0 && namespaces.length === 0 && playerAddresses.length === 0 && query?.pagination === void 0) {
      return this.worldAddress ? {
        world_addresses: [this.worldAddress],
        namespaces: [],
        player_addresses: [],
        pagination
      } : void 0;
    }
    return {
      world_addresses: worldAddresses,
      namespaces,
      player_addresses: playerAddresses,
      pagination
    };
  }
  toAchievementProgressionFilters(query) {
    const worldAddresses = query?.worldAddresses && query.worldAddresses.length > 0 ? query.worldAddresses : this.worldAddress ? [this.worldAddress] : [];
    return {
      worldAddresses,
      namespaces: query?.namespaces ?? [],
      playerAddresses: query?.playerAddresses ?? [],
      achievementIds: query?.achievementIds ?? []
    };
  }
  toActivitySubscriptionFilters(query) {
    return {
      world_addresses: this.normalizeWorldAddresses(
        query?.worldAddresses
      ),
      namespaces: query?.namespaces ?? [],
      caller_addresses: query?.callerAddresses?.map(hexToBuffer3) ?? []
    };
  }
  async getControllers(query) {
    const request = createRetrieveControllersRequest(query);
    const response = await this.client.worldClient.retrieveControllers(request).response;
    return this.mappers.controllersResponse(response);
  }
  async getTransactions(query) {
    const request = createRetrieveTransactionsRequest(query);
    const response = await this.client.worldClient.retrieveTransactions(request).response;
    return this.mappers.transactionsResponse(response);
  }
  async getTokens(query) {
    const normalizedQuery = {
      ...query,
      attribute_filters: query.attribute_filters ?? []
    };
    const request = createRetrieveTokensRequest(normalizedQuery);
    const response = await this.client.worldClient.retrieveTokens(request).response;
    return this.mappers.tokensResponse(response);
  }
  async getTokenBalances(query) {
    const request = createRetrieveTokenBalancesRequest(query);
    const response = await this.client.worldClient.retrieveTokenBalances(request).response;
    return this.mappers.tokenBalancesResponse(response);
  }
  async getTokenContracts(query) {
    const request = createRetrieveTokenContractsRequest(query);
    const response = await this.client.worldClient.retrieveTokenContracts(request).response;
    return this.mappers.tokenContractsResponse(response);
  }
  async getTokenTransfers(query) {
    const request = createRetrieveTokenTransfersRequest(query);
    const response = await this.client.worldClient.retrieveTokenTransfers(request).response;
    return this.mappers.tokenTransfersResponse(response);
  }
  async getAchievements(query) {
    const request = createRetrieveAchievementsRequest(query);
    const response = await this.client.worldClient.retrieveAchievements(request).response;
    return this.mappers.achievementsResponse(response);
  }
  async getPlayerAchievements(query) {
    const request = createRetrievePlayerAchievementsRequest(query);
    const response = await this.client.worldClient.retrievePlayerAchievements(request).response;
    return this.mappers.playerAchievementsResponse(response);
  }
  async getEntities(query) {
    const request = createRetrieveEntitiesRequest(query);
    if (request.query) {
      request.query.world_addresses = this.ensureWorldAddressesList(
        request.query.world_addresses
      );
    }
    const response = await this.client.worldClient.retrieveEntities(request).response;
    return this.mappers.entitiesResponse(response);
  }
  async getAllEntities(limit, cursor) {
    const query = {
      pagination: {
        limit,
        cursor: cursor || void 0,
        direction: "Forward",
        order_by: []
      },
      clause: void 0,
      no_hashed_keys: true,
      models: [],
      historical: false,
      world_addresses: []
    };
    return this.getEntities(query);
  }
  async getEventMessages(query) {
    const request = createRetrieveEventMessagesRequest(query);
    if (request.query) {
      request.query.world_addresses = this.ensureWorldAddressesList(
        request.query.world_addresses
      );
    }
    const response = await this.client.worldClient.retrieveEventMessages(request).response;
    return this.mappers.entitiesResponse(response);
  }
  async onTransaction(filter, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTransactions({
        filter: filter ? mapTransactionFilter(filter) : void 0
      }),
      onMessage: (response) => {
        if (response.transaction) {
          callback(this.mappers.transaction(response.transaction));
        }
      }
    });
  }
  async onTokenUpdated(contract_addresses, token_ids, callback, onError) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokens({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.token) {
          callback(this.mappers.token(response.token));
        }
      },
      onError
    });
  }
  async onEntityUpdated(clause, world_addresses, callback, onError) {
    const worldAddressesBytes = this.normalizeWorldAddresses(world_addresses);
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEntities({
        clause: clause ? mapClause(clause) : void 0,
        world_addresses: worldAddressesBytes
      }),
      onMessage: (response) => {
        console.log(response);
        if (response.entity) {
          callback(
            this.mappers.entity(response.entity),
            response.subscription_id
          );
        }
      },
      onError
    });
  }
  async updateEntitySubscription(subscription, clause, world_addresses) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateEntitiesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      clause: clause ? mapClause(clause) : void 0,
      world_addresses: this.normalizeWorldAddresses(world_addresses)
    }).response;
  }
  async onEventMessageUpdated(clause, world_addresses, callback) {
    const worldAddressesBytes = this.normalizeWorldAddresses(world_addresses);
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEventMessages({
        clause: clause ? mapClause(clause) : void 0,
        world_addresses: worldAddressesBytes
      }),
      onMessage: (response) => {
        if (response.entity) {
          callback(
            this.mappers.entity(response.entity),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateEventMessageSubscription(subscription, clause, world_addresses) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateEventMessagesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      clause: clause ? mapClause(clause) : void 0,
      world_addresses: this.normalizeWorldAddresses(world_addresses)
    }).response;
  }
  async onStarknetEvent(clauses, callback, onError) {
    const grpcClauses = clauses.map((clause) => ({
      keys: clause.keys.map(
        (k) => k ? hexToBuffer3(k) : new Uint8Array()
      ),
      pattern_matching: clause.pattern_matching === "FixedLen" ? 0 /* FixedLen */ : 1 /* VariableLen */,
      models: clause.models
    }));
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeEvents({
        keys: grpcClauses
      }),
      onMessage: (response) => {
        if (response.event) {
          const hexConverter = this.useEffectSchema ? (buffer) => Schema5.decodeSync(BufferToHex)(buffer) : bufferToHex2;
          callback({
            keys: response.event.keys.map(hexConverter),
            data: response.event.data.map(hexConverter),
            transaction_hash: hexConverter(
              response.event.transaction_hash
            )
          });
        }
      },
      onError
    });
  }
  async onIndexerUpdated(contract_address, callback) {
    const query = contract_address ? { contract_addresses: [contract_address] } : {};
    return this.onContractsUpdated(query, callback);
  }
  async onTokenBalanceUpdated(contract_addresses, account_addresses, token_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokenBalances({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        account_addresses: account_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.balance) {
          callback(
            this.mappers.tokenBalance(response.balance),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateTokenBalanceSubscription(subscription, contract_addresses, account_addresses, token_ids) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokenBalancesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contract_addresses.map(hexToBuffer3),
      account_addresses: account_addresses.map(hexToBuffer3),
      token_ids: token_ids.map(hexToBuffer3)
    }).response;
  }
  async onTokenTransferUpdated(contract_addresses, account_addresses, token_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeTokenTransfers({
        contract_addresses: contract_addresses?.map(hexToBuffer3) || [],
        account_addresses: account_addresses?.map(hexToBuffer3) || [],
        token_ids: token_ids?.map(hexToBuffer3) || []
      }),
      onMessage: (response) => {
        if (response.transfer) {
          callback(
            this.mappers.tokenTransfer(response.transfer),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateTokenTransferSubscription(subscription, contract_addresses, account_addresses, token_ids) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokenTransfersSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contract_addresses.map(hexToBuffer3),
      account_addresses: account_addresses.map(hexToBuffer3),
      token_ids: token_ids.map(hexToBuffer3)
    }).response;
  }
  async onAchievementProgressionUpdated(world_addresses, namespaces, player_addresses, achievement_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeAchievementProgressions(
        createSubscribeAchievementProgressionsRequest({
          worldAddresses: world_addresses ?? [],
          namespaces: namespaces ?? [],
          playerAddresses: player_addresses ?? [],
          achievementIds: achievement_ids ?? []
        })
      ),
      onMessage: (response) => {
        if (response.progression) {
          callback(
            this.mappers.achievementProgression(
              response.progression
            ),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateAchievementProgressionSubscription(subscription, world_addresses, namespaces, player_addresses, achievement_ids) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateAchievementProgressionsSubscription(
      createUpdateAchievementProgressionsSubscriptionRequest(
        BigInt(grpcSubscription.id),
        {
          worldAddresses: world_addresses,
          namespaces,
          playerAddresses: player_addresses,
          achievementIds: achievement_ids
        }
      )
    ).response;
  }
  async publishMessage(message) {
    if (!this.worldAddressBytes) {
      throw new Error("World address is required to publish messages");
    }
    const worldAddressBytes = this.worldAddressBytes;
    const request = {
      ...this.mappers.message(message),
      world_address: new Uint8Array(worldAddressBytes)
    };
    const response = await this.client.worldClient.publishMessage(request).response;
    return response.id;
  }
  async publishMessageBatch(messages) {
    if (!this.worldAddressBytes) {
      throw new Error("World address is required to publish messages");
    }
    const worldAddressBytes = this.worldAddressBytes;
    const request = {
      messages: messages.map((message) => ({
        ...this.mappers.message(message),
        world_address: new Uint8Array(worldAddressBytes)
      }))
    };
    const response = await this.client.worldClient.publishMessageBatch(request).response;
    return response.responses.map((r) => r.id);
  }
  async getWorldMetadata() {
    const response = await this.client.worldClient.worlds({
      world_addresses: this.cloneWorldAddresses(
        this.defaultWorldAddresses
      )
    }).response;
    return this.mappers.worldMetadataResponse(response, this.worldAddress);
  }
  async getWorlds(worldAddresses) {
    const response = await this.client.worldClient.worlds({
      world_addresses: worldAddresses ? worldAddresses.map(
        (address) => hexToBuffer3(addAddressPadding2(address))
      ) : []
    }).response;
    return mapWorldsResponse(response);
  }
  async getEvents(query) {
    const request = createRetrieveEventsRequest(query);
    const response = await this.client.worldClient.retrieveEvents(request).response;
    return this.mappers.eventsResponse(response);
  }
  async getContracts(query) {
    const request = createRetrieveContractsRequest(query || {});
    const response = await this.client.worldClient.retrieveContracts(request).response;
    return this.mappers.contractsResponse(response);
  }
  async getAggregations(query) {
    const request = createRetrieveAggregationsRequest(query);
    const response = await this.client.worldClient.retrieveAggregations(request).response;
    return this.mappers.aggregationsResponse(response);
  }
  async updateTokensSubscription(subscription, contractAddresses, tokenIds) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateTokensSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      contract_addresses: contractAddresses?.map(hexToBuffer3) || [],
      token_ids: tokenIds?.map(hexToBuffer3) || []
    }).response;
  }
  async onContractsUpdated(query, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeContracts({
        query: {
          contract_addresses: query.contract_addresses?.map(hexToBuffer3) || [],
          contract_types: query.contract_types || []
        }
      }),
      onMessage: (response) => {
        if (response.contract) {
          callback(this.mappers.contract(response.contract));
        }
      }
    });
  }
  async onAggregationUpdated(aggregator_ids, entity_ids, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeAggregations({
        aggregator_ids: aggregator_ids ?? [],
        entity_ids: entity_ids ?? []
      }),
      onMessage: (response) => {
        if (response.entry) {
          callback(
            this.mappers.aggregationEntry(
              response.entry
            ),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateAggregationSubscription(subscription, aggregator_ids, entity_ids) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateAggregationsSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      aggregator_ids,
      entity_ids
    }).response;
  }
  async getActivities(query) {
    const request = createRetrieveActivitiesRequest(query);
    const response = await this.client.worldClient.retrieveActivities(request).response;
    return this.mappers.activitiesResponse(response);
  }
  async onActivityUpdated(world_addresses, namespaces, caller_addresses, callback) {
    return this.createStreamSubscription({
      createStream: () => this.client.worldClient.subscribeActivities({
        world_addresses: this.normalizeWorldAddresses(world_addresses),
        namespaces: namespaces ?? [],
        caller_addresses: caller_addresses?.map(hexToBuffer3) ?? []
      }),
      onMessage: (response) => {
        if (response.activity) {
          callback(
            this.mappers.activity(
              response.activity
            ),
            response.subscription_id
          );
        }
      }
    });
  }
  async updateActivitySubscription(subscription, world_addresses, namespaces, caller_addresses) {
    const grpcSubscription = this.findSubscription(subscription);
    if (!grpcSubscription) {
      throw new Error("Subscription not found");
    }
    await this.client.worldClient.updateActivitiesSubscription({
      subscription_id: BigInt(grpcSubscription.id),
      world_addresses: world_addresses.map(hexToBuffer3),
      namespaces,
      caller_addresses: caller_addresses.map(hexToBuffer3)
    }).response;
  }
  async executeSql(query) {
    const response = await this.client.worldClient.executeSql({
      query
    }).response;
    return this.mappers.sqlQueryResponse(response);
  }
  async search(query) {
    const request = createSearchRequest(query.query, query.limit);
    const response = await this.client.worldClient.search(request).response;
    return this.mappers.searchResponse(response);
  }
  findSubscription(subscription) {
    const subscriptionId = subscription instanceof Subscription ? subscription.id : subscription.id;
    return this.subscriptions.get(subscriptionId);
  }
  destroy() {
    for (const [_, subscription] of this.subscriptions) {
      subscription.cancel();
    }
    this.subscriptions.clear();
    this.client.destroy();
  }
};

// src/torii-client-functional.ts
import { Effect as Effect3, Stream as Stream2, Fiber, pipe } from "effect";
import {
  trace,
  SpanStatusCode
} from "@opentelemetry/api";
import { addAddressPadding as addAddressPadding3 } from "starknet";

// src/services/world-client-effect.ts
import { Effect, Stream, Context, Layer, Schedule } from "effect";

// src/services/errors.ts
import { Data } from "effect";
var ToriiNetworkError = class extends Data.TaggedError("ToriiNetworkError") {
};
var ToriiValidationError = class extends Data.TaggedError(
  "ToriiValidationError"
) {
};
var ToriiSubscriptionError = class extends Data.TaggedError(
  "ToriiSubscriptionError"
) {
};
var ToriiConfigError = class extends Data.TaggedError("ToriiConfigError") {
};
var ToriiGrpcError = class extends Data.TaggedError("ToriiGrpcError") {
};
var ToriiTimeoutError = class extends Data.TaggedError("ToriiTimeoutError") {
};
var ToriiTransformError = class extends Data.TaggedError(
  "ToriiTransformError"
) {
};

// src/services/world-client-effect.ts
var WorldClientEffect = Context.GenericTag(
  "@services/WorldClientEffect"
);
var isNetworkError = (error) => {
  if (error instanceof ToriiGrpcError && error.details) {
    const details = error.details;
    if (details instanceof Error) {
      const msg = details.message.toLowerCase();
      return msg.includes("network") || msg.includes("fetch") || msg.includes("body stream") || msg.includes("connection") || msg.includes("timeout");
    }
  }
  if (error instanceof Error) {
    const msg = error.message.toLowerCase();
    return msg.includes("network") || msg.includes("fetch") || msg.includes("body stream") || msg.includes("connection") || msg.includes("timeout");
  }
  return false;
};
var mapError = (error) => {
  if (error instanceof Error) {
    return new ToriiGrpcError({
      message: error.message,
      method: "unknown",
      details: error
    });
  }
  return new ToriiGrpcError({
    message: String(error),
    method: "unknown",
    details: error
  });
};
var retryPolicy = Schedule.exponential("1 seconds").pipe(
  Schedule.compose(Schedule.recurs(5)),
  Schedule.whileInput((error) => isNetworkError(error.details))
);
var wrapUnary = (fn, methodName) => (request) => Effect.tryPromise({
  try: () => fn(request).response,
  catch: mapError
}).pipe(
  Effect.retry(retryPolicy),
  Effect.withSpan(`dojo.world.v1.WorldService/${methodName}`, {
    attributes: {
      "rpc.system": "grpc",
      "rpc.service": "dojo.world.v1.WorldService",
      "rpc.method": methodName,
      "network.protocol.name": "grpc"
    }
  })
);
var wrapStream = (fn, methodName) => (request) => Stream.asyncScoped(
  (emit) => Effect.gen(function* () {
    const call = fn(request);
    call.responses.onMessage((message) => {
      emit.single(message);
    });
    call.responses.onError((error) => {
      emit.fail(mapError(error));
    });
    call.responses.onComplete(() => {
      emit.end();
    });
    return yield* Effect.addFinalizer(() => Effect.sync(() => {
    }));
  })
).pipe(
  Stream.mapEffect(
    (value) => Effect.succeed(value).pipe(
      Effect.withSpan(
        `dojo.world.v1.WorldService/${methodName}`,
        {
          attributes: {
            "rpc.system": "grpc",
            "rpc.service": "dojo.world.v1.WorldService",
            "rpc.method": methodName,
            "network.protocol.name": "grpc"
          }
        }
      )
    )
  ),
  Stream.tapError(
    (error) => Effect.withSpan(
      `dojo.world.v1.WorldService/${methodName}.error`,
      {
        kind: 1,
        attributes: {
          "rpc.system": "grpc",
          "rpc.service": "dojo.world.v1.WorldService",
          "rpc.method": methodName,
          "error.message": error.details instanceof Error ? error.details.message : String(error.details),
          "error.type": error.details instanceof Error ? error.details.name : "GrpcError"
        }
      }
    )(Effect.void)
  )
);
var makeWorldClientEffect = (client) => ({
  retrieveEntities: wrapUnary(
    client.retrieveEntities.bind(client),
    "RetrieveEntities"
  ),
  retrieveEventMessages: wrapUnary(
    client.retrieveEventMessages.bind(client),
    "RetrieveEventMessages"
  ),
  retrieveTokens: wrapUnary(
    client.retrieveTokens.bind(client),
    "RetrieveTokens"
  ),
  retrieveTokenBalances: wrapUnary(
    client.retrieveTokenBalances.bind(client),
    "RetrieveTokenBalances"
  ),
  retrieveTokenTransfers: wrapUnary(
    client.retrieveTokenTransfers.bind(client),
    "RetrieveTokenTransfers"
  ),
  retrieveTransactions: wrapUnary(
    client.retrieveTransactions.bind(client),
    "RetrieveTransactions"
  ),
  retrieveControllers: wrapUnary(
    client.retrieveControllers.bind(client),
    "RetrieveControllers"
  ),
  retrieveEvents: wrapUnary(
    client.retrieveEvents.bind(client),
    "RetrieveEvents"
  ),
  retrieveContracts: wrapUnary(
    client.retrieveContracts.bind(client),
    "RetrieveContracts"
  ),
  retrieveTokenContracts: wrapUnary(
    client.retrieveTokenContracts.bind(client),
    "RetrieveTokenContracts"
  ),
  retrieveAggregations: wrapUnary(
    client.retrieveAggregations.bind(client),
    "RetrieveAggregations"
  ),
  retrieveActivities: wrapUnary(
    client.retrieveActivities.bind(client),
    "RetrieveActivities"
  ),
  retrieveAchievements: wrapUnary(
    client.retrieveAchievements.bind(client),
    "RetrieveAchievements"
  ),
  retrievePlayerAchievements: wrapUnary(
    client.retrievePlayerAchievements.bind(client),
    "RetrievePlayerAchievements"
  ),
  worlds: wrapUnary(client.worlds.bind(client), "Worlds"),
  search: wrapUnary(client.search.bind(client), "Search"),
  executeSql: wrapUnary(client.executeSql.bind(client), "ExecuteSql"),
  publishMessage: wrapUnary(
    client.publishMessage.bind(client),
    "PublishMessage"
  ),
  publishMessageBatch: wrapUnary(
    client.publishMessageBatch.bind(client),
    "PublishMessageBatch"
  ),
  subscribeEntities: wrapStream(
    client.subscribeEntities.bind(client),
    "SubscribeEntities"
  ),
  subscribeEventMessages: wrapStream(
    client.subscribeEventMessages.bind(client),
    "SubscribeEventMessages"
  ),
  subscribeTokens: wrapStream(
    client.subscribeTokens.bind(client),
    "SubscribeTokens"
  ),
  subscribeTokenBalances: wrapStream(
    client.subscribeTokenBalances.bind(client),
    "SubscribeTokenBalances"
  ),
  subscribeTokenTransfers: wrapStream(
    client.subscribeTokenTransfers.bind(client),
    "SubscribeTokenTransfers"
  ),
  subscribeEvents: wrapStream(
    client.subscribeEvents.bind(client),
    "SubscribeEvents"
  ),
  subscribeTransactions: wrapStream(
    client.subscribeTransactions.bind(client),
    "SubscribeTransactions"
  ),
  subscribeContracts: wrapStream(
    client.subscribeContracts.bind(client),
    "SubscribeContracts"
  ),
  subscribeAggregations: wrapStream(
    client.subscribeAggregations.bind(client),
    "SubscribeAggregations"
  ),
  subscribeActivities: wrapStream(
    client.subscribeActivities.bind(client),
    "SubscribeActivities"
  ),
  subscribeAchievementProgressions: wrapStream(
    client.subscribeAchievementProgressions.bind(client),
    "SubscribeAchievementProgressions"
  ),
  updateEntitiesSubscription: wrapUnary(
    client.updateEntitiesSubscription.bind(client),
    "UpdateEntitiesSubscription"
  ),
  updateEventMessagesSubscription: wrapUnary(
    client.updateEventMessagesSubscription.bind(client),
    "UpdateEventMessagesSubscription"
  ),
  updateTokensSubscription: wrapUnary(
    client.updateTokensSubscription.bind(client),
    "UpdateTokensSubscription"
  ),
  updateTokenBalancesSubscription: wrapUnary(
    client.updateTokenBalancesSubscription.bind(client),
    "UpdateTokenBalancesSubscription"
  ),
  updateTokenTransfersSubscription: wrapUnary(
    client.updateTokenTransfersSubscription.bind(client),
    "UpdateTokenTransfersSubscription"
  ),
  updateAggregationsSubscription: wrapUnary(
    client.updateAggregationsSubscription.bind(client),
    "UpdateAggregationsSubscription"
  ),
  updateActivitiesSubscription: wrapUnary(
    client.updateActivitiesSubscription.bind(client),
    "UpdateActivitiesSubscription"
  ),
  updateAchievementProgressionsSubscription: wrapUnary(
    client.updateAchievementProgressionsSubscription.bind(client),
    "UpdateAchievementProgressionsSubscription"
  )
});
var WorldClientEffectLive = Layer.effect(
  WorldClientEffect,
  Effect.gen(function* () {
    const client = yield* Effect.sync(() => {
      throw new Error("WorldClient must be provided");
    });
    return makeWorldClientEffect(client);
  })
);

// src/services/error-mappers.ts
import { Effect as Effect2 } from "effect";
var isNetworkError2 = (error) => {
  if (error instanceof Error) {
    const msg = error.message.toLowerCase();
    return msg.includes("network") || msg.includes("fetch") || msg.includes("body stream") || msg.includes("connection") || msg.includes("econnrefused") || msg.includes("enotfound");
  }
  return false;
};
var isTimeoutError = (error) => {
  if (error instanceof Error) {
    const msg = error.message.toLowerCase();
    return msg.includes("timeout") || msg.includes("timed out");
  }
  return false;
};
var mapGrpcError = (method, url = "unknown") => (error) => {
  if (error instanceof Error) {
    if (isNetworkError2(error)) {
      return new ToriiNetworkError({
        message: error.message,
        url,
        cause: error,
        retryable: true
      });
    }
    if (isTimeoutError(error)) {
      return new ToriiTimeoutError({
        message: error.message,
        operation: method,
        timeoutMs: 3e4
      });
    }
    return new ToriiGrpcError({
      message: error.message,
      method,
      details: error
    });
  }
  return new ToriiGrpcError({
    message: String(error),
    method
  });
};
var mapTransformError = (transformer) => (error) => {
  return new ToriiTransformError({
    message: error instanceof Error ? error.message : String(error),
    transformer,
    cause: error
  });
};
var mapSubscriptionError = (operation, subscriptionId) => (error) => {
  return new ToriiSubscriptionError({
    message: error instanceof Error ? error.message : String(error),
    subscriptionId,
    operation,
    cause: error
  });
};

// src/torii-client-functional.ts
function serializeForTelemetry(obj, maxLen = 500) {
  if (obj === null || obj === void 0) return "";
  try {
    const str = JSON.stringify(obj, (_, value) => {
      if (value instanceof Uint8Array) {
        return `<bytes:${value.length}>`;
      }
      return value;
    });
    return str.length > maxLen ? str.slice(0, maxLen) + "..." : str;
  } catch {
    return "<non-serializable>";
  }
}
function hexToBuffer4(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function bufferToHex3(buffer) {
  return "0x" + Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Subscription2 = class {
  constructor(_subscription) {
    this._subscription = _subscription;
  }
  cancel() {
    this._subscription.cancel();
  }
  free() {
    this._subscription.cancel();
  }
  [Symbol.dispose]() {
    this._subscription.cancel();
  }
  get id() {
    return this._subscription.id;
  }
};
var makeToriiClient = (config) => {
  const grpcClient = new DojoGrpcClient({ url: config.toriiUrl });
  const baseWorldClientEffect = makeWorldClientEffect(grpcClient.worldClient);
  const worldClientEffect = {
    ...baseWorldClientEffect,
    retrieveEntities: (req) => pipe(
      baseWorldClientEffect.retrieveEntities(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveEntities", config.toriiUrl)(e)
      )
    ),
    retrieveEventMessages: (req) => pipe(
      baseWorldClientEffect.retrieveEventMessages(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveEventMessages", config.toriiUrl)(e)
      )
    ),
    retrieveControllers: (req) => pipe(
      baseWorldClientEffect.retrieveControllers(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveControllers", config.toriiUrl)(e)
      )
    ),
    retrieveTransactions: (req) => pipe(
      baseWorldClientEffect.retrieveTransactions(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveTransactions", config.toriiUrl)(e)
      )
    ),
    retrieveTokens: (req) => pipe(
      baseWorldClientEffect.retrieveTokens(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveTokens", config.toriiUrl)(e)
      )
    ),
    retrieveTokenBalances: (req) => pipe(
      baseWorldClientEffect.retrieveTokenBalances(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveTokenBalances", config.toriiUrl)(e)
      )
    ),
    retrieveTokenContracts: (req) => pipe(
      baseWorldClientEffect.retrieveTokenContracts(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveTokenContracts", config.toriiUrl)(e)
      )
    ),
    retrieveTokenTransfers: (req) => pipe(
      baseWorldClientEffect.retrieveTokenTransfers(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveTokenTransfers", config.toriiUrl)(e)
      )
    ),
    retrieveEvents: (req) => pipe(
      baseWorldClientEffect.retrieveEvents(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveEvents", config.toriiUrl)(e)
      )
    ),
    retrieveContracts: (req) => pipe(
      baseWorldClientEffect.retrieveContracts(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveContracts", config.toriiUrl)(e)
      )
    ),
    retrieveAggregations: (req) => pipe(
      baseWorldClientEffect.retrieveAggregations(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveAggregations", config.toriiUrl)(e)
      )
    ),
    retrieveActivities: (req) => pipe(
      baseWorldClientEffect.retrieveActivities(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveActivities", config.toriiUrl)(e)
      )
    ),
    retrieveAchievements: (req) => pipe(
      baseWorldClientEffect.retrieveAchievements(req),
      Effect3.mapError(
        (e) => mapGrpcError("retrieveAchievements", config.toriiUrl)(e)
      )
    ),
    retrievePlayerAchievements: (req) => pipe(
      baseWorldClientEffect.retrievePlayerAchievements(req),
      Effect3.mapError(
        (e) => mapGrpcError(
          "retrievePlayerAchievements",
          config.toriiUrl
        )(e)
      )
    ),
    worlds: (req) => pipe(
      baseWorldClientEffect.worlds(req),
      Effect3.mapError(
        (e) => mapGrpcError("worlds", config.toriiUrl)(e)
      )
    ),
    search: (req) => pipe(
      baseWorldClientEffect.search(req),
      Effect3.mapError(
        (e) => mapGrpcError("search", config.toriiUrl)(e)
      )
    ),
    executeSql: (req) => pipe(
      baseWorldClientEffect.executeSql(req),
      Effect3.mapError(
        (e) => mapGrpcError("executeSql", config.toriiUrl)(e)
      )
    ),
    publishMessage: (req) => pipe(
      baseWorldClientEffect.publishMessage(req),
      Effect3.mapError(
        (e) => mapGrpcError("publishMessage", config.toriiUrl)(e)
      )
    ),
    publishMessageBatch: (req) => pipe(
      baseWorldClientEffect.publishMessageBatch(req),
      Effect3.mapError(
        (e) => mapGrpcError("publishMessageBatch", config.toriiUrl)(e)
      )
    )
  };
  const otelTracer = trace.getTracer("torii-client");
  const worldAddress = addAddressPadding3(config.worldAddress) ?? void 0;
  const worldAddressBytes = worldAddress ? hexToBuffer4(worldAddress) : void 0;
  const defaultWorldAddresses = worldAddressBytes ? [worldAddressBytes] : [];
  const state = {
    subscriptions: /* @__PURE__ */ new Map(),
    nextId: 1n
  };
  const cloneWorldAddresses = (addresses) => addresses.map((addr) => new Uint8Array(addr));
  const normalizeWorldAddresses = (addresses) => {
    if (addresses && addresses.length > 0) {
      return addresses.map((address) => hexToBuffer4(address));
    }
    return cloneWorldAddresses(defaultWorldAddresses);
  };
  const ensureWorldAddressesList = (list) => {
    if (list && list.length > 0) {
      return list;
    }
    return cloneWorldAddresses(defaultWorldAddresses);
  };
  const traceStreamMessage = (operation, subscriptionId, getMessage) => Stream2.tap(
    (data) => Effect3.sync(() => {
      const span = otelTracer.startSpan(`torii.${operation}.message`);
      span.setAttribute("torii.url", config.toriiUrl);
      span.setAttribute("torii.world_address", worldAddress || "");
      span.setAttribute("torii.operation", `${operation}.message`);
      span.setAttribute("torii.subscription.id", subscriptionId);
      span.setAttribute("torii.message", getMessage(data));
      span.setStatus({ code: SpanStatusCode.OK });
      span.end();
    })
  );
  const isNetworkError3 = (error) => {
    if (!(error instanceof Error)) return false;
    const message = error.message.toLowerCase();
    return message.includes("network") || message.includes("fetch") || message.includes("body stream") || message.includes("connection");
  };
  const createStreamSubscription = (options) => {
    const autoReconnect = config.autoReconnect ?? true;
    const maxReconnectAttempts = config.maxReconnectAttempts ?? 5;
    let reconnectAttempts = 0;
    let lastMessage = void 0;
    let currentCall = null;
    const setupStream = (isReconnect) => {
      const call = options.createStream();
      currentCall = call;
      call.responses.onMessage((message) => {
        reconnectAttempts = 0;
        lastMessage = message;
        options.onMessage(message);
      });
      call.responses.onError((error) => {
        const isNetwork = isNetworkError3(error);
        const errorSpan = otelTracer.startSpan(
          `torii.${options.operation}.error`
        );
        errorSpan.setAttribute(
          "torii.subscription.id",
          Number(options.subscriptionId)
        );
        errorSpan.setAttribute("torii.url", config.toriiUrl);
        errorSpan.setAttribute(
          "torii.world_address",
          worldAddress || ""
        );
        errorSpan.setAttribute("torii.operation", options.operation);
        errorSpan.setAttribute("torii.error.message", error.message);
        errorSpan.setAttribute("torii.error.is_network", isNetwork);
        errorSpan.setAttribute(
          "torii.reconnect.attempt",
          reconnectAttempts
        );
        errorSpan.setAttribute(
          "torii.reconnect.max_attempts",
          maxReconnectAttempts
        );
        if (isNetwork && autoReconnect && reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          const delay = Math.pow(2, reconnectAttempts) * 1e3;
          errorSpan.setAttribute("torii.reconnect.delay_ms", delay);
          errorSpan.setAttribute("torii.reconnect.will_retry", true);
          errorSpan.setStatus({
            code: SpanStatusCode.ERROR,
            message: "Network error, will retry"
          });
          errorSpan.end();
          setTimeout(() => {
            const reconnectSpan = otelTracer.startSpan(
              `torii.${options.operation}.reconnect`
            );
            reconnectSpan.setAttribute(
              "torii.subscription.id",
              Number(options.subscriptionId)
            );
            reconnectSpan.setAttribute(
              "torii.operation",
              options.operation
            );
            reconnectSpan.setAttribute(
              "torii.reconnect.attempt",
              reconnectAttempts
            );
            reconnectSpan.setAttribute(
              "torii.reconnect.replaying_last_message",
              !!lastMessage
            );
            if (options.onReconnect) {
              options.onReconnect();
            }
            if (lastMessage) {
              options.onMessage(lastMessage);
            }
            setupStream(true);
            reconnectSpan.setStatus({ code: SpanStatusCode.OK });
            reconnectSpan.end();
          }, delay);
        } else {
          errorSpan.setAttribute("torii.reconnect.will_retry", false);
          errorSpan.setAttribute("torii.error.final", true);
          errorSpan.setStatus({
            code: SpanStatusCode.ERROR,
            message: error.message
          });
          errorSpan.end();
          if (options.onError) {
            options.onError(error);
          } else {
            console.error(
              `[torii] Stream error (subscription ${options.subscriptionId}):`,
              error
            );
          }
        }
      });
      call.responses.onComplete(() => {
      });
    };
    return Effect3.gen(function* () {
      setupStream(false);
      yield* Effect3.never;
    }).pipe(Effect3.forkDaemon);
  };
  const runQuery = (createEffect, method) => otelTracer.startActiveSpan(
    `torii.${method}`,
    async (span) => {
      try {
        span.setAttribute("torii.url", config.toriiUrl);
        span.setAttribute(
          "torii.world_address",
          worldAddress || ""
        );
        span.setAttribute("torii.operation", method);
        const result = await pipe(
          createEffect(span),
          Effect3.mapError(
            (error) => error instanceof Error ? mapGrpcError(method, config.toriiUrl)(error) : error
          ),
          Effect3.runPromise
        );
        span.setStatus({ code: SpanStatusCode.OK });
        return result;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: errorMessage
        });
        span.setAttribute("torii.error.message", errorMessage);
        if (error && typeof error === "object" && "_tag" in error) {
          span.setAttribute(
            "torii.error.type",
            String(error._tag)
          );
        } else {
          span.setAttribute("torii.error.type", "Unknown");
        }
        if (error instanceof ToriiGrpcError && error.code !== void 0) {
          span.setAttribute("torii.error.grpc_code", error.code);
        }
        if (error instanceof ToriiNetworkError) {
          span.setAttribute(
            "torii.error.retryable",
            error.retryable
          );
          span.setAttribute("torii.error.url", error.url);
        }
        if (error instanceof ToriiTransformError) {
          span.setAttribute(
            "torii.error.transformer",
            error.transformer
          );
        }
        throw error;
      } finally {
        span.end();
      }
    }
  );
  return {
    getEntities: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => createRetrieveEntitiesRequest(query)),
        Effect3.tap(
          (req) => Effect3.sync(() => {
            if (req.query) {
              req.query.world_addresses = ensureWorldAddressesList(
                req.query.world_addresses
              );
            }
            span.setAttributes({
              "torii.input.clause": serializeForTelemetry(
                query.clause
              ),
              "torii.input.models": serializeForTelemetry(
                query.models
              ),
              "torii.input.pagination.limit": query.pagination?.limit ?? 0,
              "torii.input.pagination.cursor": query.pagination?.cursor ?? "",
              "torii.input.historical": query.historical ?? false
            });
          })
        ),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveEntities(req)
        ),
        Effect3.flatMap(
          (response) => Effect3.try({
            try: () => mapEntitiesResponse(response),
            catch: mapTransformError("mapEntitiesResponse")
          })
        ),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              Object.keys(result).length
            );
          })
        )
      ),
      "getEntities"
    ),
    getAllEntities: (limit, cursor) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttributes({
            "torii.input.pagination.limit": limit,
            "torii.input.pagination.cursor": cursor ?? ""
          });
          return {
            pagination: {
              limit,
              cursor: cursor || void 0,
              direction: "Forward",
              order_by: []
            },
            clause: void 0,
            no_hashed_keys: true,
            models: [],
            historical: false,
            world_addresses: []
          };
        }),
        Effect3.flatMap(
          (query) => pipe(
            Effect3.sync(
              () => createRetrieveEntitiesRequest(query)
            ),
            Effect3.tap(
              (req) => Effect3.sync(() => {
                if (req.query) {
                  req.query.world_addresses = ensureWorldAddressesList(
                    req.query.world_addresses
                  );
                }
              })
            ),
            Effect3.flatMap(
              (req) => worldClientEffect.retrieveEntities(req)
            ),
            Effect3.map(mapEntitiesResponse)
          )
        ),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              Object.keys(result).length
            );
          })
        )
      ),
      "getAllEntities"
    ),
    getEventMessages: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(
          () => createRetrieveEventMessagesRequest(query)
        ),
        Effect3.tap(
          (req) => Effect3.sync(() => {
            if (req.query) {
              req.query.world_addresses = ensureWorldAddressesList(
                req.query.world_addresses
              );
            }
            span.setAttributes({
              "torii.input.clause": serializeForTelemetry(
                query.clause
              ),
              "torii.input.models": serializeForTelemetry(
                query.models
              ),
              "torii.input.pagination.limit": query.pagination?.limit ?? 0,
              "torii.input.pagination.cursor": query.pagination?.cursor ?? "",
              "torii.input.historical": query.historical ?? false
            });
          })
        ),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveEventMessages(req)
        ),
        Effect3.map(mapEntitiesResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              Object.keys(result).length
            );
          })
        )
      ),
      "getEventMessages"
    ),
    getControllers: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveControllersRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveControllers(req)
        ),
        Effect3.map(mapControllersResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              Object.keys(result).length
            );
          })
        )
      ),
      "getControllers"
    ),
    getTransactions: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveTransactionsRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveTransactions(req)
        ),
        Effect3.map(mapTransactionsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.next_cursor ?? ""
            });
          })
        )
      ),
      "getTransactions"
    ),
    getTokens: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return {
            ...query,
            attribute_filters: query.attribute_filters ?? []
          };
        }),
        Effect3.map(createRetrieveTokensRequest),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveTokens(req)
        ),
        Effect3.map(mapTokensResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.next_cursor ?? ""
            });
          })
        )
      ),
      "getTokens"
    ),
    getTokenBalances: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveTokenBalancesRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveTokenBalances(req)
        ),
        Effect3.map(mapTokenBalancesResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.next_cursor ?? ""
            });
          })
        )
      ),
      "getTokenBalances"
    ),
    getTokenContracts: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveTokenContractsRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveTokenContracts(req)
        ),
        Effect3.map(mapTokenContractsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.next_cursor ?? ""
            });
          })
        )
      ),
      "getTokenContracts"
    ),
    getTokenTransfers: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveTokenTransfersRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveTokenTransfers(req)
        ),
        Effect3.map(mapTokenTransfersResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.next_cursor ?? ""
            });
          })
        )
      ),
      "getTokenTransfers"
    ),
    getAchievements: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveAchievementsRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveAchievements(req)
        ),
        Effect3.map(mapAchievementsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.nextCursor ?? ""
            });
          })
        )
      ),
      "getAchievements"
    ),
    getPlayerAchievements: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrievePlayerAchievementsRequest(
            query
          );
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrievePlayerAchievements(req)
        ),
        Effect3.map(mapPlayerAchievementsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.nextCursor ?? ""
            });
          })
        )
      ),
      "getPlayerAchievements"
    ),
    getWorldMetadata: () => runQuery(
      () => pipe(
        Effect3.sync(() => ({
          world_addresses: cloneWorldAddresses(
            defaultWorldAddresses
          )
        })),
        Effect3.flatMap((req) => worldClientEffect.worlds(req)),
        Effect3.map(
          (response) => mapWorldMetadataResponse(response, worldAddress)
        )
      ),
      "getWorldMetadata"
    ),
    getWorlds: (worldAddresses) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.world_addresses",
            serializeForTelemetry(worldAddresses)
          );
          return {
            world_addresses: worldAddresses ? worldAddresses.map(
              (address) => hexToBuffer4(
                addAddressPadding3(address)
              )
            ) : []
          };
        }),
        Effect3.flatMap((req) => worldClientEffect.worlds(req)),
        Effect3.map(mapWorldsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              result.length
            );
          })
        )
      ),
      "getWorlds"
    ),
    getEvents: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveEventsRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveEvents(req)
        ),
        Effect3.map(mapEventsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.events?.length ?? 0,
              "torii.response.cursor": result.cursor ?? ""
            });
          })
        )
      ),
      "getEvents"
    ),
    getContracts: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveContractsRequest(query || {});
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveContracts(req)
        ),
        Effect3.map(mapContractsResponse),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              result.length
            );
          })
        )
      ),
      "getContracts"
    ),
    getAggregations: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveAggregationsRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveAggregations(req)
        ),
        Effect3.map(
          (response) => mapAggregationsResponse(
            response
          )
        ),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.nextCursor ?? ""
            });
          })
        )
      ),
      "getAggregations"
    ),
    getActivities: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            serializeForTelemetry(query)
          );
          return createRetrieveActivitiesRequest(query);
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.retrieveActivities(req)
        ),
        Effect3.flatMap(
          (response) => Effect3.try({
            try: () => mapActivitiesResponse(
              response
            ),
            catch: mapTransformError(
              "mapActivitiesResponse"
            )
          })
        ),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttributes({
              "torii.response.count": result.items.length,
              "torii.response.cursor": result.nextCursor ?? ""
            });
          })
        )
      ),
      "getActivities"
    ),
    search: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttributes({
            "torii.input.query": query.query,
            "torii.input.limit": query.limit ?? 0
          });
          return createSearchRequest(
            query.query,
            query.limit
          );
        }),
        Effect3.flatMap((req) => worldClientEffect.search(req)),
        Effect3.flatMap(
          (response) => Effect3.try({
            try: () => mapSearchResponse(response),
            catch: mapTransformError("mapSearchResponse")
          })
        ),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.count",
              result.results?.length ?? 0
            );
          })
        )
      ),
      "search"
    ),
    executeSql: (query) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          span.setAttribute(
            "torii.input.query",
            query.length > 500 ? query.slice(0, 500) + "..." : query
          );
          return { query };
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.executeSql(req)
        ),
        Effect3.flatMap(
          (response) => Effect3.try({
            try: () => mapSqlQueryResponse(response),
            catch: mapTransformError("mapSqlQueryResponse")
          })
        ),
        Effect3.tap(
          (result) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.row_count",
              result.length
            );
          })
        )
      ),
      "executeSql"
    ),
    publishMessage: (message) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          if (!worldAddressBytes) {
            throw new ToriiValidationError({
              message: "World address is required to publish messages",
              field: "worldAddress",
              expected: "valid world address"
            });
          }
          span.setAttribute(
            "torii.input.message",
            serializeForTelemetry(message)
          );
          return {
            ...mapMessage(message),
            world_address: new Uint8Array(
              worldAddressBytes
            )
          };
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.publishMessage(req)
        ),
        Effect3.flatMap(
          (response) => Effect3.succeed(response.id)
        ),
        Effect3.tap(
          (id) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.message_id",
              id
            );
          })
        )
      ),
      "publishMessage"
    ),
    publishMessageBatch: (messages) => runQuery(
      (span) => pipe(
        Effect3.sync(() => {
          if (!worldAddressBytes) {
            throw new ToriiValidationError({
              message: "World address is required to publish messages",
              field: "worldAddress",
              expected: "valid world address"
            });
          }
          span.setAttribute(
            "torii.input.message_count",
            messages.length
          );
          return {
            messages: messages.map((message) => ({
              ...mapMessage(message),
              world_address: new Uint8Array(
                worldAddressBytes
              )
            }))
          };
        }),
        Effect3.flatMap(
          (req) => worldClientEffect.publishMessageBatch(req)
        ),
        Effect3.flatMap(
          (response) => Effect3.succeed(
            response.responses.map(
              (r) => r.id
            )
          )
        ),
        Effect3.tap(
          (ids) => Effect3.sync(() => {
            span.setAttribute(
              "torii.response.message_count",
              ids.length
            );
          })
        )
      ),
      "publishMessageBatch"
    ),
    onEntityUpdated: (clause, world_addresses, callback, onError) => {
      const subscriptionId = state.nextId++;
      const worldAddressesBytes = normalizeWorldAddresses(world_addresses);
      const program = createStreamSubscription({
        createStream: () => grpcClient.worldClient.subscribeEntities({
          clause: clause ? mapClause(clause) : void 0,
          world_addresses: worldAddressesBytes
        }),
        onMessage: (response) => {
          if (response.entity) {
            try {
              const entity = mapEntity(response.entity);
              callback(entity);
            } catch (error) {
              const mappedError = mapSubscriptionError(
                "update",
                subscriptionId
              )(error);
              const span = otelTracer.startSpan(
                "torii.subscribeEntities.mapping_error"
              );
              span.setAttribute(
                "torii.subscription.id",
                Number(subscriptionId)
              );
              span.setAttribute(
                "torii.operation",
                "subscribeEntities"
              );
              span.setAttribute(
                "torii.error.type",
                mappedError._tag
              );
              span.setAttribute(
                "torii.error.message",
                mappedError.message
              );
              span.setAttribute(
                "torii.error.transformer",
                "mapEntity"
              );
              span.setStatus({
                code: SpanStatusCode.ERROR,
                message: mappedError.message
              });
              span.end();
              if (onError) {
                onError(mappedError);
              }
            }
          }
        },
        onError,
        subscriptionId,
        operation: "subscribeEntities"
      });
      return pipe(
        program,
        Effect3.map((fiber) => {
          const subscription = new Subscription2({
            id: subscriptionId,
            cancel: () => {
              Effect3.runFork(Fiber.interrupt(fiber));
              state.subscriptions.delete(subscriptionId);
            }
          });
          state.subscriptions.set(subscriptionId, subscription);
          return subscription;
        }),
        Effect3.withSpan("torii.subscribeEntities", {
          attributes: {
            "torii.url": config.toriiUrl,
            "torii.world_address": worldAddress || "",
            "torii.operation": "subscribeEntities",
            "torii.subscription.id": Number(subscriptionId)
          }
        }),
        Effect3.runPromise
      );
    },
    onTokenUpdated: (contract_addresses, token_ids, callback, onError) => {
      const subscriptionId = state.nextId++;
      const program = createStreamSubscription({
        createStream: () => grpcClient.worldClient.subscribeTokens({
          contract_addresses: contract_addresses?.map(hexToBuffer4) || [],
          token_ids: token_ids?.map(hexToBuffer4) || []
        }),
        onMessage: (response) => {
          if (response.token) {
            try {
              const token = mapToken(response.token);
              callback(token);
            } catch (error) {
              const mappedError = mapSubscriptionError(
                "update",
                subscriptionId
              )(error);
              const span = otelTracer.startSpan(
                "torii.subscribeTokens.mapping_error"
              );
              span.setAttribute(
                "torii.subscription.id",
                Number(subscriptionId)
              );
              span.setAttribute(
                "torii.operation",
                "subscribeTokens"
              );
              span.setAttribute(
                "torii.error.type",
                mappedError._tag
              );
              span.setAttribute(
                "torii.error.message",
                mappedError.message
              );
              span.setAttribute(
                "torii.error.transformer",
                "mapToken"
              );
              span.setStatus({
                code: SpanStatusCode.ERROR,
                message: mappedError.message
              });
              span.end();
              if (onError) {
                onError(mappedError);
              }
            }
          }
        },
        onError,
        subscriptionId,
        operation: "subscribeTokens"
      });
      return pipe(
        program,
        Effect3.map((fiber) => {
          const subscription = new Subscription2({
            id: subscriptionId,
            cancel: () => {
              Effect3.runFork(Fiber.interrupt(fiber));
              state.subscriptions.delete(subscriptionId);
            }
          });
          state.subscriptions.set(subscriptionId, subscription);
          return subscription;
        }),
        Effect3.withSpan("torii.subscribeTokens", {
          attributes: {
            "torii.url": config.toriiUrl,
            "torii.world_address": worldAddress || "",
            "torii.operation": "subscribeTokens",
            "torii.subscription.id": Number(subscriptionId)
          }
        }),
        Effect3.runPromise
      );
    },
    onTransaction: (filter, callback) => {
      const subscriptionId = state.nextId++;
      const program = createStreamSubscription({
        createStream: () => grpcClient.worldClient.subscribeTransactions({
          filter: filter ? mapTransactionFilter(filter) : void 0
        }),
        onMessage: (response) => {
          if (response.transaction) {
            try {
              const transaction = mapTransaction(
                response.transaction
              );
              callback(transaction);
            } catch (error) {
              const mappedError = mapSubscriptionError(
                "update",
                subscriptionId
              )(error);
              const span = otelTracer.startSpan(
                "torii.subscribeTransactions.mapping_error"
              );
              span.setAttribute(
                "torii.subscription.id",
                Number(subscriptionId)
              );
              span.setAttribute(
                "torii.operation",
                "subscribeTransactions"
              );
              span.setAttribute(
                "torii.error.type",
                mappedError._tag
              );
              span.setAttribute(
                "torii.error.message",
                mappedError.message
              );
              span.setAttribute(
                "torii.error.transformer",
                "mapTransaction"
              );
              span.setStatus({
                code: SpanStatusCode.ERROR,
                message: mappedError.message
              });
              span.end();
            }
          }
        },
        subscriptionId,
        operation: "subscribeTransactions"
      });
      return pipe(
        program,
        Effect3.map((fiber) => {
          const subscription = new Subscription2({
            id: subscriptionId,
            cancel: () => {
              Effect3.runFork(Fiber.interrupt(fiber));
              state.subscriptions.delete(subscriptionId);
            }
          });
          state.subscriptions.set(subscriptionId, subscription);
          return subscription;
        }),
        Effect3.withSpan("torii.subscribeTransactions", {
          attributes: {
            "torii.url": config.toriiUrl,
            "torii.world_address": worldAddress || "",
            "torii.operation": "subscribeTransactions",
            "torii.subscription.id": Number(subscriptionId)
          }
        }),
        Effect3.runPromise
      );
    },
    onStarknetEvent: (clauses, callback, onError) => {
      const subscriptionId = state.nextId++;
      const grpcClauses = clauses.map((clause) => ({
        keys: clause.keys.map(
          (k) => k ? hexToBuffer4(k) : new Uint8Array()
        ),
        pattern_matching: clause.pattern_matching === "FixedLen" ? 0 /* FixedLen */ : 1 /* VariableLen */,
        models: clause.models
      }));
      const program = createStreamSubscription({
        createStream: () => grpcClient.worldClient.subscribeEvents({
          keys: grpcClauses
        }),
        onMessage: (response) => {
          if (response.event) {
            try {
              const event = {
                keys: response.event.keys.map(bufferToHex3),
                data: response.event.data.map(bufferToHex3),
                transaction_hash: bufferToHex3(
                  response.event.transaction_hash
                )
              };
              callback(event);
            } catch (error) {
              const mappedError = mapSubscriptionError(
                "update",
                subscriptionId
              )(error);
              const span = otelTracer.startSpan(
                "torii.subscribeEvents.mapping_error"
              );
              span.setAttribute(
                "torii.subscription.id",
                Number(subscriptionId)
              );
              span.setAttribute(
                "torii.operation",
                "subscribeEvents"
              );
              span.setAttribute(
                "torii.error.type",
                mappedError._tag
              );
              span.setAttribute(
                "torii.error.message",
                mappedError.message
              );
              span.setAttribute(
                "torii.error.transformer",
                "bufferToHex"
              );
              span.setStatus({
                code: SpanStatusCode.ERROR,
                message: mappedError.message
              });
              span.end();
              if (onError) {
                onError(mappedError);
              }
            }
          }
        },
        onError,
        subscriptionId,
        operation: "subscribeEvents"
      });
      return pipe(
        program,
        Effect3.map((fiber) => {
          const subscription = new Subscription2({
            id: subscriptionId,
            cancel: () => {
              Effect3.runFork(Fiber.interrupt(fiber));
              state.subscriptions.delete(subscriptionId);
            }
          });
          state.subscriptions.set(subscriptionId, subscription);
          return subscription;
        }),
        Effect3.withSpan("torii.subscribeEvents", {
          attributes: {
            "torii.url": config.toriiUrl,
            "torii.world_address": worldAddress || "",
            "torii.operation": "subscribeEvents",
            "torii.subscription.id": Number(subscriptionId)
          }
        }),
        Effect3.runPromise
      );
    },
    destroy: () => {
      state.subscriptions.forEach((sub) => sub.cancel());
      state.subscriptions.clear();
      grpcClient.destroy();
    }
  };
};
export {
  Array$,
  CallType,
  ComparisonOperator,
  ContractType,
  DojoGrpcClient,
  Enum,
  EnumOption,
  FixedSizeArray,
  LogicalOperator,
  Member,
  OrderDirection,
  PaginationDirection,
  PatternMatching,
  Primitive,
  Struct,
  Subscription,
  ToriiGrpcClient,
  Ty,
  WorldClient,
  World as WorldMessage,
  World2 as WorldService,
  createDojoGrpcClient,
  makeToriiClient
};
//# sourceMappingURL=index.js.map