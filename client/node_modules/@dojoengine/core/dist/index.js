// src/provider/DojoProvider.ts
import {
  Contract,
  RpcProvider,
  shortString
} from "starknet";

// src/constants/index.ts
var LOCAL_KATANA = "http://127.0.0.1:5050";
var LOCAL_RELAY = "/ip4/127.0.0.1/tcp/9090";
var LOCAL_TORII = "http://127.0.0.1:8080";
var KATANA_PREFUNDED_ADDRESS = "0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec";
var KATANA_PREFUNDED_PRIVATE_KEY = "0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912";
var KATANA_CLASS_HASH = "0x07dc7899aa655b0aae51eadff6d801a58e97dd99cf4666ee59e704249e51adf2";
var KATANA_ETH_CONTRACT_ADDRESS = "0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";

// src/logger/logger.ts
var NO_OP = (_message, ..._optionalParams) => {
};
var ConsoleLogger = class {
  info;
  warn;
  error;
  constructor(options) {
    const { level } = options || {};
    this.error = console.error.bind(console);
    if (level === "none") {
      this.error = NO_OP;
      this.warn = NO_OP;
      this.info = NO_OP;
    }
    if (level === "error") {
      this.warn = NO_OP;
      this.info = NO_OP;
      return;
    }
    this.warn = console.warn.bind(console);
    if (level === "warn") {
      this.info = NO_OP;
      return;
    }
    this.info = console.log.bind(console);
  }
};

// src/types/index.ts
var WorldEntryPoints = /* @__PURE__ */ ((WorldEntryPoints2) => {
  WorldEntryPoints2["get"] = "entity";
  WorldEntryPoints2["set"] = "set_entity";
  WorldEntryPoints2["entities"] = "entities";
  WorldEntryPoints2["execute"] = "execute";
  WorldEntryPoints2["registerSystem"] = "register_system";
  WorldEntryPoints2["registerComponent"] = "register_model";
  WorldEntryPoints2["model"] = "model";
  WorldEntryPoints2["system"] = "system";
  WorldEntryPoints2["metadataUri"] = "metadata_uri";
  WorldEntryPoints2["setMetadataUri"] = "set_metadata_uri";
  WorldEntryPoints2["registerModel"] = "register_model";
  WorldEntryPoints2["deployContract"] = "deploy_contract";
  WorldEntryPoints2["upgradeContract"] = "upgrade_contract";
  WorldEntryPoints2["uuid"] = "uuid";
  WorldEntryPoints2["emit"] = "emit";
  WorldEntryPoints2["entityIds"] = "entity_ids";
  WorldEntryPoints2["setExecutor"] = "set_executor";
  WorldEntryPoints2["executor"] = "executor";
  WorldEntryPoints2["base"] = "base";
  WorldEntryPoints2["deleteEntity"] = "delete_entity";
  WorldEntryPoints2["isOwner"] = "is_owner";
  WorldEntryPoints2["grantOwner"] = "grant_owner";
  WorldEntryPoints2["revokeOwner"] = "revoke_owner";
  WorldEntryPoints2["isWriter"] = "is_writer";
  WorldEntryPoints2["grantWriter"] = "grant_writer";
  WorldEntryPoints2["revokeWriter"] = "revoke_writer";
  return WorldEntryPoints2;
})(WorldEntryPoints || {});

// src/utils/compile.ts
import {
  CallData,
  createAbiParser,
  parseCalldataField,
  isNoConstructorValid
} from "starknet";
function isLen(name) {
  return /_len$/.test(name);
}
function isCairo1Type(type) {
  return type.includes("::");
}
function findFunctionAbiByNamespace(abi, namespace, contractName, functionName) {
  const contractPattern = `::${contractName}::`;
  const exactMatch = abi.find((item) => {
    if (item?.type !== "interface") return false;
    const name = item.name || "";
    if (!name.startsWith(`${namespace}::`)) return false;
    if (!name.includes(contractPattern)) return false;
    return Array.isArray(item.items) && item.items.some(
      (fn) => fn?.type === "function" && fn?.name === functionName
    );
  });
  if (exactMatch) {
    return exactMatch.items.find(
      (fn) => fn?.type === "function" && fn?.name === functionName
    );
  }
  const namespaceMatch = abi.find((item) => {
    if (item?.type !== "interface") return false;
    const name = item.name || "";
    if (!name.startsWith(`${namespace}::`)) return false;
    return Array.isArray(item.items) && item.items.some(
      (fn) => fn?.type === "function" && fn?.name === functionName
    );
  });
  if (namespaceMatch) {
    return namespaceMatch.items.find(
      (fn) => fn?.type === "function" && fn?.name === functionName
    );
  }
  for (const item of abi) {
    if (item?.type === "interface" && Array.isArray(item.items)) {
      const func = item.items.find(
        (fn) => fn?.type === "function" && fn?.name === functionName
      );
      if (func) return func;
    }
  }
  return abi.find(
    (item) => item?.type === "function" && item?.name === functionName
  );
}
function compileDojoCalldata(abi, namespace, contractName, method, argsCalldata) {
  const structs = CallData.getAbiStruct(abi);
  const enums = CallData.getAbiEnum(abi);
  const parser = createAbiParser(abi);
  const abiMethod = findFunctionAbiByNamespace(
    abi,
    namespace,
    contractName,
    method
  );
  if (isNoConstructorValid(method, argsCalldata, abiMethod)) {
    return [];
  }
  if (!abiMethod) {
    throw new Error(
      `Method "${method}" not found in ABI for namespace "${namespace}", contract "${contractName}"`
    );
  }
  let args;
  if (Array.isArray(argsCalldata)) {
    const expectedCount = abiMethod.inputs.filter(
      (input) => !isLen(input.name)
    ).length;
    if (argsCalldata.length !== expectedCount) {
      throw new Error(
        `Expected ${expectedCount} arguments for method "${method}", got ${argsCalldata.length}`
      );
    }
    args = argsCalldata;
  } else {
    args = abiMethod.inputs.filter((input) => !isLen(input.name)).map((input) => {
      const value = argsCalldata[input.name];
      if (value === void 0) {
        throw new Error(
          `Missing argument "${input.name}" for method "${method}"`
        );
      }
      return value;
    });
  }
  const argsIterator = args[Symbol.iterator]();
  const callArray = abiMethod.inputs.reduce(
    (acc, input) => {
      if (isLen(input.name) && !isCairo1Type(input.type)) {
        return acc;
      }
      return acc.concat(
        parseCalldataField({
          argsIterator,
          input,
          structs,
          enums,
          parser
        })
      );
    },
    []
  );
  Object.defineProperty(callArray, "__compiled__", {
    enumerable: false,
    writable: false,
    value: true
  });
  return callArray;
}

// src/utils/index.ts
var getContractAbi = (manifest, contract2) => {
  if (Array.isArray(contract2?.abi) && contract2.abi.length > 0) {
    return contract2.abi;
  }
  if (Array.isArray(manifest?.abis)) {
    return manifest.abis;
  }
  return [];
};
var getContractByName = (manifest, nameSpace, name) => {
  return manifest.contracts.find((contract2) => {
    return contract2.tag === nameSpace + "-" + name;
  });
};
var parseDojoCall = (manifest, nameSpace, call) => {
  if ("contractName" in call) {
    const contract2 = getContractByName(
      manifest,
      nameSpace,
      call.contractName
    );
    if (!contract2) {
      throw new Error(
        `Contract "${call.contractName}" not found in namespace "${nameSpace}"`
      );
    }
    return {
      contractAddress: contract2.address,
      calldata: compileDojoCalldata(
        getContractAbi(manifest, contract2),
        nameSpace,
        call.contractName,
        call.entrypoint,
        call.calldata
      ),
      entrypoint: call.entrypoint
    };
  }
  return call;
};
var parseModelName = (model2) => {
  const acronyms = /* @__PURE__ */ new Set(["ERC"]);
  return model2.name.split("::").pop().split("_").map((part) => {
    if (acronyms.has(part.toUpperCase())) {
      return part.toUpperCase();
    }
    if (!isNaN(parseInt(part))) {
      return part;
    }
    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
  }).join("");
};
var createModelTypedData = (name, model2) => {
  const typesFromSchema = (name2, schema, types) => {
    Object.entries(schema).forEach(([key, value]) => {
      let typeName = value?.constructor.name;
      switch (typeName) {
        case "Object":
          typesFromSchema(key, value, types);
          break;
        case "BigInt":
          types[name2].push({ name: key, type: "felt" });
          break;
        case "String":
          types[name2].push({ name: key, type: "shortstring" });
          break;
        case "Number":
          types[name2].push({ name: key, type: "u128" });
          break;
        case "Boolean":
          types[name2].push({ name: key, type: "bool" });
          break;
        default:
          throw new Error(`Unsupported type: ${typeName}`);
      }
    });
    return types;
  };
  return {
    types: typesFromSchema("Model", model2, {
      StarknetDomain: [
        { name: "name", type: "shortstring" },
        { name: "version", type: "shortstring" },
        { name: "chainId", type: "shortstring" },
        { name: "revision", type: "shortstring" }
      ],
      OffchainMessage: [
        { name: "model", type: "shortstring" },
        { name, type: "Model" }
      ],
      Model: []
    }),
    primaryType: "OffchainMessage",
    domain: {
      name: "Dojo",
      version: "1",
      chainId: "1",
      revision: "1"
    },
    message: {
      model: name,
      [name]: Object.fromEntries(
        Object.entries(model2).map(([k, v]) => {
          if (typeof v === "bigint") {
            return [k, "0x" + v.toString(16)];
          }
          return [k, v];
        })
      )
    }
  };
};

// src/provider/provider.ts
var Provider = class {
  // Store the address of the world.
  worldAddress;
  /**
   * Constructor: Initializes the Provider with a given world address.
   *
   * @param {string} worldAddress - The address of the world.
   */
  constructor(worldAddress) {
    this.worldAddress = worldAddress;
  }
  /**
   * Retrieves the stored world address.
   *
   * @returns {string} - The address of the world.
   */
  getWorldAddress() {
    return this.worldAddress;
  }
};

// src/provider/DojoProvider.ts
var DojoProviderBase = class extends Provider {
  provider;
  contract;
  manifest;
  logger;
  /**
   * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.
   *
   * @param {string} world_address - Address of the world.
   * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).
   */
  constructor(manifest, url = LOCAL_KATANA, logLevel = "none") {
    super(manifest.world.address);
    this.provider = new RpcProvider({
      nodeUrl: url
    });
    this.contract = new Contract({
      abi: manifest.world.abi ?? manifest.abis ?? [],
      address: this.getWorldAddress(),
      providerOrAccount: this.provider
    });
    this.manifest = manifest;
    this.logger = new ConsoleLogger({ level: logLevel });
    this.initializeActionMethods();
  }
  /**
   * Retrieves a single entity's details.
   *
   * @param {string} model - The component to query.
   * @param {Array<string>} keys - The keys to query.
   * @param {number} [offset=0] - Starting offset (defaults to 0).
   * @param {number} [length=0] - Length to retrieve (defaults to 0).
   * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
   */
  async entity(model2, keys, offset = 0, length = 0, layout) {
    try {
      return await this.contract.call("entity" /* get */, [
        shortString.encodeShortString(model2),
        keys.length,
        ...keys,
        offset,
        length,
        layout.length,
        layout
      ]);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Retrieves multiple entities' details.
   *
   * @param {string} model - The component to query.
   * @param {number} index - The index to query.
   * @param {Array<string>} values - The values to query.
   * @param {number} valuesLength - The values length to query.
   * @param {Array<number>} valuesLayout - The values layout to query.
   */
  async entities(model2, index, values, valuesLength, valuesLayout) {
    try {
      return await this.contract.call("entities" /* entities */, [
        shortString.encodeShortString(model2),
        index,
        values,
        valuesLength,
        valuesLayout
      ]);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Retrieves a models
   *
   * @param {string} name - Name of the model.
   * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.
   */
  async model(name) {
    try {
      return await this.contract.call("model" /* model */, [
        shortString.encodeShortString(name)
      ]);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Retrieves current uuid from the world contract.
   *
   * @returns {Promise<number>} - A promise that resolves to the world uuid
   * @throws {Error} - Throws an error if the call fails.
   *
   * @example
   * const uuid = await provider.uuid();
   * console.log(uuid);
   * // => 6
   *
   */
  async uuid() {
    try {
      const result = await this.provider.callContract({
        contractAddress: this.getWorldAddress(),
        entrypoint: "uuid" /* uuid */,
        calldata: []
      });
      if (result && result.length === 1) {
        return parseInt(result[0]);
      }
      throw new Error("Contract did not return expected uuid");
    } catch (error) {
      this.logger.error(`Failed to fetch uuid: ${error}`);
      throw new Error(`Failed to fetch uuid: ${error}`);
    }
  }
  /**
   * Executes a function with the given parameters.
   * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.
   *
   * ```ts
   * await provider.execute(signer, { contractName, entrypoint, calldata });
   * await provider.execute(signer, { contractAddress, entrypoint, calldata });
   * await provider.execute(signer, [{ contractName, entrypoint, calldata }, { contractAddress, entrypoint, calldata }]);
   * ```
   * @param {Account} account - The account to use.
   * @param {AllowArray<DojoCall | Call>} call - The call or calls
   * @param {UniversalDetails} details - https://github.com/starknet-io/starknet.js/blob/5efa196017ee8f761ae837ecac9c059da8f3e09a/src/types/account.ts#L26
   * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
   */
  async execute(account, call, nameSpace, details = {}) {
    const dojoCalls = Array.isArray(call) ? call : [call];
    const calls = dojoCalls.map(
      (i) => parseDojoCall(this.manifest, nameSpace, i)
    );
    try {
      return await account?.execute(calls, details);
    } catch (error) {
      this.logger.error("Error occured: ", error);
      throw error;
    }
  }
  /**
   * Calls a function with the given parameters and return parsed results for a DojoCall.
   *
   * ```ts
   * let parsedResult = await provider.call({ contractName, entrypoint, calldata });
   * ```
   * @param {DojoCall | Call} call - The dojoCall or call
   * @returns {Promise<Result>} - A promise that resolves to the response of the function call.
   */
  async call(nameSpace, call) {
    if ("contractName" in call) {
      try {
        const contractInfos = getContractByName(
          this.manifest,
          nameSpace,
          call.contractName
        );
        const contract2 = new Contract({
          abi: contractInfos.abi,
          address: contractInfos.address,
          providerOrAccount: this.provider
        });
        const compiledCalldata = compileDojoCalldata(
          contractInfos.abi,
          nameSpace,
          call.contractName,
          call.entrypoint,
          call.calldata
        );
        return await contract2.call(call.entrypoint, compiledCalldata);
      } catch (error) {
        this.logger.error(
          `Failed to callContract ${call.contractName}: ${error}`
        );
        throw new Error(
          `Failed to callContract ${call.contractName}: ${error}`
        );
      }
    } else {
      return this.callRaw(nameSpace, call);
    }
  }
  /**
   * Calls a function with the given parameters.
   *
   * @param {string} nameSpace - The namespace of the contract within the world
   * @param {DojoCall | Call} call - The dojoCall or call
   * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.
   * @throws {Error} - Throws an error if the call fails.
   *
   * @example
   * const result = await provider.callRaw("namespace", { contractAddress, entrypoint, calldata });
   */
  async callRaw(nameSpace, call) {
    const parsedCall = parseDojoCall(this.manifest, nameSpace, call);
    try {
      return await this.provider.callContract(parsedCall);
    } catch (error) {
      this.logger.error(
        `Failed to call ${parsedCall.contractAddress}: ${error}`
      );
      throw new Error(
        `Failed to call ${parsedCall.contractAddress}: ${error}`
      );
    }
  }
  initializeActionMethods() {
    if (!this.manifest?.contracts) {
      return;
    }
    const host = this;
    const functionCounts = /* @__PURE__ */ new Map();
    for (const contract2 of this.manifest.contracts) {
      if (!contract2?.systems?.length) continue;
      for (const systemName of contract2.systems) {
        functionCounts.set(
          systemName,
          (functionCounts.get(systemName) || 0) + 1
        );
      }
    }
    const isAccountLike = (value) => typeof value === "object" && value !== null && "execute" in value;
    for (const contract2 of this.manifest.contracts) {
      if (!contract2?.systems?.length || typeof contract2.tag !== "string") {
        continue;
      }
      const names = this.parseContractTag(contract2.tag);
      if (!names) {
        continue;
      }
      const abiItems = getContractAbi(this.manifest, contract2);
      for (const systemName of contract2.systems) {
        const isDuplicate = (functionCounts.get(systemName) || 0) > 1;
        const methodName = isDuplicate ? `${names.namespace}_${names.contractName}_${systemName}` : systemName;
        if (methodName in host) {
          continue;
        }
        const interfaceAbi = abiItems.find(
          (item) => item?.type === "interface" && item?.items.find(
            (i) => i?.type === "function" && i?.name === systemName
          )
        );
        if (!interfaceAbi) {
          continue;
        }
        const functionAbi = interfaceAbi.items.find(
          (i) => i?.type === "function" && i?.name === systemName
        );
        if (!functionAbi) {
          continue;
        }
        const expectsArgs = Array.isArray(functionAbi.inputs) ? functionAbi.inputs.length > 0 : false;
        const stateMutability = typeof functionAbi.state_mutability === "string" ? functionAbi.state_mutability : "external";
        if (stateMutability === "view") {
          host[methodName] = async (...parameters) => {
            const [maybeAccountOrArgs, maybeArgs] = parameters;
            const args = isAccountLike(maybeAccountOrArgs) ? maybeArgs : maybeAccountOrArgs;
            if (expectsArgs && args === void 0) {
              throw new Error(
                `Missing arguments for action "${methodName}"`
              );
            }
            return this.call(names.namespace, {
              contractName: names.contractName,
              entrypoint: systemName,
              calldata: args ?? []
            });
          };
          continue;
        }
        host[methodName] = async (...parameters) => {
          const [maybeAccount, maybeArgs] = parameters;
          if (!isAccountLike(maybeAccount)) {
            throw new Error(
              `Account is required for action "${methodName}"`
            );
          }
          const args = maybeArgs;
          if (expectsArgs && args === void 0) {
            throw new Error(
              `Missing arguments for action "${methodName}"`
            );
          }
          return this.execute(
            maybeAccount,
            {
              contractName: names.contractName,
              entrypoint: systemName,
              calldata: args ?? []
            },
            names.namespace
          );
        };
      }
    }
  }
  parseContractTag(tag) {
    const separatorIndex = tag.lastIndexOf("-");
    if (separatorIndex === -1) {
      return null;
    }
    return {
      namespace: tag.slice(0, separatorIndex),
      contractName: tag.slice(separatorIndex + 1)
    };
  }
};
var DojoProvider = DojoProviderBase;

// src/config/index.ts
function createDojoConfig({ manifest, ...config }) {
  return {
    rpcUrl: config.rpcUrl ?? LOCAL_KATANA,
    toriiUrl: config.toriiUrl ?? LOCAL_TORII,
    masterAddress: config.masterAddress ?? KATANA_PREFUNDED_ADDRESS,
    masterPrivateKey: config.masterPrivateKey ?? KATANA_PREFUNDED_PRIVATE_KEY,
    accountClassHash: config.accountClassHash ?? KATANA_CLASS_HASH,
    feeTokenAddress: config.feeTokenAddress ?? KATANA_ETH_CONTRACT_ADDRESS,
    manifest: {
      ...manifest,
      world: { ...manifest.world, abi: manifest.abis }
    }
  };
}

// src/manifest/index.ts
import { z } from "zod";
var abiItem = z.union([
  z.object({
    type: z.literal("impl"),
    name: z.string(),
    interface_name: z.string()
  }),
  z.object({
    type: z.literal("struct"),
    name: z.string(),
    members: z.array(z.object({ name: z.string(), type: z.string() }))
  }),
  z.object({
    type: z.literal("enum"),
    name: z.string(),
    variants: z.array(z.object({ name: z.string(), type: z.string() }))
  }),
  z.object({
    type: z.literal("interface"),
    name: z.string(),
    items: z.array(
      z.object({
        type: z.literal("function"),
        name: z.string(),
        inputs: z.array(
          z.object({ name: z.string(), type: z.string() })
        ),
        outputs: z.array(z.object({ type: z.string() })),
        state_mutability: z.string()
      })
    )
  }),
  z.object({
    type: z.literal("constructor"),
    name: z.string(),
    inputs: z.array(z.object({ name: z.string(), type: z.string() }))
  }),
  z.object({
    type: z.literal("event"),
    name: z.string(),
    kind: z.literal("struct"),
    members: z.array(
      z.object({ name: z.string(), type: z.string(), kind: z.string() })
    )
  }),
  z.object({
    type: z.literal("event"),
    name: z.string(),
    kind: z.literal("enum"),
    variants: z.array(
      z.object({ name: z.string(), type: z.string(), kind: z.string() })
    )
  })
]);
var generalFields = z.object({
  class_hash: z.string(),
  name: z.string(),
  abi: z.array(abiItem)
});
var world = generalFields.extend({
  kind: z.literal("WorldContract"),
  address: z.string(),
  transaction_hash: z.string(),
  block_number: z.number(),
  seed: z.string(),
  metadata: z.object({
    rpc_url: z.string()
  })
});
var base = generalFields.extend({
  kind: z.literal("Class"),
  abi: z.literal(null)
});
var contract = generalFields.extend({
  kind: z.literal("DojoContract"),
  address: z.string(),
  reads: z.array(z.unknown()),
  writes: z.array(z.unknown()),
  computed: z.array(z.unknown())
});
var model = generalFields.extend({
  kind: z.literal("DojoModel"),
  members: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      key: z.boolean()
    })
  )
});
var manifestSchema = z.object({
  world,
  base,
  contracts: z.array(contract),
  models: z.array(model)
});
var createManifestFromJson = (content) => {
  try {
    return manifestSchema.parse(content);
  } catch (error) {
    console.error(error);
    throw new Error("Invalid Dojo manifest.json");
  }
};
export {
  DojoProvider,
  KATANA_CLASS_HASH,
  KATANA_ETH_CONTRACT_ADDRESS,
  KATANA_PREFUNDED_ADDRESS,
  KATANA_PREFUNDED_PRIVATE_KEY,
  LOCAL_KATANA,
  LOCAL_RELAY,
  LOCAL_TORII,
  WorldEntryPoints,
  createDojoConfig,
  createManifestFromJson,
  createModelTypedData,
  getContractAbi,
  getContractByName,
  parseDojoCall,
  parseModelName
};
//# sourceMappingURL=index.js.map