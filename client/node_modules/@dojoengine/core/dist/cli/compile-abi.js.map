{"version":3,"sources":["../../src/cli/compile-abi.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from \"fs\";\nimport { join, isAbsolute, dirname } from \"path\";\n\ntype AbiEntry = {\n    [key: string]: any;\n};\n\ntype LegacyManifest = {\n    world?: { abi?: AbiEntry[]; [key: string]: any };\n    base?: { abi?: AbiEntry[] | null; [key: string]: any };\n    contracts?: Array<{ abi?: AbiEntry[]; [key: string]: any }>;\n    models?: Array<{ abi?: AbiEntry[]; [key: string]: any }>;\n    [key: string]: any;\n};\n\ntype OutputPaths = {\n    json: string;\n    ts: string;\n};\n\ntype CollectOptions = {\n    generateTypes: boolean;\n    outputPath?: string;\n    manifestPath?: string;\n};\n\n/**\n * Generate a TypeScript file from compiled-abi.json with proper const assertions\n * This allows TypeScript to extract literal types from the ABI\n */\nfunction ensureDirectory(path: string): void {\n    const directory = dirname(path);\n    mkdirSync(directory, { recursive: true });\n}\n\nexport function resolveOutputPaths(outputOption?: string): OutputPaths {\n    const jsonPath = outputOption\n        ? isAbsolute(outputOption)\n            ? outputOption\n            : join(process.cwd(), outputOption)\n        : join(process.cwd(), \"compiled-abi.json\");\n\n    const tsPath = jsonPath.endsWith(\".json\")\n        ? `${jsonPath.slice(0, -5)}.ts`\n        : `${jsonPath}.ts`;\n\n    return { json: jsonPath, ts: tsPath };\n}\n\nfunction generateAbiTypes(paths: OutputPaths): void {\n    const { json: inputPath, ts: outputPath } = paths;\n\n    try {\n        // Read the compiled ABI\n        const abiContent = readFileSync(inputPath, \"utf-8\");\n        const abiJson = JSON.parse(abiContent);\n\n        // Generate TypeScript content\n        const tsContent = `// This file is auto-generated from compiled-abi.json\n// Do not edit manually\n\nexport const compiledAbi = ${JSON.stringify(abiJson, null, 2)} as const;\n\nexport type CompiledAbi = typeof compiledAbi;\n`;\n\n        // Write the TypeScript file\n        ensureDirectory(outputPath);\n        writeFileSync(outputPath, tsContent);\n\n        console.log(`âœ… Generated TypeScript types at ${outputPath}`);\n    } catch (error) {\n        console.error(`Error generating types: ${error}`);\n        process.exit(1);\n    }\n}\n\nfunction collectAbis(options: CollectOptions): void {\n    const dojoRoot = process.env.DOJO_ROOT || process.cwd();\n    const dojoEnv = process.env.DOJO_ENV || \"dev\";\n\n    const resolvedManifestPath = options.manifestPath\n        ? isAbsolute(options.manifestPath)\n            ? options.manifestPath\n            : join(dojoRoot, options.manifestPath)\n        : join(dojoRoot, `manifest_${dojoEnv}.json`);\n\n    const allAbis: AbiEntry[] = [];\n    let manifest: LegacyManifest | null = null;\n\n    // Read manifest file\n    if (!existsSync(resolvedManifestPath)) {\n        console.error(`Manifest file not found: ${resolvedManifestPath}`);\n        process.exit(1);\n    }\n\n    try {\n        const manifestContent = readFileSync(resolvedManifestPath, \"utf-8\");\n        manifest = JSON.parse(manifestContent);\n\n        if (manifest?.world?.abi) {\n            allAbis.push(...manifest.world.abi);\n        }\n\n        if (manifest?.abis) {\n            allAbis.push(...manifest.abis);\n        }\n\n        if (manifest?.contracts) {\n            for (const contract of manifest.contracts) {\n                if (Array.isArray(contract.abi)) {\n                    allAbis.push(...contract.abi);\n                }\n            }\n        }\n\n        if (manifest?.models) {\n            for (const model of manifest.models) {\n                if (Array.isArray(model.abi)) {\n                    allAbis.push(...model.abi);\n                }\n            }\n        }\n        // console.log(manifest, allAbis);\n    } catch (error) {\n        console.error(`Error reading manifest file: ${error}`);\n        process.exit(1);\n    }\n\n    const dedupedAbis = new Map<string, AbiEntry>();\n    const duplicateCounts: Record<string, number> = {};\n\n    for (const entry of allAbis) {\n        const type = typeof entry.type === \"string\" ? entry.type : \"unknown\";\n        const name =\n            typeof (entry as { name?: string }).name === \"string\"\n                ? (entry as { name: string }).name\n                : \"\";\n        const interfaceName =\n            typeof (entry as { interface_name?: string }).interface_name ===\n            \"string\"\n                ? (entry as { interface_name: string }).interface_name\n                : \"\";\n\n        const key = `${type}::${name}::${interfaceName}`;\n\n        if (dedupedAbis.has(key)) {\n            duplicateCounts[key] = (duplicateCounts[key] ?? 1) + 1;\n            continue;\n        }\n\n        dedupedAbis.set(key, entry);\n    }\n\n    const mergedAbis = Array.from(dedupedAbis.entries())\n        .sort((a, b) => a[0].localeCompare(b[0]))\n        .map(([, value]) => value);\n\n    if (Object.keys(duplicateCounts).length > 0) {\n        console.warn(\"!  Duplicate ABI entries detected and ignored:\");\n        for (const [key, count] of Object.entries(duplicateCounts)) {\n            console.warn(`   â€¢ ${key} (${count} occurrences)`);\n        }\n    }\n\n    // Write output\n    const output = {\n        abi: mergedAbis,\n        manifest: manifest\n            ? {\n                  ...manifest,\n                  contracts: manifest.contracts ?? [],\n                  models: manifest.models ?? [],\n              }\n            : undefined,\n    };\n\n    const paths = resolveOutputPaths(options.outputPath);\n    ensureDirectory(paths.json);\n    writeFileSync(paths.json, JSON.stringify(output, null, 2));\n\n    console.log(\n        `âœ… ABI compilation complete with ${mergedAbis.length} entries`\n    );\n    console.log(`ðŸ“„ ABI written to ${paths.json}`);\n\n    // Generate TypeScript types if requested\n    if (options.generateTypes) {\n        generateAbiTypes(paths);\n    }\n}\n\nfunction parseArgs(argv: string[]): CollectOptions {\n    let generateTypes = false;\n    let outputPath: string | undefined;\n    let manifestPath: string | undefined;\n    let index = 0;\n\n    while (index < argv.length) {\n        const arg = argv[index];\n\n        if (arg === \"--generate-types\") {\n            generateTypes = true;\n            index += 1;\n            continue;\n        }\n\n        if (arg === \"--output\") {\n            const value = argv[index + 1];\n            if (!value || value.startsWith(\"--\")) {\n                console.error(\"Missing value for --output option\");\n                process.exit(1);\n            }\n            outputPath = value;\n            index += 2;\n            continue;\n        }\n\n        if (arg.startsWith(\"--output=\")) {\n            const value = arg.slice(\"--output=\".length);\n            if (!value) {\n                console.error(\"Missing value for --output option\");\n                process.exit(1);\n            }\n            outputPath = value;\n            index += 1;\n            continue;\n        }\n\n        if (arg === \"--manifest-path\") {\n            const value = argv[index + 1];\n            if (!value || value.startsWith(\"--\")) {\n                console.error(\"Missing value for --manifest-path option\");\n                process.exit(1);\n            }\n            manifestPath = value;\n            index += 2;\n            continue;\n        }\n\n        if (arg.startsWith(\"--manifest-path=\")) {\n            const value = arg.slice(\"--manifest-path=\".length);\n            if (!value) {\n                console.error(\"Missing value for --manifest-path option\");\n                process.exit(1);\n            }\n            manifestPath = value;\n            index += 1;\n            continue;\n        }\n\n        console.warn(`!  Unknown argument ignored: ${arg}`);\n        index += 1;\n    }\n\n    return {\n        generateTypes,\n        outputPath,\n        manifestPath,\n    };\n}\n\nconst options = parseArgs(process.argv.slice(2));\n\ntry {\n    collectAbis(options);\n} catch (error) {\n    console.error(`Unexpected error: ${error}`);\n    process.exit(1);\n}\n"],"mappings":"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","names":["options"]}