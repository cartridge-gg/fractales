#!/usr/bin/env node

// src/cli/compile-abi.ts
import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { join, isAbsolute, dirname } from "path";
function ensureDirectory(path) {
  const directory = dirname(path);
  mkdirSync(directory, { recursive: true });
}
function resolveOutputPaths(outputOption) {
  const jsonPath = outputOption ? isAbsolute(outputOption) ? outputOption : join(process.cwd(), outputOption) : join(process.cwd(), "compiled-abi.json");
  const tsPath = jsonPath.endsWith(".json") ? `${jsonPath.slice(0, -5)}.ts` : `${jsonPath}.ts`;
  return { json: jsonPath, ts: tsPath };
}
function generateAbiTypes(paths) {
  const { json: inputPath, ts: outputPath } = paths;
  try {
    const abiContent = readFileSync(inputPath, "utf-8");
    const abiJson = JSON.parse(abiContent);
    const tsContent = `// This file is auto-generated from compiled-abi.json
// Do not edit manually

export const compiledAbi = ${JSON.stringify(abiJson, null, 2)} as const;

export type CompiledAbi = typeof compiledAbi;
`;
    ensureDirectory(outputPath);
    writeFileSync(outputPath, tsContent);
    console.log(`\u2705 Generated TypeScript types at ${outputPath}`);
  } catch (error) {
    console.error(`Error generating types: ${error}`);
    process.exit(1);
  }
}
function collectAbis(options2) {
  const dojoRoot = process.env.DOJO_ROOT || process.cwd();
  const dojoEnv = process.env.DOJO_ENV || "dev";
  const resolvedManifestPath = options2.manifestPath ? isAbsolute(options2.manifestPath) ? options2.manifestPath : join(dojoRoot, options2.manifestPath) : join(dojoRoot, `manifest_${dojoEnv}.json`);
  const allAbis = [];
  let manifest = null;
  if (!existsSync(resolvedManifestPath)) {
    console.error(`Manifest file not found: ${resolvedManifestPath}`);
    process.exit(1);
  }
  try {
    const manifestContent = readFileSync(resolvedManifestPath, "utf-8");
    manifest = JSON.parse(manifestContent);
    if (manifest?.world?.abi) {
      allAbis.push(...manifest.world.abi);
    }
    if (manifest?.abis) {
      allAbis.push(...manifest.abis);
    }
    if (manifest?.contracts) {
      for (const contract of manifest.contracts) {
        if (Array.isArray(contract.abi)) {
          allAbis.push(...contract.abi);
        }
      }
    }
    if (manifest?.models) {
      for (const model of manifest.models) {
        if (Array.isArray(model.abi)) {
          allAbis.push(...model.abi);
        }
      }
    }
  } catch (error) {
    console.error(`Error reading manifest file: ${error}`);
    process.exit(1);
  }
  const dedupedAbis = /* @__PURE__ */ new Map();
  const duplicateCounts = {};
  for (const entry of allAbis) {
    const type = typeof entry.type === "string" ? entry.type : "unknown";
    const name = typeof entry.name === "string" ? entry.name : "";
    const interfaceName = typeof entry.interface_name === "string" ? entry.interface_name : "";
    const key = `${type}::${name}::${interfaceName}`;
    if (dedupedAbis.has(key)) {
      duplicateCounts[key] = (duplicateCounts[key] ?? 1) + 1;
      continue;
    }
    dedupedAbis.set(key, entry);
  }
  const mergedAbis = Array.from(dedupedAbis.entries()).sort((a, b) => a[0].localeCompare(b[0])).map(([, value]) => value);
  if (Object.keys(duplicateCounts).length > 0) {
    console.warn("!  Duplicate ABI entries detected and ignored:");
    for (const [key, count] of Object.entries(duplicateCounts)) {
      console.warn(`   \u2022 ${key} (${count} occurrences)`);
    }
  }
  const output = {
    abi: mergedAbis,
    manifest: manifest ? {
      ...manifest,
      contracts: manifest.contracts ?? [],
      models: manifest.models ?? []
    } : void 0
  };
  const paths = resolveOutputPaths(options2.outputPath);
  ensureDirectory(paths.json);
  writeFileSync(paths.json, JSON.stringify(output, null, 2));
  console.log(
    `\u2705 ABI compilation complete with ${mergedAbis.length} entries`
  );
  console.log(`\u{1F4C4} ABI written to ${paths.json}`);
  if (options2.generateTypes) {
    generateAbiTypes(paths);
  }
}
function parseArgs(argv) {
  let generateTypes = false;
  let outputPath;
  let manifestPath;
  let index = 0;
  while (index < argv.length) {
    const arg = argv[index];
    if (arg === "--generate-types") {
      generateTypes = true;
      index += 1;
      continue;
    }
    if (arg === "--output") {
      const value = argv[index + 1];
      if (!value || value.startsWith("--")) {
        console.error("Missing value for --output option");
        process.exit(1);
      }
      outputPath = value;
      index += 2;
      continue;
    }
    if (arg.startsWith("--output=")) {
      const value = arg.slice("--output=".length);
      if (!value) {
        console.error("Missing value for --output option");
        process.exit(1);
      }
      outputPath = value;
      index += 1;
      continue;
    }
    if (arg === "--manifest-path") {
      const value = argv[index + 1];
      if (!value || value.startsWith("--")) {
        console.error("Missing value for --manifest-path option");
        process.exit(1);
      }
      manifestPath = value;
      index += 2;
      continue;
    }
    if (arg.startsWith("--manifest-path=")) {
      const value = arg.slice("--manifest-path=".length);
      if (!value) {
        console.error("Missing value for --manifest-path option");
        process.exit(1);
      }
      manifestPath = value;
      index += 1;
      continue;
    }
    console.warn(`!  Unknown argument ignored: ${arg}`);
    index += 1;
  }
  return {
    generateTypes,
    outputPath,
    manifestPath
  };
}
var options = parseArgs(process.argv.slice(2));
try {
  collectAbis(options);
} catch (error) {
  console.error(`Unexpected error: ${error}`);
  process.exit(1);
}
export {
  resolveOutputPaths
};
//# sourceMappingURL=compile-abi.js.map