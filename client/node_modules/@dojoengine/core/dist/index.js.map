{"version":3,"sources":["../src/provider/DojoProvider.ts","../src/constants/index.ts","../src/logger/logger.ts","../src/types/index.ts","../src/utils/compile.ts","../src/utils/index.ts","../src/provider/provider.ts","../src/config/index.ts","../src/manifest/index.ts"],"sourcesContent":["import {\n    type Account,\n    type AccountInterface,\n    type AllowArray,\n    type ArgsOrCalldata,\n    type Call,\n    type CallContractResponse,\n    CallResult,\n    Contract,\n    type InvokeFunctionResponse,\n    RpcProvider,\n    shortString,\n    type UniversalDetails,\n} from \"starknet\";\n\nimport { LOCAL_KATANA } from \"../constants\";\nimport { ConsoleLogger, type LogLevel } from \"../logger/logger\";\nimport { type DojoCall, WorldEntryPoints } from \"../types\";\nimport { compileDojoCalldata } from \"../utils/compile\";\nimport { getContractAbi, getContractByName, parseDojoCall } from \"../utils\";\nimport { Provider } from \"./provider\";\n\ntype DojoActionInputs<Fn> = Fn extends { inputs: infer Inputs }\n    ? keyof Inputs extends never\n        ? undefined\n        : Inputs\n    : undefined;\n\ntype KnownStateMutability = \"view\" | \"external\";\n\ntype ActionSignature = {\n    inputs: object;\n    outputs: unknown;\n    stateMutability: KnownStateMutability | (string & {});\n};\n\nexport type DojoActionInterface = Record<string, ActionSignature>;\n\ntype UnionToIntersection<U> = (\n    U extends unknown\n        ? (k: U) => void\n        : never\n) extends (k: infer I) => void\n    ? I\n    : never;\n\ntype EnsureActionInterface<T> = T extends object\n    ? {\n          [K in keyof T]: T[K] extends ActionSignature ? T[K] : never;\n      } extends T\n        ? { [K in keyof T]: T[K] }\n        : never\n    : never;\n\ntype ExtractActionUnion<Actions> = Actions extends ReadonlyArray<infer Item>\n    ? EnsureActionInterface<Item>\n    : EnsureActionInterface<Actions>;\n\ntype NormalizeActions<Actions> = EnsureActionInterface<\n    UnionToIntersection<ExtractActionUnion<Actions>>\n> extends infer Result\n    ? Result extends never\n        ? Record<never, ActionSignature>\n        : Result\n    : Record<never, ActionSignature>;\n\ntype DojoActionMethod<Fn> = Fn extends { stateMutability: infer Mut }\n    ? Mut extends \"view\"\n        ? DojoActionInputs<Fn> extends undefined\n            ? () => Promise<CallResult>\n            : (args: DojoActionInputs<Fn>) => Promise<CallResult>\n        : DojoActionInputs<Fn> extends undefined\n          ? (\n                account: Account | AccountInterface\n            ) => Promise<InvokeFunctionResponse>\n          : (\n                account: Account | AccountInterface,\n                args: DojoActionInputs<Fn>\n            ) => Promise<InvokeFunctionResponse>\n    : DojoActionInputs<Fn> extends undefined\n      ? (account: Account | AccountInterface) => Promise<InvokeFunctionResponse>\n      : (\n            account: Account | AccountInterface,\n            args: DojoActionInputs<Fn>\n        ) => Promise<InvokeFunctionResponse>;\n\ntype DojoActionMethodMap<Actions> = {\n    [K in keyof NormalizeActions<Actions> & string]: DojoActionMethod<\n        NormalizeActions<Actions>[K]\n    >;\n};\n\ntype ActionMethodImplementation = (\n    ...parameters: Array<unknown>\n) => Promise<unknown>;\n\n/**\n * Core runtime implementation for the Dojo provider. Prefer using the exported `DojoProvider`\n * constructor which augments this base instance with strongly typed action methods.\n */\nclass DojoProviderBase extends Provider {\n    public provider: RpcProvider;\n    public contract: Contract;\n    public manifest: any;\n    public logger: ConsoleLogger;\n\n    /**\n     * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.\n     *\n     * @param {string} world_address - Address of the world.\n     * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).\n     */\n    constructor(\n        manifest?: any,\n        url: string = LOCAL_KATANA,\n        logLevel: LogLevel = \"none\"\n    ) {\n        super(manifest.world.address);\n        this.provider = new RpcProvider({\n            nodeUrl: url,\n        });\n\n        this.contract = new Contract({\n            abi: manifest.world.abi ?? manifest.abis ?? [],\n            address: this.getWorldAddress(),\n            providerOrAccount: this.provider,\n        });\n        this.manifest = manifest;\n        this.logger = new ConsoleLogger({ level: logLevel });\n\n        this.initializeActionMethods();\n    }\n\n    /**\n     * Retrieves a single entity's details.\n     *\n     * @param {string} model - The component to query.\n     * @param {Array<string>} keys - The keys to query.\n     * @param {number} [offset=0] - Starting offset (defaults to 0).\n     * @param {number} [length=0] - Length to retrieve (defaults to 0).\n     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.\n     */\n    public async entity(\n        model: string,\n        keys: Array<string>,\n        offset: number = 0,\n        length: number = 0,\n        layout: Array<number>\n    ): Promise<Array<bigint>> {\n        try {\n            return (await this.contract.call(WorldEntryPoints.get, [\n                shortString.encodeShortString(model),\n                keys.length,\n                ...(keys as any),\n                offset,\n                length,\n                layout.length,\n                layout,\n            ])) as unknown as Array<bigint>;\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves multiple entities' details.\n     *\n     * @param {string} model - The component to query.\n     * @param {number} index - The index to query.\n     * @param {Array<string>} values - The values to query.\n     * @param {number} valuesLength - The values length to query.\n     * @param {Array<number>} valuesLayout - The values layout to query.\n     */\n    public async entities(\n        model: string,\n        index: string,\n        values: Array<string>,\n        valuesLength: number,\n        valuesLayout: Array<number>\n    ): Promise<Array<Array<bigint>>> {\n        try {\n            return (await this.contract.call(WorldEntryPoints.entities, [\n                shortString.encodeShortString(model),\n                index,\n                values,\n                valuesLength,\n                valuesLayout,\n            ])) as unknown as Promise<Array<Array<bigint>>>;\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves a models\n     *\n     * @param {string} name - Name of the model.\n     * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.\n     */\n    public async model(name: string): Promise<bigint> {\n        try {\n            return (await this.contract.call(WorldEntryPoints.model, [\n                shortString.encodeShortString(name),\n            ])) as unknown as bigint;\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves current uuid from the world contract.\n     *\n     * @returns {Promise<number>} - A promise that resolves to the world uuid\n     * @throws {Error} - Throws an error if the call fails.\n     *\n     * @example\n     * const uuid = await provider.uuid();\n     * console.log(uuid);\n     * // => 6\n     *\n     */\n    public async uuid(): Promise<number> {\n        try {\n            const result = await this.provider.callContract({\n                contractAddress: this.getWorldAddress(),\n                entrypoint: WorldEntryPoints.uuid,\n                calldata: [],\n            });\n            if (result && result.length === 1) {\n                return parseInt(result[0]);\n            }\n            throw new Error(\"Contract did not return expected uuid\");\n        } catch (error) {\n            this.logger.error(`Failed to fetch uuid: ${error}`);\n            throw new Error(`Failed to fetch uuid: ${error}`);\n        }\n    }\n\n    /**\n     * Executes a function with the given parameters.\n     * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.\n     *\n     * ```ts\n     * await provider.execute(signer, { contractName, entrypoint, calldata });\n     * await provider.execute(signer, { contractAddress, entrypoint, calldata });\n     * await provider.execute(signer, [{ contractName, entrypoint, calldata }, { contractAddress, entrypoint, calldata }]);\n     * ```\n     * @param {Account} account - The account to use.\n     * @param {AllowArray<DojoCall | Call>} call - The call or calls\n     * @param {UniversalDetails} details - https://github.com/starknet-io/starknet.js/blob/5efa196017ee8f761ae837ecac9c059da8f3e09a/src/types/account.ts#L26\n     * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.\n     */\n    public async execute(\n        account: Account | AccountInterface,\n        call: AllowArray<DojoCall | Call>,\n        nameSpace: string,\n        details: UniversalDetails = {}\n    ): Promise<InvokeFunctionResponse> {\n        const dojoCalls = Array.isArray(call) ? call : [call];\n        const calls = dojoCalls.map((i) =>\n            parseDojoCall(this.manifest, nameSpace, i)\n        );\n\n        try {\n            return await account?.execute(calls, details);\n        } catch (error) {\n            this.logger.error(\"Error occured: \", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Calls a function with the given parameters and return parsed results for a DojoCall.\n     *\n     * ```ts\n     * let parsedResult = await provider.call({ contractName, entrypoint, calldata });\n     * ```\n     * @param {DojoCall | Call} call - The dojoCall or call\n     * @returns {Promise<Result>} - A promise that resolves to the response of the function call.\n     */\n    public async call(\n        nameSpace: string,\n        call: DojoCall | Call\n    ): Promise<CallResult> {\n        if (\"contractName\" in call) {\n            try {\n                const contractInfos = getContractByName(\n                    this.manifest,\n                    nameSpace,\n                    call.contractName\n                );\n                const contract = new Contract({\n                    abi: contractInfos.abi,\n                    address: contractInfos.address,\n                    providerOrAccount: this.provider,\n                });\n                const compiledCalldata = compileDojoCalldata(\n                    contractInfos.abi,\n                    nameSpace,\n                    call.contractName,\n                    call.entrypoint,\n                    call.calldata\n                );\n                return await contract.call(call.entrypoint, compiledCalldata);\n            } catch (error) {\n                this.logger.error(\n                    `Failed to callContract ${call.contractName}: ${error}`\n                );\n                throw new Error(\n                    `Failed to callContract ${call.contractName}: ${error}`\n                );\n            }\n        } else {\n            return this.callRaw(nameSpace, call);\n        }\n    }\n\n    /**\n     * Calls a function with the given parameters.\n     *\n     * @param {string} nameSpace - The namespace of the contract within the world\n     * @param {DojoCall | Call} call - The dojoCall or call\n     * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.\n     * @throws {Error} - Throws an error if the call fails.\n     *\n     * @example\n     * const result = await provider.callRaw(\"namespace\", { contractAddress, entrypoint, calldata });\n     */\n    async callRaw(\n        nameSpace: string,\n        call: DojoCall | Call\n    ): Promise<CallContractResponse> {\n        const parsedCall = parseDojoCall(this.manifest, nameSpace, call);\n        try {\n            return await this.provider.callContract(parsedCall);\n        } catch (error) {\n            this.logger.error(\n                `Failed to call ${parsedCall.contractAddress}: ${error}`\n            );\n            throw new Error(\n                `Failed to call ${parsedCall.contractAddress}: ${error}`\n            );\n        }\n    }\n\n    private initializeActionMethods(): void {\n        if (!this.manifest?.contracts) {\n            return;\n        }\n\n        const host = this as unknown as Record<\n            string,\n            ActionMethodImplementation\n        >;\n\n        const functionCounts = new Map<string, number>();\n        for (const contract of this.manifest.contracts as Array<any>) {\n            if (!contract?.systems?.length) continue;\n            for (const systemName of contract.systems as Array<string>) {\n                functionCounts.set(\n                    systemName,\n                    (functionCounts.get(systemName) || 0) + 1\n                );\n            }\n        }\n\n        const isAccountLike = (\n            value: unknown\n        ): value is Account | AccountInterface =>\n            typeof value === \"object\" &&\n            value !== null &&\n            \"execute\" in (value as Record<string, unknown>);\n\n        for (const contract of this.manifest.contracts as Array<any>) {\n            if (\n                !contract?.systems?.length ||\n                typeof contract.tag !== \"string\"\n            ) {\n                continue;\n            }\n\n            const names = this.parseContractTag(contract.tag);\n            if (!names) {\n                continue;\n            }\n\n            const abiItems = getContractAbi(this.manifest, contract);\n\n            for (const systemName of contract.systems as Array<string>) {\n                const isDuplicate = (functionCounts.get(systemName) || 0) > 1;\n                const methodName = isDuplicate\n                    ? `${names.namespace}_${names.contractName}_${systemName}`\n                    : systemName;\n\n                if (methodName in host) {\n                    continue;\n                }\n\n                const interfaceAbi = abiItems.find(\n                    (item: any) =>\n                        item?.type === \"interface\" &&\n                        item?.items.find(\n                            (i: any) =>\n                                i?.type === \"function\" && i?.name === systemName\n                        )\n                );\n\n                if (!interfaceAbi) {\n                    continue;\n                }\n                const functionAbi = interfaceAbi.items.find(\n                    (i: any) => i?.type === \"function\" && i?.name === systemName\n                );\n                if (!functionAbi) {\n                    continue;\n                }\n\n                const expectsArgs = Array.isArray(functionAbi.inputs)\n                    ? functionAbi.inputs.length > 0\n                    : false;\n                const stateMutability =\n                    typeof functionAbi.state_mutability === \"string\"\n                        ? functionAbi.state_mutability\n                        : \"external\";\n\n                if (stateMutability === \"view\") {\n                    host[methodName] = async (\n                        ...parameters: Array<unknown>\n                    ) => {\n                        const [maybeAccountOrArgs, maybeArgs] = parameters;\n                        const args = isAccountLike(maybeAccountOrArgs)\n                            ? (maybeArgs as Record<string, unknown> | undefined)\n                            : (maybeAccountOrArgs as\n                                  | Record<string, unknown>\n                                  | undefined);\n\n                        if (expectsArgs && args === undefined) {\n                            throw new Error(\n                                `Missing arguments for action \"${methodName}\"`\n                            );\n                        }\n\n                        return this.call(names.namespace, {\n                            contractName: names.contractName,\n                            entrypoint: systemName,\n                            calldata: (args ?? []) as unknown as ArgsOrCalldata,\n                        });\n                    };\n\n                    continue;\n                }\n\n                host[methodName] = async (...parameters: Array<unknown>) => {\n                    const [maybeAccount, maybeArgs] = parameters;\n\n                    if (!isAccountLike(maybeAccount)) {\n                        throw new Error(\n                            `Account is required for action \"${methodName}\"`\n                        );\n                    }\n\n                    const args = maybeArgs as\n                        | Record<string, unknown>\n                        | undefined;\n\n                    if (expectsArgs && args === undefined) {\n                        throw new Error(\n                            `Missing arguments for action \"${methodName}\"`\n                        );\n                    }\n\n                    return this.execute(\n                        maybeAccount,\n                        {\n                            contractName: names.contractName,\n                            entrypoint: systemName,\n                            calldata: (args ?? []) as unknown as ArgsOrCalldata,\n                        },\n                        names.namespace\n                    );\n                };\n            }\n        }\n    }\n\n    private parseContractTag(\n        tag: string\n    ): { namespace: string; contractName: string } | null {\n        const separatorIndex = tag.lastIndexOf(\"-\");\n        if (separatorIndex === -1) {\n            return null;\n        }\n\n        return {\n            namespace: tag.slice(0, separatorIndex),\n            contractName: tag.slice(separatorIndex + 1),\n        };\n    }\n}\n\nexport type DojoProviderInstance<Actions = never> = DojoProviderBase &\n    DojoActionMethodMap<Actions>;\n\nexport type DojoProvider<Actions = never> = DojoProviderInstance<Actions>;\n\ntype DojoProviderConstructor = new <Actions = never>(\n    manifest?: any,\n    url?: string,\n    logLevel?: LogLevel\n) => DojoProvider<Actions>;\n\nexport const DojoProvider =\n    DojoProviderBase as unknown as DojoProviderConstructor;\n","export const LOCAL_KATANA = \"http://127.0.0.1:5050\";\nexport const LOCAL_RELAY = \"/ip4/127.0.0.1/tcp/9090\";\nexport const LOCAL_TORII = \"http://127.0.0.1:8080\";\nexport const KATANA_PREFUNDED_ADDRESS =\n    \"0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec\";\nexport const KATANA_PREFUNDED_PRIVATE_KEY =\n    \"0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912\";\nexport const KATANA_CLASS_HASH =\n    \"0x07dc7899aa655b0aae51eadff6d801a58e97dd99cf4666ee59e704249e51adf2\";\nexport const KATANA_ETH_CONTRACT_ADDRESS =\n    \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\";\n","/** Signature of a logging function */\nexport interface LogFn {\n    (message?: any, ...optionalParams: any[]): void;\n}\n\n/** Basic logger interface */\nexport interface Logger {\n    info: LogFn;\n    warn: LogFn;\n    error: LogFn;\n}\n\n/** Log levels */\nexport type LogLevel = \"info\" | \"warn\" | \"error\" | \"none\";\n\n/* tslint:disable:no-unused-variable */\nconst NO_OP: LogFn = (_message?: any, ..._optionalParams: any[]) => {};\n\n/** Logger which outputs to the browser console */\nexport class ConsoleLogger implements Logger {\n    readonly info: LogFn;\n    readonly warn: LogFn;\n    readonly error: LogFn;\n\n    constructor(options?: { level?: LogLevel }) {\n        const { level } = options || {};\n\n        this.error = console.error.bind(console);\n\n        if (level === \"none\") {\n            this.error = NO_OP;\n            this.warn = NO_OP;\n            this.info = NO_OP;\n        }\n\n        if (level === \"error\") {\n            this.warn = NO_OP;\n            this.info = NO_OP;\n\n            return;\n        }\n\n        this.warn = console.warn.bind(console);\n\n        if (level === \"warn\") {\n            this.info = NO_OP;\n\n            return;\n        }\n\n        this.info = console.log.bind(console);\n    }\n}\n","import { Calldata, CairoCustomEnum, CairoOption, RawArgs } from \"starknet\";\n\n/**\n * Enumeration representing various entry points or functions available in the World.\n */\nexport enum WorldEntryPoints {\n    get = \"entity\", // Retrieve a single entity\n    set = \"set_entity\", // Set or update a single entity\n    entities = \"entities\", // Retrieve multiple entities\n    execute = \"execute\", // Execute a specific command\n    registerSystem = \"register_system\", // Register a new system\n    registerComponent = \"register_model\", // Register a new component\n    model = \"model\", // Access a component\n    system = \"system\", // Access a system\n    metadataUri = \"metadata_uri\", // Retrieve metadata URI for a resource\n    setMetadataUri = \"set_metadata_uri\", // Set metadata URI for a resource\n    registerModel = \"register_model\", // Register a new model\n    deployContract = \"deploy_contract\", // Deploy a contract and return its address\n    upgradeContract = \"upgrade_contract\", // Upgrade a contract\n    uuid = \"uuid\", // Retrieve the UUID of the world\n    emit = \"emit\", // Emit an event\n    entityIds = \"entity_ids\", // Retrieve entity IDs for a model\n    setExecutor = \"set_executor\", // Set executor for the world\n    executor = \"executor\", // Retrieve the executor's address\n    base = \"base\", // Retrieve base class hash\n    deleteEntity = \"delete_entity\", // Delete an entity\n    isOwner = \"is_owner\", // Check if an address is an owner of a resource\n    grantOwner = \"grant_owner\", // Grant ownership of a resource\n    revokeOwner = \"revoke_owner\", // Revoke ownership of a resource\n    isWriter = \"is_writer\", // Check if a system is a writer for a model\n    grantWriter = \"grant_writer\", // Grant writer permission\n    revokeWriter = \"revoke_writer\", // Revoke writer permission\n}\n\n/**\n * World interface: An interface that defines the methods that a world must implement.\n * Dojo v0.4.0\n */\n\nexport interface IWorld {\n    // Retrieve metadata URI for a resource\n    metadataUri?(resource: string): Promise<Array<string>>;\n\n    // Set metadata URI for a resource\n    setMetadataUri?(resource: string, uri: Array<string>): Promise<void>;\n\n    // Retrieve model class hash by name\n    model?(name: string): Promise<string>;\n\n    // Register a new model\n    registerModel?(classHash: string): Promise<void>;\n\n    // Deploy a contract and return its address\n    deployContract?(salt: string, classHash: string): Promise<string>;\n\n    // Upgrade a contract and return its new class hash\n    upgradeContract?(address: string, classHash: string): Promise<string>;\n\n    // Retrieve the UUID of the world\n    uuid?(): Promise<string>;\n\n    // Retrieve entity details\n    entity?(\n        model: string,\n        keys: Array<string>,\n        offset: number,\n        length: number,\n        layout: Array<number>\n    ): Promise<Array<bigint>>;\n\n    // Set entity details\n    setEntity?(\n        model: string,\n        keys: Array<string>,\n        offset: number,\n        values: Array<string>,\n        layout: Array<number>\n    ): Promise<void>;\n\n    // Retrieve multiple entities' details\n    entities?(\n        model: string,\n        index: string | null,\n        values: Array<string>,\n        valuesLength: number,\n        valuesLayout: Array<number>\n    ): Promise<Array<Array<bigint>>>;\n\n    // Retrieve entity IDs for a model\n    entityIds?(model: string): Promise<Array<string>>;\n\n    // Set executor for the world\n    setExecutor?(contractAddress: string): Promise<void>;\n\n    // Retrieve the executor's address\n    executor?(): Promise<string>;\n\n    // Retrieve base class hash\n    base?(): Promise<string>;\n\n    // Delete an entity\n    deleteEntity?(\n        model: string,\n        keys: Array<string>,\n        layout: Array<number>\n    ): Promise<void>;\n\n    // Check if an address is an owner of a resource\n    isOwner?(address: string, resource: string): Promise<boolean>;\n\n    // Grant ownership of a resource to an address\n    grantOwner?(address: string, resource: string): Promise<void>;\n\n    // Revoke ownership of a resource from an address\n    revokeOwner?(address: string, resource: string): Promise<void>;\n\n    // Check if a system is a writer for a model\n    isWriter?(model: string, system: string): Promise<boolean>;\n\n    // Grant writer permission to a system for a model\n    grantWriter?(model: string, system: string): Promise<void>;\n\n    // Revoke writer permission from a system for a model\n    revokeWriter?(model: string, system: string): Promise<void>;\n\n    // Get the age or duration since the World was created\n    worldAge?(): Promise<bigint>;\n}\n\nexport type DojoCall = {\n    contractName: string;\n    entrypoint: string;\n    calldata: RawArgs | Calldata;\n};\n\n/**\n * Cairo to TypeScript type mappings\n */\ntype CairoToTsTypeMap = {\n    \"core::felt252\": string;\n    \"core::integer::u8\": number;\n    \"core::integer::u16\": number;\n    \"core::integer::u32\": number;\n    \"core::integer::u64\": bigint;\n    \"core::integer::u128\": bigint;\n    \"core::integer::u256\": bigint;\n    \"core::integer::i8\": number;\n    \"core::integer::i16\": number;\n    \"core::integer::i32\": number;\n    \"core::integer::i64\": bigint;\n    \"core::integer::i128\": bigint;\n    \"core::bool\": boolean;\n    \"core::starknet::contract_address::ContractAddress\": string;\n    \"core::starknet::class_hash::ClassHash\": string;\n    \"core::byte_array::ByteArray\": string;\n    \"()\": void;\n};\n\n/**\n * Map Cairo type to TypeScript type with ABI context\n */\nexport type MapCairoType<\n    T extends string,\n    ABI extends readonly any[] = never,\n> = T extends keyof CairoToTsTypeMap\n    ? CairoToTsTypeMap[T]\n    : T extends `core::array::Array::<${infer Inner}>`\n      ? MapCairoType<Inner, ABI>[]\n      : T extends `core::array::Span::<${infer Inner}>`\n        ? MapCairoType<Inner, ABI>[]\n        : T extends `@core::array::Array::<${infer Inner}>`\n          ? MapCairoType<Inner, ABI>[]\n          : T extends `(${infer Types})`\n            ? MapTupleTypes<Types, ABI>\n            : ABI extends never\n              ? unknown\n              : T extends ExtractStructNames<ABI>\n                ? ExtractStructType<T, ABI>\n                : T extends ExtractEnumNames<ABI>\n                  ? ExtractEnumType<T, ABI>\n                  : unknown;\n\n/**\n * Extract all struct names from ABI\n */\ntype ExtractStructNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"struct\"; name: string }\n>[\"name\"];\n\n/**\n * Find the first struct with a specific name in the ABI\n * This prevents duplicate struct definitions from creating union types\n */\ntype FindFirstStructByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"struct\"; name: Name }\n        ? First\n        : FindFirstStructByName<Rest, Name>\n    : never;\n\n/**\n * Extract a specific struct type by name from ABI\n * Only uses the first occurrence of a struct with the given name\n */\ntype ExtractStructType<\n    Name extends string,\n    ABI extends readonly any[],\n> = FindFirstStructByName<ABI, Name> extends {\n    type: \"struct\";\n    name: Name;\n    members: infer M;\n}\n    ? M extends readonly { name: string; type: string }[]\n        ? {\n              [P in M[number] as P[\"name\"]]: MapCairoType<P[\"type\"], ABI>;\n          }\n        : never\n    : never;\n\n/**\n * Map tuple types\n */\ntype MapTupleTypes<\n    T extends string,\n    ABI extends readonly any[] = never,\n> = T extends `${infer First}, ${infer Rest}`\n    ? [MapCairoType<First, ABI>, ...MapTupleTypes<Rest, ABI>]\n    : T extends \"\"\n      ? []\n      : [MapCairoType<T, ABI>];\n\ntype Simplify<T> = T extends object ? { [K in keyof T]: T[K] } : T;\n\ntype UnionToIntersection<U> = (\n    U extends any\n        ? (arg: U) => void\n        : never\n) extends (arg: infer I) => void\n    ? I\n    : never;\n\n// ========================\n// ABI Type Extraction\n// ========================\n\n/**\n * Extract function signature from a function item\n */\ntype ExtractFunctionSignature<\n    F,\n    ABI extends readonly any[] = never,\n> = F extends {\n    type: \"function\";\n    name: string;\n    inputs: infer I;\n    outputs: infer O;\n}\n    ? {\n          inputs: I extends readonly {\n              name: string;\n              type: string;\n          }[]\n              ? {\n                    [P in I[number] as P[\"name\"]]: MapCairoType<P[\"type\"], ABI>;\n                }\n              : never;\n          outputs: O extends readonly { type: string }[]\n              ? O[\"length\"] extends 0\n                  ? void\n                  : O[\"length\"] extends 1\n                    ? MapCairoType<O[0][\"type\"], ABI>\n                    : {\n                          [Index in keyof O]: O[Index] extends {\n                              type: string;\n                          }\n                              ? MapCairoType<O[Index][\"type\"], ABI>\n                              : never;\n                      }\n              : void;\n          stateMutability: F extends { state_mutability: infer Mut }\n              ? Mut extends string\n                  ? Mut\n                  : \"external\"\n              : \"external\";\n      }\n    : never;\n\n/**\n * Extract all types from ABI array\n */\nexport type ExtractAbiTypesFromArray<ABI> = ABI extends readonly any[]\n    ? {\n          structs: ExtractStructs<ABI>;\n          enums: ExtractEnums<ABI>;\n          functions: ExtractFunctions<ABI>;\n          interfaces: ExtractInterfaces<ABI>;\n          models: ExtractModels<ABI>;\n          actions: ExtractActions<ABI, ExtractInterfaces<ABI>>;\n      }\n    : never;\n\n/**\n * Helper type to extract structs from ABI\n */\ntype ExtractStructs<ABI extends readonly any[]> = {\n    [StructName in ExtractStructNames<ABI>]: ExtractStructType<StructName, ABI>;\n};\n\n/**\n * Find the first enum with a specific name in the ABI\n * This prevents duplicate enum definitions from creating union types\n */\ntype FindFirstEnumByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"enum\"; name: Name }\n        ? First\n        : FindFirstEnumByName<Rest, Name>\n    : never;\n\n/**\n * Extract all enum names from ABI\n */\ntype ExtractEnumNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"enum\"; name: string }\n>[\"name\"];\n\ntype CairoEnumVariantMap<\n    Variants extends readonly { name: string; type: string }[],\n    ABI extends readonly any[],\n> = {\n    [P in Variants[number] as P[\"name\"]]: MapCairoType<P[\"type\"], ABI>;\n};\n\ntype ExtractEnumVariants<\n    Name extends string,\n    ABI extends readonly any[],\n> = FindFirstEnumByName<ABI, Name> extends {\n    type: \"enum\";\n    name: Name;\n    variants: infer V;\n}\n    ? V extends readonly { name: string; type: string }[]\n        ? CairoEnumVariantMap<V, ABI>\n        : never\n    : never;\n\n/**\n * Extract just the type union of an enum by name\n * This is used for type mapping in function parameters\n */\ntype ExtractEnumType<\n    Name extends string,\n    ABI extends readonly any[],\n> = ExtractEnumVariants<Name, ABI> extends infer VariantMap\n    ? [VariantMap] extends [never]\n        ? never\n        : Name extends `core::option::Option::<${infer Inner}>`\n          ? CairoOption<MapCairoType<Inner, ABI>>\n          : CairoCustomEnum & {\n                readonly __variantMap?: VariantMap;\n                readonly __variantNames?: keyof VariantMap & string;\n            }\n    : never;\n\n/**\n * Helper type to extract enums from ABI\n */\ntype ExtractEnums<ABI extends readonly any[]> = {\n    [EnumName in ExtractEnumNames<ABI>]: FindFirstEnumByName<\n        ABI,\n        EnumName\n    > extends {\n        type: \"enum\";\n        name: EnumName;\n        variants: infer V;\n    }\n        ? V extends readonly { name: string; type: string }[]\n            ? {\n                  variants: CairoEnumVariantMap<V, ABI>;\n                  type: ExtractEnumType<EnumName, ABI>;\n                  variantNames: V[number][\"name\"];\n              }\n            : never\n        : never;\n};\n\n/**\n * Find the first function with a specific name in the ABI\n * This prevents duplicate function definitions from creating union types\n */\ntype FindFirstFunctionByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"function\"; name: Name }\n        ? First\n        : FindFirstFunctionByName<Rest, Name>\n    : never;\n\n/**\n * Extract all function names from ABI\n */\ntype ExtractFunctionNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"function\"; name: string }\n>[\"name\"];\n\n/**\n * Helper type to extract functions from ABI\n */\ntype ExtractFunctions<ABI extends readonly any[]> = {\n    [FunctionName in ExtractFunctionNames<ABI>]: ExtractFunctionSignature<\n        FindFirstFunctionByName<ABI, FunctionName>,\n        ABI\n    >;\n};\n\n/**\n * Find the first interface with a specific name in the ABI\n * This prevents duplicate interface definitions from creating union types\n */\ntype FindFirstInterfaceByName<\n    ABI extends readonly any[],\n    Name extends string,\n> = ABI extends readonly [infer First, ...infer Rest extends readonly any[]]\n    ? First extends { type: \"interface\"; name: Name }\n        ? First\n        : FindFirstInterfaceByName<Rest, Name>\n    : never;\n\n/**\n * Extract all interface names from ABI\n */\ntype ExtractInterfaceNames<ABI extends readonly any[]> = Extract<\n    ABI[number],\n    { type: \"interface\"; name: string }\n>[\"name\"];\n\n/**\n * Helper type to extract interfaces from ABI\n */\ntype ExtractInterfaces<ABI extends readonly any[]> = {\n    [InterfaceName in ExtractInterfaceNames<ABI>]: FindFirstInterfaceByName<\n        ABI,\n        InterfaceName\n    > extends {\n        type: \"interface\";\n        name: InterfaceName;\n        items: infer Items;\n    }\n        ? Items extends readonly any[]\n            ? {\n                  [F in Items[number] as F extends {\n                      type: \"function\";\n                      name: infer FN;\n                  }\n                      ? FN extends string\n                          ? FN\n                          : never\n                      : never]: ExtractFunctionSignature<F, ABI>;\n              }\n            : {}\n        : never;\n};\n\ntype ModelStructNames<ABI extends readonly any[]> = Extract<\n    ExtractStructNames<ABI>,\n    `${string}::models::${string}`\n>;\n\ntype MergeModelEntries<ABI extends readonly any[]> = UnionToIntersection<\n    ModelStructNames<ABI> extends infer Name\n        ? Name extends `${infer Namespace}::models::${infer Model}`\n            ? {\n                  [K in Namespace]: {\n                      [P in Model]: ExtractStructType<Name, ABI>;\n                  };\n              }\n            : {}\n        : {}\n>;\n\ntype ExtractModels<ABI extends readonly any[]> = Simplify<\n    MergeModelEntries<ABI>\n>;\n\ntype ActionInterfaceNames<ABI extends readonly any[]> = Extract<\n    ExtractInterfaceNames<ABI>,\n    `${string}::systems::actions::${string}`\n>;\n\ntype MergeActionEntries<\n    ABI extends readonly any[],\n    Interfaces extends Record<string, any>,\n> = UnionToIntersection<\n    ActionInterfaceNames<ABI> extends infer Name\n        ? Name extends `${infer Namespace}::systems::actions::${infer Interface}`\n            ? {\n                  [K in Namespace]: {\n                      [P in Interface]: Interfaces[Name & keyof Interfaces];\n                  };\n              }\n            : {}\n        : {}\n>;\n\ntype ExtractActions<\n    ABI extends readonly any[],\n    Interfaces extends Record<string, any>,\n> = Simplify<MergeActionEntries<ABI, Interfaces>>;\n\n/**\n * Main exported type for extracting ABI types\n * Usage:\n * - Compiled ABI: type MyAbi = ExtractAbiTypes<typeof compiledAbi>\n * - Raw ABI array: type MyAbi = ExtractAbiTypes<typeof abi>\n */\nexport type ExtractAbiTypes<T> = T extends { abi: infer ABI }\n    ? ABI extends readonly any[]\n        ? ExtractAbiTypesFromArray<ABI>\n        : never\n    : T extends readonly any[]\n      ? ExtractAbiTypesFromArray<T>\n      : never;\n\ntype ModelCollection<T> = ExtractAbiTypes<T>[\"models\"];\n\ntype ActionCollection<T> = ExtractAbiTypes<T>[\"actions\"];\n\nexport type ModelsFromAbi<T> = ModelCollection<T>;\n\nexport type ActionsFromAbi<T> = ActionCollection<T>;\n\ntype ModelPathUnion<Models> = Models extends Record<string, Record<string, any>>\n    ? {\n          [Namespace in keyof Models & string]: {\n              [Model in keyof Models[Namespace] &\n                  string]: `${Namespace}-${Model}`;\n          }[keyof Models[Namespace] & string];\n      }[keyof Models & string]\n    : never;\n\nexport type ModelPathFromAbi<T> = ModelPathUnion<ModelCollection<T>>;\n\nexport type GetModel<\n    T,\n    Path extends ModelPathFromAbi<T>,\n> = ModelCollection<T> extends Record<string, Record<string, any>>\n    ? Path extends `${infer Namespace}-${infer Model}`\n        ? Namespace extends keyof ModelCollection<T>\n            ? Model extends keyof ModelCollection<T>[Namespace]\n                ? ModelCollection<T>[Namespace][Model]\n                : never\n            : never\n        : never\n    : never;\n\nexport type GetActions<\n    T,\n    Namespace extends keyof ActionCollection<T>,\n> = ActionCollection<T>[Namespace];\n\nexport type GetActionInterface<\n    T,\n    Namespace extends keyof ActionCollection<T>,\n    InterfaceName extends keyof ActionCollection<T>[Namespace],\n> = ActionCollection<T>[Namespace][InterfaceName];\n\nexport type GetActionFunction<\n    T,\n    Namespace extends keyof ActionCollection<T>,\n    InterfaceName extends keyof ActionCollection<T>[Namespace],\n    FunctionName extends keyof ActionCollection<T>[Namespace][InterfaceName],\n> = ActionCollection<T>[Namespace][InterfaceName][FunctionName];\n","import {\n    type Abi,\n    type AbiEntry,\n    type Calldata,\n    type FunctionAbi,\n    type InterfaceAbi,\n    type RawArgs,\n    CallData,\n    createAbiParser,\n    parseCalldataField,\n    isNoConstructorValid,\n} from \"starknet\";\n\nfunction isLen(name: string): boolean {\n    return /_len$/.test(name);\n}\n\nfunction isCairo1Type(type: string): boolean {\n    return type.includes(\"::\");\n}\n\nexport function findFunctionAbiByNamespace(\n    abi: Abi,\n    namespace: string,\n    contractName: string,\n    functionName: string\n): FunctionAbi | undefined {\n    const contractPattern = `::${contractName}::`;\n\n    const exactMatch = abi.find((item): item is InterfaceAbi => {\n        if (item?.type !== \"interface\") return false;\n        const name = item.name || \"\";\n        if (!name.startsWith(`${namespace}::`)) return false;\n        if (!name.includes(contractPattern)) return false;\n        return (\n            Array.isArray(item.items) &&\n            item.items.some(\n                (fn: any) =>\n                    fn?.type === \"function\" && fn?.name === functionName\n            )\n        );\n    });\n\n    if (exactMatch) {\n        return exactMatch.items.find(\n            (fn: any) => fn?.type === \"function\" && fn?.name === functionName\n        ) as FunctionAbi | undefined;\n    }\n\n    const namespaceMatch = abi.find((item): item is InterfaceAbi => {\n        if (item?.type !== \"interface\") return false;\n        const name = item.name || \"\";\n        if (!name.startsWith(`${namespace}::`)) return false;\n        return (\n            Array.isArray(item.items) &&\n            item.items.some(\n                (fn: any) =>\n                    fn?.type === \"function\" && fn?.name === functionName\n            )\n        );\n    });\n\n    if (namespaceMatch) {\n        return namespaceMatch.items.find(\n            (fn: any) => fn?.type === \"function\" && fn?.name === functionName\n        ) as FunctionAbi | undefined;\n    }\n\n    for (const item of abi) {\n        if (item?.type === \"interface\" && Array.isArray(item.items)) {\n            const func = item.items.find(\n                (fn: any) =>\n                    fn?.type === \"function\" && fn?.name === functionName\n            );\n            if (func) return func as FunctionAbi;\n        }\n    }\n\n    return abi.find(\n        (item) => item?.type === \"function\" && item?.name === functionName\n    ) as FunctionAbi | undefined;\n}\n\nexport function compileDojoCalldata(\n    abi: Abi,\n    namespace: string,\n    contractName: string,\n    method: string,\n    argsCalldata: RawArgs\n): Calldata {\n    const structs = CallData.getAbiStruct(abi);\n    const enums = CallData.getAbiEnum(abi);\n    const parser = createAbiParser(abi);\n\n    const abiMethod = findFunctionAbiByNamespace(\n        abi,\n        namespace,\n        contractName,\n        method\n    );\n\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n        return [];\n    }\n\n    if (!abiMethod) {\n        throw new Error(\n            `Method \"${method}\" not found in ABI for namespace \"${namespace}\", contract \"${contractName}\"`\n        );\n    }\n\n    let args: any[];\n    if (Array.isArray(argsCalldata)) {\n        const expectedCount = abiMethod.inputs.filter(\n            (input) => !isLen(input.name)\n        ).length;\n        if (argsCalldata.length !== expectedCount) {\n            throw new Error(\n                `Expected ${expectedCount} arguments for method \"${method}\", got ${argsCalldata.length}`\n            );\n        }\n        args = argsCalldata;\n    } else {\n        args = abiMethod.inputs\n            .filter((input) => !isLen(input.name))\n            .map((input) => {\n                const value = (argsCalldata as Record<string, unknown>)[\n                    input.name\n                ];\n                if (value === undefined) {\n                    throw new Error(\n                        `Missing argument \"${input.name}\" for method \"${method}\"`\n                    );\n                }\n                return value;\n            });\n    }\n\n    const argsIterator = args[Symbol.iterator]();\n    const callArray: string[] = abiMethod.inputs.reduce(\n        (acc: string[], input: AbiEntry) => {\n            if (isLen(input.name) && !isCairo1Type(input.type)) {\n                return acc;\n            }\n            return acc.concat(\n                parseCalldataField({\n                    argsIterator,\n                    input,\n                    structs,\n                    enums,\n                    parser,\n                })\n            );\n        },\n        []\n    );\n\n    Object.defineProperty(callArray, \"__compiled__\", {\n        enumerable: false,\n        writable: false,\n        value: true,\n    });\n\n    return callArray as Calldata;\n}\n","import { Abi, Call, TypedData } from \"starknet\";\n\nimport { DojoCall } from \"../types\";\nimport { compileDojoCalldata } from \"./compile\";\n\n/**\n * Gets the ABI for a contract, supporting both old (inline) and new (root-level) manifest formats.\n *\n * @param {any} manifest - The manifest object.\n * @param {any} contract - The contract object.\n * @returns {Abi} The ABI array.\n */\nexport const getContractAbi = (manifest: any, contract: any): Abi => {\n    if (Array.isArray(contract?.abi) && contract.abi.length > 0) {\n        return contract.abi;\n    }\n    if (Array.isArray(manifest?.abis)) {\n        return manifest.abis;\n    }\n    return [];\n};\n\n/**\n * Gets a contract from a manifest by name.\n *\n * @param {any} manifest - The manifest object.\n * @param {string} name - The name of the contract.\n * @returns {any} The contract object.\n *\n */\nexport const getContractByName = (\n    manifest: any,\n    nameSpace: string,\n    name: string\n) => {\n    return manifest.contracts.find((contract: any) => {\n        return contract.tag === nameSpace + \"-\" + name;\n    });\n};\n\n/**\n * Convert a DojoCall to a Call replacing contractName with contractAddress\n *\n * @param {any} manifest - The manifest object.\n * @param {DojoCall | Call} call - A DojoCall or Call\n * @returns {Call} The contract object.\n *\n */\nexport const parseDojoCall = (\n    manifest: any,\n    nameSpace: string,\n    call: DojoCall | Call\n): Call => {\n    if (\"contractName\" in call) {\n        const contract = getContractByName(\n            manifest,\n            nameSpace,\n            call.contractName\n        );\n\n        if (!contract) {\n            throw new Error(\n                `Contract \"${call.contractName}\" not found in namespace \"${nameSpace}\"`\n            );\n        }\n\n        return {\n            contractAddress: contract.address,\n            calldata: compileDojoCalldata(\n                getContractAbi(manifest, contract),\n                nameSpace,\n                call.contractName,\n                call.entrypoint,\n                call.calldata\n            ),\n            entrypoint: call.entrypoint,\n        };\n    }\n\n    return call;\n};\n\n/**\n * Parses a model name into a class name.\n *\n * @param {any} model - The model object.\n * @returns {string} The class name.\n *\n */\nexport const parseModelName = (model: any) => {\n    // Define a set of known acronyms\n    const acronyms = new Set([\"ERC\"]);\n\n    return model.name\n        .split(\"::\")\n        .pop()\n        .split(\"_\")\n        .map((part: string) => {\n            // If the part is a known acronym, keep it in uppercase\n            if (acronyms.has(part.toUpperCase())) {\n                return part.toUpperCase();\n            }\n            // If the part is fully numeric, keep it as is\n            if (!isNaN(parseInt(part))) {\n                return part;\n            }\n            // Capitalize the first letter and make the rest lowercase\n            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n        })\n        .join(\"\");\n};\n\n/**\n * Creates a model typed data object.\n *\n * @param {any} model - The model object.\n * @returns {any} The model typed data object.\n *\n */\nexport const createModelTypedData = (name: string, model: any): TypedData => {\n    const typesFromSchema = (\n        name: string,\n        schema: any,\n        types: { [typeName: string]: { name: string; type: string }[] }\n    ) => {\n        Object.entries(schema).forEach(([key, value]) => {\n            let typeName = value?.constructor.name;\n            switch (typeName) {\n                case \"Object\":\n                    typesFromSchema(key, value, types);\n                    break;\n                case \"BigInt\":\n                    types[name].push({ name: key, type: \"felt\" });\n                    break;\n                case \"String\":\n                    types[name].push({ name: key, type: \"shortstring\" });\n                    break;\n                case \"Number\":\n                    types[name].push({ name: key, type: \"u128\" });\n                    break;\n                case \"Boolean\":\n                    types[name].push({ name: key, type: \"bool\" });\n                    break;\n                default:\n                    throw new Error(`Unsupported type: ${typeName}`);\n            }\n        });\n        return types;\n    };\n\n    return {\n        types: typesFromSchema(\"Model\", model, {\n            StarknetDomain: [\n                { name: \"name\", type: \"shortstring\" },\n                { name: \"version\", type: \"shortstring\" },\n                { name: \"chainId\", type: \"shortstring\" },\n                { name: \"revision\", type: \"shortstring\" },\n            ],\n            OffchainMessage: [\n                { name: \"model\", type: \"shortstring\" },\n                { name: name, type: \"Model\" },\n            ],\n            Model: [],\n        }),\n        primaryType: \"OffchainMessage\",\n        domain: {\n            name: \"Dojo\",\n            version: \"1\",\n            chainId: \"1\",\n            revision: \"1\",\n        },\n        message: {\n            model: name,\n            [name]: Object.fromEntries(\n                Object.entries(model).map(([k, v]) => {\n                    if (typeof v === \"bigint\") {\n                        return [k, \"0x\" + v.toString(16)];\n                    }\n\n                    return [k, v];\n                })\n            ),\n        },\n    };\n};\n","import { IWorld } from \"../types\";\n\n/**\n * Provider class: An abstract base class for all providers.\n * It implements the ICommands interface, ensuring that any class deriving from Provider\n * will have implementations for the entity and entities methods.\n */\nexport abstract class Provider implements IWorld {\n    // Store the address of the world.\n    private readonly worldAddress: string;\n\n    /**\n     * Constructor: Initializes the Provider with a given world address.\n     *\n     * @param {string} worldAddress - The address of the world.\n     */\n    constructor(worldAddress: string) {\n        this.worldAddress = worldAddress;\n    }\n\n    /**\n     * Abstract method to retrieve a single entity's details.\n     * Classes extending Provider should provide a concrete implementation for this method.\n     *\n     * @param {string} component - The component to query.\n     * @param {Query} query - The query details.\n     * @param {number} offset - Starting offset.\n     * @param {number} length - Length to retrieve.\n     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.\n     */\n    public abstract entity(\n        model: string,\n        keys: Array<string>,\n        offset: number,\n        length: number,\n        layout: Array<number>\n    ): Promise<Array<bigint>>;\n\n    /**\n     * Abstract method to retrieve multiple entities' details.\n     * Classes extending Provider should provide a concrete implementation for this method.\n     *\n     * @param {string} component - The component to query.\n     * @param {number} length - Number of entities to retrieve.\n     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entities' details.\n     */\n    public abstract entities(\n        model: string,\n        index: string | null,\n        values: Array<string>,\n        valuesLength: number,\n        valuesLayout: Array<number>\n    ): Promise<Array<Array<bigint>>>;\n\n    /**\n     * Retrieves the stored world address.\n     *\n     * @returns {string} - The address of the world.\n     */\n    public getWorldAddress(): string {\n        return this.worldAddress;\n    }\n}\n","import {\n    KATANA_CLASS_HASH,\n    KATANA_ETH_CONTRACT_ADDRESS,\n    KATANA_PREFUNDED_ADDRESS,\n    KATANA_PREFUNDED_PRIVATE_KEY,\n    LOCAL_KATANA,\n    LOCAL_TORII,\n} from \"../constants\";\n\nexport type DojoConfig = ReturnType<typeof createDojoConfig>;\n\ninterface DojoConfigParams {\n    rpcUrl?: string;\n    toriiUrl?: string;\n    masterAddress?: string;\n    masterPrivateKey?: string;\n    accountClassHash?: string;\n    feeTokenAddress?: string;\n    manifest: any;\n}\n\n/**\n * Create Dojo Config: Creates a Dojo Config object. If no parameters are passed, it will use the default values of the current Dojo version.\n */\nexport function createDojoConfig({ manifest, ...config }: DojoConfigParams) {\n    return {\n        rpcUrl: config.rpcUrl ?? LOCAL_KATANA,\n        toriiUrl: config.toriiUrl ?? LOCAL_TORII,\n        masterAddress: config.masterAddress ?? KATANA_PREFUNDED_ADDRESS,\n        masterPrivateKey:\n            config.masterPrivateKey ?? KATANA_PREFUNDED_PRIVATE_KEY,\n        accountClassHash: config.accountClassHash ?? KATANA_CLASS_HASH,\n        feeTokenAddress: config.feeTokenAddress ?? KATANA_ETH_CONTRACT_ADDRESS,\n        manifest: {\n            ...manifest,\n            world: { ...manifest.world, abi: manifest.abis },\n        },\n    };\n}\n","import { z } from \"zod\";\n\nconst abiItem = z.union([\n    z.object({\n        type: z.literal(\"impl\"),\n        name: z.string(),\n        interface_name: z.string(),\n    }),\n    z.object({\n        type: z.literal(\"struct\"),\n        name: z.string(),\n        members: z.array(z.object({ name: z.string(), type: z.string() })),\n    }),\n    z.object({\n        type: z.literal(\"enum\"),\n        name: z.string(),\n        variants: z.array(z.object({ name: z.string(), type: z.string() })),\n    }),\n    z.object({\n        type: z.literal(\"interface\"),\n        name: z.string(),\n        items: z.array(\n            z.object({\n                type: z.literal(\"function\"),\n                name: z.string(),\n                inputs: z.array(\n                    z.object({ name: z.string(), type: z.string() })\n                ),\n                outputs: z.array(z.object({ type: z.string() })),\n                state_mutability: z.string(),\n            })\n        ),\n    }),\n    z.object({\n        type: z.literal(\"constructor\"),\n        name: z.string(),\n        inputs: z.array(z.object({ name: z.string(), type: z.string() })),\n    }),\n    z.object({\n        type: z.literal(\"event\"),\n        name: z.string(),\n        kind: z.literal(\"struct\"),\n        members: z.array(\n            z.object({ name: z.string(), type: z.string(), kind: z.string() })\n        ),\n    }),\n    z.object({\n        type: z.literal(\"event\"),\n        name: z.string(),\n        kind: z.literal(\"enum\"),\n        variants: z.array(\n            z.object({ name: z.string(), type: z.string(), kind: z.string() })\n        ),\n    }),\n]);\n\nconst generalFields = z.object({\n    class_hash: z.string(),\n    name: z.string(),\n    abi: z.array(abiItem),\n});\n\nconst world = generalFields.extend({\n    kind: z.literal(\"WorldContract\"),\n    address: z.string(),\n    transaction_hash: z.string(),\n    block_number: z.number(),\n    seed: z.string(),\n    metadata: z.object({\n        rpc_url: z.string(),\n    }),\n});\n\nconst base = generalFields.extend({\n    kind: z.literal(\"Class\"),\n    abi: z.literal(null),\n});\n\nconst contract = generalFields.extend({\n    kind: z.literal(\"DojoContract\"),\n    address: z.string(),\n    reads: z.array(z.unknown()),\n    writes: z.array(z.unknown()),\n    computed: z.array(z.unknown()),\n});\n\nconst model = generalFields.extend({\n    kind: z.literal(\"DojoModel\"),\n    members: z.array(\n        z.object({\n            name: z.string(),\n            type: z.string(),\n            key: z.boolean(),\n        })\n    ),\n});\n\nconst manifestSchema = z.object({\n    world: world,\n    base,\n    contracts: z.array(contract),\n    models: z.array(model),\n});\n\nexport type Manifest = z.infer<typeof manifestSchema>;\n\nexport const createManifestFromJson = (content: any): Manifest => {\n    try {\n        return manifestSchema.parse(content);\n    } catch (error) {\n        console.error(error);\n        throw new Error(\"Invalid Dojo manifest.json\");\n    }\n};\n"],"mappings":"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","names":["WorldEntryPoints","contract","model","name","model","contract"]}