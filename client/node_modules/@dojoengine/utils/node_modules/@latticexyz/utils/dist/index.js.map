{"version":3,"sources":["../src/arrays.ts","../src/deferred.ts","../src/mobx.ts","../src/guards.ts","../src/proxy.ts","../src/enums.ts","../src/objects.ts","../src/random.ts","../src/rx.ts","../src/uuid.ts","../src/sleep.ts","../src/promise.ts","../src/iterable.ts","../src/area.ts","../src/worker.ts","../src/pack.ts","../src/CoordMap.ts","../src/VoxelCoordMap.ts","../src/eth.ts","../src/cubic.ts","../src/console.ts","../src/distance.ts","../src/math.ts","../src/v2/arrayToHex.ts","../src/v2/bytesToString.ts","../src/v2/isHex.ts","../src/v2/hexToArray.ts","../src/v2/stringToBytes.ts","../src/bytes.ts"],"sourcesContent":["/**\n * TypeScript type guard to assert the type of a non-empty array\n * @param array Any array to check for non-emptiness\n * @returns True if the empty is non-empty, else false. TypeScript accepts the array as non-empty after the assertion.\n */\nexport function isNotEmpty<T>(array: T[]): array is [T, ...T[]] {\n  if (array.length === 0) return false;\n  return true;\n}\n\n/**\n * Filters undefined values from an array and lets TypeScript know the resulting array\n * does not have undefined values\n * @param array Array potentially including undefined values\n * @returns Array without undefined values\n */\nexport function filterNullishValues<T>(array: (T | undefined)[]): T[] {\n  return array.filter((value) => value != null) as T[];\n}\n","/**\n * A convenient way to create a promise with resolve and reject functions.\n * @returns Tuple with resolve function, reject function and promise.\n */\nexport function deferred<T>(): [(t: T) => void, (t: Error) => void, Promise<T>] {\n  let resolve: ((t: T) => void) | null = null;\n  let reject: ((t: Error) => void) | null = null;\n  const promise = new Promise<T>((r, rj) => {\n    resolve = (t: T) => r(t);\n    reject = (e: Error) => rj(e);\n  });\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return [resolve as any, reject as any, promise];\n}\n","import { IComputedValue, IObservableValue, reaction } from \"mobx\";\nimport { deferred } from \"./deferred\";\n\n/**\n * @param comp Computed/Observable value that is either defined or undefined\n * @returns promise that resolves with the first truthy computed value\n */\nexport async function awaitValue<T>(comp: IComputedValue<T | undefined> | IObservableValue<T | undefined>): Promise<T> {\n  const [resolve, , promise] = deferred<T>();\n\n  const dispose = reaction(\n    () => comp.get(),\n    (value) => {\n      if (value) {\n        resolve(value);\n      }\n    },\n    { fireImmediately: true },\n  );\n\n  const value = await promise;\n  // Dispose the reaction once the promise is resolved\n  dispose();\n\n  return value;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Func } from \"./types\";\n\nexport function isObject(c: unknown): c is Record<string, any> {\n  return typeof c === \"object\" && !Array.isArray(c) && c !== null;\n}\n\nexport function isFunction(c: unknown): c is Func<any, any> {\n  return c instanceof Function;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { IComputedValue, IObservableValue, reaction } from \"mobx\";\nimport DeepProxy from \"proxy-deep\";\nimport { deferred } from \"./deferred\";\nimport { isFunction, isObject } from \"./guards\";\nimport { Cached } from \"./types\";\n\nfunction deepAccess(target: Record<string, unknown>, path: string[]): any {\n  if (path.length === 0) return target;\n  if (path.length === 1) return target[path[0]];\n  const [next, ...rest] = path;\n  const nextTarget = target[next];\n  if (!isObject(nextTarget)) throw new Error(\"Path does not exist on the target\");\n  return deepAccess(nextTarget, rest);\n}\n\n/**\n * Caches any function calls to the target until the target is ready.\n * @param target T extends Cachable\n * @returns Cached<T>\n */\nexport function cacheUntilReady<T extends Record<string, any>>(\n  target: IObservableValue<T | undefined> | IComputedValue<T | undefined>,\n): Cached<T> {\n  // The call queue contains the path and arguments of calls to the\n  // proxiedTarget while the target was not available yet.\n  // It also contains resolve and reject methods to fulfil the promise\n  // returned when calling the proxiedTarget once the target becomes available.\n  const callQueue: {\n    path: string[];\n    args?: any[];\n    resolve: (result: any) => void;\n    reject: (e: Error) => void;\n  }[] = [];\n\n  // The proxiedTarget proxies all calls to the target.\n  // If a function is called on the proxiedTarget while the target is not\n  // available, a promise is returned and the call will be stored in the callQueue\n  // until the target becomes available and the promise is fulfilled.\n  const proxiedTarget = new DeepProxy(\n    {},\n    {\n      get(_t, prop) {\n        const targetReady = target.get();\n        if (targetReady) {\n          // If the target is ready, relay all calls directly to the target\n          // (Except for the \"proxied\" key, which indicates whether the object is currently proxied)\n          if (prop === \"proxied\") return false;\n          return Reflect.get(targetReady, prop);\n        } else {\n          // Note: if the target is not available, accessing a property returns another proxy,\n          // not a Promise. It is possible to check whether a value is currently proxied using the proxied key.\n          if (prop === \"proxied\") return true;\n          if (prop === \"name\") return \"ProxiedTarget\";\n          if (prop === \"toJSON\") return () => ({ proxied: true });\n          return this.nest(() => void 0);\n        }\n      },\n      apply(_, thisArg, args) {\n        const targetReady = target.get();\n        if (targetReady) {\n          // If the target is ready, relay all calls directly to the target\n          const targetFunc = deepAccess(targetReady, this.path);\n          if (!isFunction(targetFunc)) throw new Error(\"Target is not callable\");\n          return Reflect.apply(targetFunc, thisArg, args);\n        } else {\n          // Otherwise store the call and relay it to the target later once it's ready.\n          // The return value of this call is a promise, that gets resolved once the target is ready.\n          const [resolve, reject, promise] = deferred();\n          callQueue.push({ path: this.path, args, resolve, reject });\n          return promise;\n        }\n      },\n    },\n  );\n\n  reaction(\n    () => target.get(),\n    (targetReady) => {\n      if (!targetReady) return;\n      // Move all entries from callQueue to queuedCalls\n      const queuedCalls = callQueue.splice(0);\n      for (const { path, args, resolve, reject } of queuedCalls) {\n        const target = deepAccess(targetReady, path);\n        if (args && isFunction(target)) {\n          (async () => {\n            try {\n              resolve(await target(...args));\n            } catch (e: any) {\n              reject(e);\n            }\n          })();\n        } else {\n          resolve(target);\n        }\n      }\n    },\n  );\n\n  return proxiedTarget as Cached<T>;\n}\n","/**\n * @param enm Numeric enum\n * @returns Number array containing the enum values\n */\nexport function numValues(enm: object): number[] {\n  const nums: number[] = [];\n  for (const val of Object.values(enm)) {\n    if (!isNaN(Number(val))) {\n      nums.push(Number(val));\n    }\n  }\n  return nums;\n}\n","/**\n * Utility function to map a source object to an object with the same keys but mapped values\n * @param source Source object to be mapped\n * @param valueMap Mapping values of the source object to values of the target object\n * @returns An object with the same keys as the source object but mapped values\n */\nexport function mapObject<S extends { [key: string]: unknown }, T extends { [key in keyof S]: unknown }>(\n  source: S,\n  valueMap: (value: S[keyof S], key: keyof S) => T[keyof S],\n): T {\n  const target: Partial<{ [key in keyof typeof source]: T[keyof S] }> = {};\n  for (const key in source) {\n    target[key] = valueMap(source[key], key);\n  }\n  return target as T;\n}\n","/**\n *\n * @param to Upper bound (included)\n * @param from Lower bound (included). Default 0.\n * @returns A random integer between from and to.\n */\nexport function random(to: number, from = 0): number {\n  return Math.floor(Math.random() * (to - from + 1)) + from;\n}\n\n/**\n * @param array Array to pick a random element from.\n * @returns Random element from the given array.\n */\nexport function pickRandom<T>(array: [T, ...T[]]): T {\n  return array[random(array.length - 1)];\n}\n","import {\n  concatMap,\n  delay,\n  filter,\n  first,\n  mergeMap,\n  Observable,\n  of,\n  OperatorFunction,\n  pipe,\n  ReplaySubject,\n  scan,\n  Timestamp,\n  timestamp,\n} from \"rxjs\";\nimport { computed, IComputedValue, IObservableValue, observable, reaction, runInAction, toJS } from \"mobx\";\nimport { deferred } from \"./deferred\";\nimport { awaitValue } from \"./mobx\";\n\nexport function filterNullish<T>(): OperatorFunction<T, NonNullable<T>> {\n  return pipe<Observable<T>, Observable<NonNullable<T>>>(\n    filter<T>((x: T) => x != null) as OperatorFunction<T, NonNullable<T>>,\n  );\n}\n\nexport function awaitPromise<T extends Promise<unknown>>(): OperatorFunction<T, Awaited<T>> {\n  return pipe(concatMap((x: T) => x)) as OperatorFunction<T, Awaited<T>>;\n}\n\n/**\n * RxJS operator to stretch out an event stream by a given delay per event\n * @param spacingDelayMs Delay between each event in ms\n * @returns stream of events with at least spacingDelayMs spaceing between event\n */\nexport function stretch<T>(spacingDelayMs: number) {\n  return pipe(\n    timestamp<T>(),\n    scan((acc: (Timestamp<T> & { delay: number }) | null, curr: Timestamp<T>) => {\n      // calculate delay needed to offset next emission\n      let delay = 0;\n      if (acc !== null) {\n        const timeDelta = curr.timestamp - acc.timestamp;\n        delay = timeDelta > spacingDelayMs ? 0 : spacingDelayMs - timeDelta;\n      }\n\n      return {\n        timestamp: curr.timestamp,\n        delay: delay,\n        value: curr.value,\n      };\n    }, null),\n    filterNullish(),\n    mergeMap((i) => of(i.value).pipe(delay(i.delay)), 1),\n  );\n}\n\nexport function observableToComputed<T>(obs: IObservableValue<T>): IComputedValue<T> {\n  return computed(() => obs.get());\n}\n\nexport function computedToStream<T>(comp: IComputedValue<T> | IObservableValue<T>): Observable<T> {\n  const stream = new ReplaySubject<T>(1);\n  reaction(\n    () => comp.get(),\n    (value) => {\n      if (value != null) stream.next(value);\n    },\n    { fireImmediately: true },\n  );\n  return stream;\n}\n\nexport function observableToStream<T>(obs: T): Observable<T> {\n  const stream = new ReplaySubject<T>(1);\n  reaction(\n    () => toJS(obs),\n    (value) => {\n      if (value != null) stream.next(value);\n    },\n    { fireImmediately: true },\n  );\n  return stream;\n}\n\nexport function streamToComputed<T>(stream$: Observable<T>): IComputedValue<T | undefined> {\n  const value = observable.box<T | undefined>();\n  stream$.subscribe((val) => runInAction(() => value.set(val)));\n  return computed(() => value.get());\n}\n\nexport async function streamToDefinedComputed<T>(stream$: Observable<T>): Promise<IComputedValue<T>> {\n  const value = observable.box<T>();\n  stream$.subscribe((val) => runInAction(() => value.set(val)));\n  const computedValue = computed(() => value.get());\n  await awaitValue(computedValue);\n  return computedValue as IComputedValue<T>;\n}\n\n/**\n *\n * @param stream$ RxJS observable to check for the given value\n * @param predicate Predicate to check\n * @returns A promise that resolves with the requested value once the predicate is true\n */\nexport async function awaitStreamValue<T>(\n  stream$: Observable<T>,\n  predicate: (value: T) => boolean = (value) => value != null,\n): Promise<T> {\n  const [resolve, , promise] = deferred<T>();\n  stream$.pipe(first(predicate)).subscribe(resolve);\n  return promise;\n}\n\n/**\n * Turns a stream into an updating object for easy access outside of rxjs\n * @param stream$ Stream to turn into a wrapped value\n * @returns Object with `current` key corresponding to last stream value\n */\nexport async function streamToWrappedValue<T>(stream$: Observable<T>): Promise<{ current: T }> {\n  const value: { current?: T } = {};\n  stream$.subscribe((v) => (value.current = v));\n  value.current = await awaitStreamValue(stream$);\n  return value as { current: T };\n}\n","/**\n * UUID.core.js - UUID.js for Minimalists\n *\n * @file\n * @author  LiosK\n * @version v4.2.0\n * @license Apache License 2.0: Copyright (c) 2010-2018 LiosK\n * @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js\n */\n\n/**\n * @class\n * @classdesc {@link UUID} object.\n * @hideconstructor\n */\n\n// Core Component {{{\n\n/**\n * Generates a version 4 UUID as a hexadecimal string.\n * @returns {string} Hexadecimal UUID string.\n */\nexport const uuid = function () {\n  const rand = _getRandomInt,\n    hex = _hexAligner;\n  return (\n    hex(rand(32), 8) + // time_low\n    \"-\" +\n    hex(rand(16), 4) + // time_mid\n    \"-\" +\n    hex(0x4000 | rand(12), 4) + // time_hi_and_version\n    \"-\" +\n    hex(0x8000 | rand(14), 4) + // clock_seq_hi_and_reserved clock_seq_low\n    \"-\" +\n    hex(rand(48), 12)\n  ); // node\n};\n\n/**\n * Returns an unsigned x-bit random integer.\n * @private\n * @param {number} x Unsigned integer ranging from 0 to 53, inclusive.\n * @returns {number} Unsigned x-bit random integer (0 <= f(x) < 2^x).\n */\nconst _getRandomInt = function (x: number) {\n  if (x < 0 || x > 53) {\n    return NaN;\n  }\n  const n = 0 | (Math.random() * 0x40000000); // 1 << 30\n  return x > 30 ? n + (0 | (Math.random() * (1 << (x - 30)))) * 0x40000000 : n >>> (30 - x);\n};\n\n/**\n * Converts an integer to a zero-filled hexadecimal string.\n * @private\n * @param {number} num\n * @param {number} length\n * @returns {string}\n */\nconst _hexAligner = function (num: number, length: number) {\n  let str = num.toString(16),\n    i = length - str.length,\n    z = \"0\";\n  for (; i > 0; i >>>= 1, z += z) {\n    if (i & 1) {\n      str = z + str;\n    }\n  }\n  return str;\n};\n","export function sleep<T>(timeout: number, returns?: T): Promise<T> {\n  return new Promise<T>((resolve) => setTimeout(() => resolve(returns as T), timeout));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { deferred } from \"./deferred\";\nimport { sleep } from \"./sleep\";\n\nexport const range = function* (total = 0, step = 1, from = 0) {\n  // eslint-disable-next-line no-empty\n  for (let i = 0; i < total; yield from + i++ * step) {}\n};\n\nexport async function rejectAfter<T>(ms: number, msg: string): Promise<T> {\n  await sleep(ms);\n  throw new Error(msg);\n}\n\nexport const timeoutAfter = async <T>(promise: Promise<T>, ms: number, timeoutMsg: string) => {\n  return Promise.race([promise, rejectAfter<T>(ms, timeoutMsg)]);\n};\n\nexport const callWithRetry = <T>(\n  fn: (...args: any[]) => Promise<T>,\n  args: any[] = [],\n  maxRetries = 10,\n  retryInterval = 1000,\n): Promise<T> => {\n  const [resolve, reject, promise] = deferred<T>();\n  const process = async () => {\n    let res: T;\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        res = await fn(...args);\n        resolve(res);\n        break;\n      } catch (e) {\n        if (i < maxRetries - 1) {\n          console.info(\"[CallWithRetry Failed] attempt number=\" + i, fn);\n          console.error(e);\n          await sleep(Math.min(retryInterval * 2 ** i + Math.random() * 100, 15000));\n        } else {\n          reject(e as unknown as Error);\n        }\n      }\n    }\n  };\n  process();\n  return promise;\n};\n","export function makeIterable<T>(iterator: Iterator<T>): IterableIterator<T> {\n  const iterable: IterableIterator<T> = {\n    ...iterator,\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n\n  return iterable;\n}\n\nexport function concatIterators<T>(first: Iterator<T>, second?: Iterator<T>): IterableIterator<T> {\n  if (!second) return makeIterable(first);\n  return makeIterable({\n    next() {\n      const next = first.next();\n      if (!next.done) return next;\n      return second.next();\n    },\n  });\n}\n\nexport function mergeIterators<A, B>(iteratorA: Iterator<A>, iteratorB: Iterator<B>): IterableIterator<[A, B]> {\n  const iterator: Iterator<[A, B]> = {\n    next() {\n      const nextA = iteratorA.next();\n      const nextB = iteratorB.next();\n      if (nextA.done && nextB.done) return { done: true, value: null };\n      return { value: [nextA.value, nextB.value] };\n    },\n  };\n  return makeIterable(iterator);\n}\n\nexport function transformIterator<A, B>(iterator: Iterator<A>, transform: (value: A) => B): IterableIterator<B> {\n  return makeIterable({\n    next() {\n      const { done, value } = iterator.next();\n      return { done, value: done ? value : transform(value) };\n    },\n  });\n}\n\n/**\n * Turns an array into an iterator. NOTE: an iterator can only be iterated once.\n * @param array Array to be turned into an iterator\n * @returns Iterator to iterate through the array\n */\nexport function arrayToIterator<T>(array: T[]): IterableIterator<T> {\n  let i = 0;\n  const iterator: Iterator<T> = {\n    next() {\n      const done = i >= array.length;\n      if (done) return { done, value: null };\n      return { value: array[i++] };\n    },\n  };\n  return makeIterable(iterator);\n}\n","import { Area, Coord } from \"./types\";\n\nexport function areaContains(area: Area, coord: Coord) {\n  return coord.x >= area.x && coord.y >= area.y && coord.x < area.x + area.width && coord.y < area.y + area.height;\n}\n\nexport function coordsOf(area: Area) {\n  const coords: Coord[] = [];\n  for (let dx = 0; dx < area.width; dx++) {\n    for (let dy = 0; dy < area.height; dy++) {\n      coords.push({ x: area.x + dx, y: area.y + dy });\n    }\n  }\n  return coords;\n}\n","import { fromEvent, map, Observable } from \"rxjs\";\n\nexport interface DoWork<In, Out> {\n  work(input$: Observable<In>): Observable<Out>;\n}\n\nexport function fromWorker<I, O>(worker: Worker, input$: Observable<I>): Observable<O> {\n  input$.subscribe((event) => worker.postMessage(event));\n  return fromEvent<MessageEvent<O>>(worker, \"message\").pipe(map((e) => e.data));\n}\n\nexport function runWorker<I, O>(worker: DoWork<I, O>) {\n  const input$ = fromEvent<MessageEvent<I>>(self, \"message\");\n  const output$ = worker.work(input$.pipe(map((event) => event.data)));\n  output$.subscribe((event) => self.postMessage(event));\n}\n","function rightMask(input: number, keep: number): number {\n  return input & (2 ** keep - 1);\n}\n\n/**\n * Packs two unsigned integers in one 32 bit unsigned integer\n * @param numbers Unsigned integers to be packed in 32 bit integer\n * @param bitsPerNumber Bits for each number\n * @returns Packed 32 bit unsigned integer\n */\nexport function pack(numbers: number[], bitsPerNumber: number[]): number {\n  // Total number of bits must be 32\n  if (bitsPerNumber.reduce((acc, curr) => acc + curr, 0) > 32) {\n    throw new Error(\"JS pretends integers are 32 bit when bitshifts are involved\");\n  }\n\n  // Array lengths must match\n  if (numbers.length !== bitsPerNumber.length) throw new Error(\"Arrays' lengths must match\");\n\n  // Numbers must fit in number of bits and must be unsigned\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < 0) {\n      throw new Error(\"Underflow: can only pack unsigned integer\");\n    }\n    if (numbers[i] > 2 ** bitsPerNumber[i] - 1) {\n      const error = `Overflow: ${numbers[i]} does not fit in ${bitsPerNumber[i]} bits`;\n      throw new Error(error);\n    }\n  }\n\n  // Pack number\n  let packed = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    packed = (packed << bitsPerNumber[i]) | numbers[i];\n  }\n  return packed;\n}\n\n/**\n * Unpacks a packed 32 bit unsigned integer into the original unsigned integers\n * @param packed Packed 32 bit unsigned integer\n * @param bitsPerNumber Bits for each unsigned integer\n * @returns Array of unpacked unsignd integers\n */\nexport function unpack(packed: number, bitsPerNumber: number[]): number[] {\n  const numbers: number[] = [];\n  let shiftedPacked = packed;\n  for (let i = bitsPerNumber.length - 1; i >= 0; i--) {\n    numbers.unshift(rightMask(shiftedPacked, bitsPerNumber[i]));\n    shiftedPacked = shiftedPacked >>> bitsPerNumber[i];\n  }\n  return numbers;\n}\n\nexport function packTuple(numbers: [number, number]): number {\n  return pack(numbers, [8, 24]);\n}\n\nexport function unpackTuple(packed: number): [number, number] {\n  return unpack(packed, [8, 24]) as [number, number];\n}\n","import { Coord } from \"./types\";\nimport { transformIterator } from \"./iterable\";\n\nconst LOWER_HALF_MASK = 2 ** 16 - 1;\nconst MAX_SUPPORTED = 2 ** 15 - 1;\n\nexport function subtract(from: CoordMap<boolean>, subtract: CoordMap<boolean>): CoordMap<boolean> {\n  const result = new CoordMap<boolean>();\n\n  for (const coord of from.coords()) {\n    if (subtract.get(coord)) continue;\n    result.set(coord, true);\n  }\n\n  return result;\n}\n\nexport function coordToKey(coord: Coord) {\n  const key = (coord.x << 16) | (coord.y & LOWER_HALF_MASK);\n  return key;\n\n  // Old version using strings:\n  // return `${coord.x}/${coord.y}`;\n}\n\nexport function keyToCoord(key: number): Coord {\n  const x = key >> 16;\n  const y = (key << 16) >> 16;\n  return { x, y };\n\n  // Old version using strings:\n  // const fragments = key.split(\"/\");\n  // return { x: Number(fragments[0]), y: Number(fragments[1]) };\n}\n\nexport class CoordMap<T> {\n  map: Map<number, T>;\n  defaultValue?: T;\n\n  constructor(props?: { defaultValue?: T }) {\n    this.map = new Map<number, T>();\n    this.defaultValue = props?.defaultValue;\n  }\n\n  static from<T>(coordMapLike: { map: Map<number, T>; defaultValue?: T }): CoordMap<T> {\n    const coordMap = new CoordMap<T>();\n    coordMap.map = coordMapLike.map;\n    coordMap.defaultValue = coordMapLike.defaultValue;\n    return coordMap;\n  }\n\n  set(coord: Coord, value: T) {\n    if (\n      coord.x > MAX_SUPPORTED ||\n      coord.x < -1 * MAX_SUPPORTED ||\n      coord.y > MAX_SUPPORTED ||\n      coord.y < -1 * MAX_SUPPORTED\n    ) {\n      throw new Error(`CoordMap only supports coords up to ${MAX_SUPPORTED}`);\n    }\n    return this.map.set(coordToKey(coord), value);\n  }\n\n  get(coord: Coord) {\n    return this.map.get(coordToKey(coord)) ?? this.defaultValue;\n  }\n\n  keys() {\n    return this.map.keys();\n  }\n\n  coords(): IterableIterator<Coord> {\n    return transformIterator(this.map.keys(), (key) => keyToCoord(key));\n  }\n\n  entries() {\n    return this.map.entries();\n  }\n\n  toArray(): [Coord, T][] {\n    const entries = Array.from(this.map.entries());\n    return entries.map(([key, value]) => [keyToCoord(key), value]);\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  delete(coord: Coord) {\n    return this.map.delete(coordToKey(coord));\n  }\n\n  has(coord: Coord): boolean {\n    return this.map.has(coordToKey(coord));\n  }\n\n  clear() {\n    for (const key of this.map.keys()) {\n      this.map.delete(key);\n    }\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n}\n","import { VoxelCoord } from \"./types\";\nimport { transformIterator } from \"./iterable\";\n\nfunction coordToKey(coord: VoxelCoord) {\n  // TODO: find a more memory efficient way to store these keys\n  return `${coord.x}/${coord.y}/${coord.z}`;\n}\n\nfunction keyToCoord(key: string): VoxelCoord {\n  const fragments = key.split(\"/\");\n  return { x: Number(fragments[0]), y: Number(fragments[1]), z: Number(fragments[2]) };\n}\n\nexport class VoxelCoordMap<T> {\n  map: Map<string, T>;\n  defaultValue?: T;\n\n  constructor(props?: { defaultValue?: T }) {\n    this.map = new Map<string, T>();\n    this.defaultValue = props?.defaultValue;\n  }\n\n  static from<T>(coordMapLike: { map: Map<string, T>; defaultValue?: T }): VoxelCoordMap<T> {\n    const coordMap = new VoxelCoordMap<T>();\n    coordMap.map = coordMapLike.map;\n    coordMap.defaultValue = coordMapLike.defaultValue;\n    return coordMap;\n  }\n\n  set(coord: VoxelCoord, value: T) {\n    return this.map.set(coordToKey(coord), value);\n  }\n\n  get(coord: VoxelCoord) {\n    return this.map.get(coordToKey(coord)) ?? this.defaultValue;\n  }\n\n  keys() {\n    return this.map.keys();\n  }\n\n  coords(): IterableIterator<VoxelCoord> {\n    return transformIterator(this.map.keys(), (key) => keyToCoord(key));\n  }\n\n  entries() {\n    return this.map.entries();\n  }\n\n  toArray(): [VoxelCoord, T][] {\n    const entries = Array.from(this.map.entries());\n    return entries.map(([key, value]) => [keyToCoord(key), value]);\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  delete(coord: VoxelCoord) {\n    return this.map.delete(coordToKey(coord));\n  }\n\n  has(coord: VoxelCoord): boolean {\n    return this.map.has(coordToKey(coord));\n  }\n\n  clear() {\n    for (const key of this.map.keys()) {\n      this.map.delete(key);\n    }\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n}\n","/**\n * Pads start of a hex string with 0 to create a bit string of the given length\n * @param input Hex string\n * @param bits Number of bits in the output hex string\n * @returns Hex string of specified length\n */\nexport function padToBitLength(input: string, bits: number) {\n  // Cut off 0x prefix\n  if (input.substring(0, 2) == \"0x\") input = input.substring(2);\n  // Pad start with 0 to get desired bit length\n  const length = bits / 4;\n  input = input.padStart(length, \"0\");\n  input = input.substring(input.length - length);\n  // Prefix with 0x\n  return `0x${input}`;\n}\n\n/**\n * Pads start of a hex string with 0 to create a 160 bit hex string\n * which can be used as an Ethereum address\n * @param input Hex string\n * @returns 160 bit hex string\n */\nexport function toEthAddress(input: string) {\n  return padToBitLength(input, 160);\n}\n\n/**\n * Pads start of a hex string with 0 to create a 256bit hex string\n * which can be used as an Ethereum address\n * @param input Hex string\n * @returns 256 bit hex string\n */\nexport function to256BitString(input: string) {\n  return padToBitLength(input, 256);\n}\n\nexport function extractEncodedArguments(input: string) {\n  // Cutting off the first 4 bytes, which represent the function selector\n  if (input[0] !== \"0\" && input[1] !== \"x\") throw new Error(\"Invalid hex string\");\n  return \"0x\" + input.substring(10);\n}\n","const RND_A = 134775813;\nconst RND_B = 1103515245;\nconst ACCURACY = 1000;\n\nexport function randomize(seed: number, x: number, y: number) {\n  return (((((x ^ y) * RND_A) ^ (seed + x)) * (((RND_B * x) << 16) ^ (RND_B * y - RND_A))) >>> 0) / 4294967295;\n}\n\nexport function tile(coordinate: number, period: number) {\n  if (coordinate < 0) while (coordinate < 0) coordinate += period;\n  return coordinate % period;\n}\n\nexport function interpolate(a: number, b: number, c: number, d: number, x: number, s: number, scale: number) {\n  const p = d - c - (a - b);\n  return (b * Math.pow(s, 3) + x * (c * Math.pow(s, 2) + a * s * (-s + x) + x * (-(b + p) * s + p * x))) * scale;\n\n  // return (x) * ((x ) * ((x ) * p + (a - b - p)) + (c - a)) + b;\n}\n\n/**\n * Config a cubic noise.\n * @param {Number} seed A seed in the range [0, 1].\n * @param {Number} [periodX] The number of units after which the x coordinate repeats.\n * @param {Number} [periodY] The number of units after which the y coordinate repeats.\n * @returns {Object} A configuration object used by noise functions.\n */\nexport function cubicNoiseConfig(\n  seed: number,\n  octave: number,\n  scale: number,\n  periodX = Number.MAX_SAFE_INTEGER,\n  periodY = Number.MAX_SAFE_INTEGER,\n) {\n  return {\n    seed: Math.floor(seed * Number.MAX_SAFE_INTEGER),\n    periodX: periodX,\n    periodY: periodY,\n    octave,\n    scale,\n  };\n}\n\n/**\n * Sample 1D cubic noise.\n * @param {Object} config A valid noise configuration.\n * @param {Number} x The X position to sample at.\n * @returns {Number} A noise value in the range [0, 1].\n */\nexport function cubicNoiseSample1(config: ReturnType<typeof cubicNoiseConfig>, x: number) {\n  const xi = Math.floor(x);\n  const lerp = x - xi;\n\n  return (\n    interpolate(\n      randomize(config.seed, tile(xi - 1, config.periodX), 0),\n      randomize(config.seed, tile(xi, config.periodX), 0),\n      randomize(config.seed, tile(xi + 1, config.periodX), 0),\n      randomize(config.seed, tile(xi + 2, config.periodX), 0),\n      lerp,\n      1,\n      1,\n    ) *\n      0.666666 +\n    0.166666\n  );\n}\n\n/**\n * Sample 2D cubic noise.\n * @param {Object} config A valid noise configuration.\n * @param {Number} x The X position to sample at.\n * @param {Number} y The Y position to sample at.\n * @returns {Number} A noise value in the range [0, 1].\n */\nexport function cubicNoiseSample2(\n  { octave, periodX, periodY, seed, scale }: ReturnType<typeof cubicNoiseConfig>,\n  x: number,\n  y: number,\n) {\n  const xi = Math.floor(x / octave);\n  const lerpX = Math.floor((x * ACCURACY) / octave) - xi * ACCURACY;\n  const yi = Math.floor(y / octave);\n  const lerpY = Math.floor((y * ACCURACY) / octave) - yi * ACCURACY;\n  const x0 = tile(xi - 1, periodX);\n  const x1 = tile(xi, periodX);\n  const x2 = tile(xi + 1, periodX);\n  const x3 = tile(xi + 2, periodX);\n\n  const xSamples = new Array(4);\n\n  for (let i = 0; i < 4; ++i) {\n    const y = tile(yi - 1 + i, periodY);\n\n    xSamples[i] = interpolate(\n      randomize(seed, x0, y),\n      randomize(seed, x1, y),\n      randomize(seed, x2, y),\n      randomize(seed, x3, y),\n      lerpX,\n      ACCURACY,\n      1,\n    );\n  }\n\n  return Math.floor(\n    interpolate(xSamples[0], xSamples[1], xSamples[2], xSamples[3], lerpY, ACCURACY, scale) / Math.pow(ACCURACY, 6),\n  );\n}\n","const TOPICS_KEY = \"mud-logger-topics\";\n\nexport function enableLogger() {\n  const windowConsole = window.console;\n  let filtersActive = Boolean(localStorage.getItem(TOPICS_KEY));\n\n  const topicsString = localStorage.getItem(TOPICS_KEY);\n  let topics: string[] = topicsString ? JSON.parse(topicsString) : [];\n\n  function log(...logs: string[]) {\n    if (filtersActive) return;\n    windowConsole.log(...logs);\n  }\n\n  function logWithTopic(topic: string, ...logs: string[]) {\n    if (!filtersActive || topics.includes(topic)) {\n      windowConsole.log(`--- BETTER CONSOLE / TOPIC ${topic} ---`);\n      windowConsole.log(...logs);\n    }\n  }\n\n  function enableFilters() {\n    localStorage.setItem(TOPICS_KEY, JSON.stringify([]));\n    filtersActive = true;\n  }\n\n  function disableFilters() {\n    localStorage.removeItem(TOPICS_KEY);\n    filtersActive = false;\n  }\n\n  function addTopic(topic: string) {\n    topics.push(topic);\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  function removeTopic(topic: string) {\n    topics = topics.filter((t) => t !== topic);\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  function resetTopics() {\n    topics = [];\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  const logger = {\n    ...windowConsole,\n    log,\n    logWithTopic,\n    enableFilters,\n    disableFilters,\n    addTopic,\n    removeTopic,\n    resetTopics,\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).logger = logger;\n  window.console = logger;\n  return logger;\n}\n","/**\n * Compute the Euclidean distance between two points\n * https://en.wikipedia.org/wiki/Euclidean_distance\n * @param a\n * @param b\n * @returns Euclidian distance between a and b\n */\nexport function euclidean(a: number[], b: number[]): number {\n  if (a.length !== b.length) throw new Error(\"points must have same dimension\");\n  return Math.sqrt(a.reduce((acc, _, i) => acc + Math.pow(a[i] - b[i], 2), 0));\n}\n","/**\n * For positive inputs: returns the greatest integer less than or equal to its numeric argument.\n * For negative inputs: returns the smallest integer greater than or equal to its numeric argument.\n *\n * @param x A numeric expression.\n * @returns Input rounded towards zero.\n */\nexport function roundTowardsZero(x: number) {\n  const sign = x < 0 ? -1 : 1;\n  return sign * Math.floor(Math.abs(x));\n}\n","// TODO: migrate to viem's toHex()\nexport const arrayToHex = (array: Uint8Array | ArrayBuffer): `0x${string}` =>\n  `0x${[...new Uint8Array(array)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\")}`;\n","export const bytesToString = (bytes: Uint8Array): string => [...bytes].map((x) => String.fromCharCode(x)).join(\"\");\n","// TODO: migrate to viem's isHex()\n// Note that this assumes hex pairs, but viem does not. We'll need to be careful migrating.\n// Padding an odd-length hex sounds scary (based on how Solidity left/right aligns numbers vs bytes/strings).\nexport function isHex(hex: string): boolean {\n  return /^(0x)?([\\da-f]{2})*$/i.test(hex);\n}\n","import { isHex } from \"./isHex\";\n\n// TODO: migrate to viem's toBytes(hex)\nexport const hexToArray = (hex: string): Uint8Array => {\n  if (!isHex(hex)) {\n    console.error(\"Invalid hex string\", hex);\n    throw new Error(\"Invalid hex string\");\n  }\n  const bytes = hex.match(/[\\da-f]{2}/gi);\n  if (!bytes) return new Uint8Array([]);\n  return new Uint8Array(bytes.map((byte) => parseInt(byte, 16)));\n};\n","export const stringToBytes16 = (str: string): Uint8Array => {\n  if (str.length > 16) throw new Error(\"string too long\");\n  return new Uint8Array(16).map((v, i) => str.charCodeAt(i));\n};\n\nexport const stringToBytes32 = (str: string): Uint8Array => {\n  if (str.length > 32) throw new Error(\"string too long\");\n  return new Uint8Array(32).map((v, i) => str.charCodeAt(i));\n};\n","import { toEthAddress } from \"./eth\";\nimport { hexToArray } from \"./v2\";\n\nexport function formatHex(hex: string): string {\n  if (hex.substring(0, 2) == \"0x\") hex = hex.substring(2);\n  const prefix = hex.length % 2 !== 0 ? \"0x0\" : \"0x\";\n  return prefix + hex;\n}\n\nexport function hexStringToUint8Array(hexString: string): Uint8Array {\n  return hexToArray(hexString);\n}\n\nexport function Uint8ArrayToHexString(data: Uint8Array): string {\n  if (data.length === 0) return \"0x00\";\n  return formatHex(data.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\"));\n}\n\nexport function concatUint8Arrays(...arrays: Uint8Array[]): Uint8Array {\n  return Uint8Array.from(\n    arrays.reduce<number[]>((acc, curr) => {\n      return [...acc, ...curr];\n    }, []),\n  );\n}\n\nexport function splitUint8Arrays(data: Uint8Array, byteLengths: number[]): Uint8Array[] {\n  const arrays: Uint8Array[] = [];\n  let i = 0;\n  for (const length of byteLengths) {\n    const array = new Uint8Array(length);\n    arrays.push(array);\n    for (let j = 0; j < length; j++) {\n      array[j] = data[i];\n      i++;\n    }\n  }\n  return arrays;\n}\n\nexport function Int32ArrayToUint8Array(input: number[]): Uint8Array {\n  const buffer = new ArrayBuffer(input.length * 4);\n  const int32arr = new Int32Array(buffer);\n  for (let i = 0; i < input.length; i++) {\n    int32arr[i] = input[i];\n  }\n  return new Uint8Array(buffer);\n}\n\nexport function Uint8ArrayToInt32Array(input: Uint8Array): number[] {\n  return [...new Int32Array(input.buffer)];\n}\n\nexport function ethAddressToUint8Array(address: string): Uint8Array {\n  return hexStringToUint8Array(toEthAddress(address));\n}\n\n// https://stackoverflow.com/a/55330424\nexport function createToInt(size: number) {\n  if (size < 2) {\n    throw new Error(\"Minimum size is 2\");\n  } else if (size > 64) {\n    throw new Error(\"Maximum size is 64\");\n  }\n\n  // Determine value range\n  const maxValue = 2 ** (size - 1) - 1;\n  const minValue = -maxValue - 1;\n\n  return (value: number) => {\n    value = value << 0;\n    if (value > maxValue || value < minValue) {\n      console.log(\"value\", value, maxValue, minValue, value > maxValue, value < minValue);\n      throw new Error(`Int${size} overflow`);\n    }\n\n    if (value < 0) {\n      return 2 ** size + value;\n    } else {\n      return value;\n    }\n  };\n}\n\nexport const toInt32 = createToInt(32);\n"],"mappings":"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","names":["value","reaction","reaction","target","reaction","delay","reaction","first","subtract","coordToKey","keyToCoord","y"]}