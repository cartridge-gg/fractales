// src/arrays.ts
function isNotEmpty(array) {
  if (array.length === 0) return false;
  return true;
}
function filterNullishValues(array) {
  return array.filter((value) => value != null);
}

// src/deferred.ts
function deferred() {
  let resolve = null;
  let reject = null;
  const promise = new Promise((r, rj) => {
    resolve = (t) => r(t);
    reject = (e) => rj(e);
  });
  return [resolve, reject, promise];
}

// src/mobx.ts
import { reaction } from "mobx";
async function awaitValue(comp) {
  const [resolve, , promise] = deferred();
  const dispose = reaction(
    () => comp.get(),
    (value2) => {
      if (value2) {
        resolve(value2);
      }
    },
    { fireImmediately: true }
  );
  const value = await promise;
  dispose();
  return value;
}

// src/guards.ts
function isObject(c) {
  return typeof c === "object" && !Array.isArray(c) && c !== null;
}
function isFunction(c) {
  return c instanceof Function;
}

// src/proxy.ts
import { reaction as reaction2 } from "mobx";
import DeepProxy from "proxy-deep";
function deepAccess(target, path) {
  if (path.length === 0) return target;
  if (path.length === 1) return target[path[0]];
  const [next, ...rest] = path;
  const nextTarget = target[next];
  if (!isObject(nextTarget)) throw new Error("Path does not exist on the target");
  return deepAccess(nextTarget, rest);
}
function cacheUntilReady(target) {
  const callQueue = [];
  const proxiedTarget = new DeepProxy(
    {},
    {
      get(_t, prop) {
        const targetReady = target.get();
        if (targetReady) {
          if (prop === "proxied") return false;
          return Reflect.get(targetReady, prop);
        } else {
          if (prop === "proxied") return true;
          if (prop === "name") return "ProxiedTarget";
          if (prop === "toJSON") return () => ({ proxied: true });
          return this.nest(() => void 0);
        }
      },
      apply(_, thisArg, args) {
        const targetReady = target.get();
        if (targetReady) {
          const targetFunc = deepAccess(targetReady, this.path);
          if (!isFunction(targetFunc)) throw new Error("Target is not callable");
          return Reflect.apply(targetFunc, thisArg, args);
        } else {
          const [resolve, reject, promise] = deferred();
          callQueue.push({ path: this.path, args, resolve, reject });
          return promise;
        }
      }
    }
  );
  reaction2(
    () => target.get(),
    (targetReady) => {
      if (!targetReady) return;
      const queuedCalls = callQueue.splice(0);
      for (const { path, args, resolve, reject } of queuedCalls) {
        const target2 = deepAccess(targetReady, path);
        if (args && isFunction(target2)) {
          (async () => {
            try {
              resolve(await target2(...args));
            } catch (e) {
              reject(e);
            }
          })();
        } else {
          resolve(target2);
        }
      }
    }
  );
  return proxiedTarget;
}

// src/enums.ts
function numValues(enm) {
  const nums = [];
  for (const val of Object.values(enm)) {
    if (!isNaN(Number(val))) {
      nums.push(Number(val));
    }
  }
  return nums;
}

// src/objects.ts
function mapObject(source, valueMap) {
  const target = {};
  for (const key in source) {
    target[key] = valueMap(source[key], key);
  }
  return target;
}

// src/random.ts
function random(to, from = 0) {
  return Math.floor(Math.random() * (to - from + 1)) + from;
}
function pickRandom(array) {
  return array[random(array.length - 1)];
}

// src/rx.ts
import {
  concatMap,
  delay,
  filter,
  first,
  mergeMap,
  of,
  pipe,
  ReplaySubject,
  scan,
  timestamp
} from "rxjs";
import { computed, observable, reaction as reaction3, runInAction, toJS } from "mobx";
function filterNullish() {
  return pipe(
    filter((x) => x != null)
  );
}
function awaitPromise() {
  return pipe(concatMap((x) => x));
}
function stretch(spacingDelayMs) {
  return pipe(
    timestamp(),
    scan((acc, curr) => {
      let delay2 = 0;
      if (acc !== null) {
        const timeDelta = curr.timestamp - acc.timestamp;
        delay2 = timeDelta > spacingDelayMs ? 0 : spacingDelayMs - timeDelta;
      }
      return {
        timestamp: curr.timestamp,
        delay: delay2,
        value: curr.value
      };
    }, null),
    filterNullish(),
    mergeMap((i) => of(i.value).pipe(delay(i.delay)), 1)
  );
}
function observableToComputed(obs) {
  return computed(() => obs.get());
}
function computedToStream(comp) {
  const stream = new ReplaySubject(1);
  reaction3(
    () => comp.get(),
    (value) => {
      if (value != null) stream.next(value);
    },
    { fireImmediately: true }
  );
  return stream;
}
function observableToStream(obs) {
  const stream = new ReplaySubject(1);
  reaction3(
    () => toJS(obs),
    (value) => {
      if (value != null) stream.next(value);
    },
    { fireImmediately: true }
  );
  return stream;
}
function streamToComputed(stream$) {
  const value = observable.box();
  stream$.subscribe((val) => runInAction(() => value.set(val)));
  return computed(() => value.get());
}
async function streamToDefinedComputed(stream$) {
  const value = observable.box();
  stream$.subscribe((val) => runInAction(() => value.set(val)));
  const computedValue = computed(() => value.get());
  await awaitValue(computedValue);
  return computedValue;
}
async function awaitStreamValue(stream$, predicate = (value) => value != null) {
  const [resolve, , promise] = deferred();
  stream$.pipe(first(predicate)).subscribe(resolve);
  return promise;
}
async function streamToWrappedValue(stream$) {
  const value = {};
  stream$.subscribe((v) => value.current = v);
  value.current = await awaitStreamValue(stream$);
  return value;
}

// src/uuid.ts
var uuid = function() {
  const rand = _getRandomInt, hex = _hexAligner;
  return hex(rand(32), 8) + // time_low
  "-" + hex(rand(16), 4) + // time_mid
  "-" + hex(16384 | rand(12), 4) + // time_hi_and_version
  "-" + hex(32768 | rand(14), 4) + // clock_seq_hi_and_reserved clock_seq_low
  "-" + hex(rand(48), 12);
};
var _getRandomInt = function(x) {
  if (x < 0 || x > 53) {
    return NaN;
  }
  const n = 0 | Math.random() * 1073741824;
  return x > 30 ? n + (0 | Math.random() * (1 << x - 30)) * 1073741824 : n >>> 30 - x;
};
var _hexAligner = function(num, length) {
  let str = num.toString(16), i = length - str.length, z = "0";
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      str = z + str;
    }
  }
  return str;
};

// src/sleep.ts
function sleep(timeout, returns) {
  return new Promise((resolve) => setTimeout(() => resolve(returns), timeout));
}

// src/promise.ts
var range = function* (total = 0, step = 1, from = 0) {
  for (let i = 0; i < total; yield from + i++ * step) {
  }
};
async function rejectAfter(ms, msg) {
  await sleep(ms);
  throw new Error(msg);
}
var timeoutAfter = async (promise, ms, timeoutMsg) => {
  return Promise.race([promise, rejectAfter(ms, timeoutMsg)]);
};
var callWithRetry = (fn, args = [], maxRetries = 10, retryInterval = 1e3) => {
  const [resolve, reject, promise] = deferred();
  const process = async () => {
    let res;
    for (let i = 0; i < maxRetries; i++) {
      try {
        res = await fn(...args);
        resolve(res);
        break;
      } catch (e) {
        if (i < maxRetries - 1) {
          console.info("[CallWithRetry Failed] attempt number=" + i, fn);
          console.error(e);
          await sleep(Math.min(retryInterval * 2 ** i + Math.random() * 100, 15e3));
        } else {
          reject(e);
        }
      }
    }
  };
  process();
  return promise;
};

// src/iterable.ts
function makeIterable(iterator) {
  const iterable = {
    ...iterator,
    [Symbol.iterator]() {
      return this;
    }
  };
  return iterable;
}
function concatIterators(first2, second) {
  if (!second) return makeIterable(first2);
  return makeIterable({
    next() {
      const next = first2.next();
      if (!next.done) return next;
      return second.next();
    }
  });
}
function mergeIterators(iteratorA, iteratorB) {
  const iterator = {
    next() {
      const nextA = iteratorA.next();
      const nextB = iteratorB.next();
      if (nextA.done && nextB.done) return { done: true, value: null };
      return { value: [nextA.value, nextB.value] };
    }
  };
  return makeIterable(iterator);
}
function transformIterator(iterator, transform) {
  return makeIterable({
    next() {
      const { done, value } = iterator.next();
      return { done, value: done ? value : transform(value) };
    }
  });
}
function arrayToIterator(array) {
  let i = 0;
  const iterator = {
    next() {
      const done = i >= array.length;
      if (done) return { done, value: null };
      return { value: array[i++] };
    }
  };
  return makeIterable(iterator);
}

// src/area.ts
function areaContains(area, coord) {
  return coord.x >= area.x && coord.y >= area.y && coord.x < area.x + area.width && coord.y < area.y + area.height;
}
function coordsOf(area) {
  const coords = [];
  for (let dx = 0; dx < area.width; dx++) {
    for (let dy = 0; dy < area.height; dy++) {
      coords.push({ x: area.x + dx, y: area.y + dy });
    }
  }
  return coords;
}

// src/worker.ts
import { fromEvent, map } from "rxjs";
function fromWorker(worker, input$) {
  input$.subscribe((event) => worker.postMessage(event));
  return fromEvent(worker, "message").pipe(map((e) => e.data));
}
function runWorker(worker) {
  const input$ = fromEvent(self, "message");
  const output$ = worker.work(input$.pipe(map((event) => event.data)));
  output$.subscribe((event) => self.postMessage(event));
}

// src/pack.ts
function rightMask(input, keep) {
  return input & 2 ** keep - 1;
}
function pack(numbers, bitsPerNumber) {
  if (bitsPerNumber.reduce((acc, curr) => acc + curr, 0) > 32) {
    throw new Error("JS pretends integers are 32 bit when bitshifts are involved");
  }
  if (numbers.length !== bitsPerNumber.length) throw new Error("Arrays' lengths must match");
  for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] < 0) {
      throw new Error("Underflow: can only pack unsigned integer");
    }
    if (numbers[i] > 2 ** bitsPerNumber[i] - 1) {
      const error = `Overflow: ${numbers[i]} does not fit in ${bitsPerNumber[i]} bits`;
      throw new Error(error);
    }
  }
  let packed = 0;
  for (let i = 0; i < numbers.length; i++) {
    packed = packed << bitsPerNumber[i] | numbers[i];
  }
  return packed;
}
function unpack(packed, bitsPerNumber) {
  const numbers = [];
  let shiftedPacked = packed;
  for (let i = bitsPerNumber.length - 1; i >= 0; i--) {
    numbers.unshift(rightMask(shiftedPacked, bitsPerNumber[i]));
    shiftedPacked = shiftedPacked >>> bitsPerNumber[i];
  }
  return numbers;
}
function packTuple(numbers) {
  return pack(numbers, [8, 24]);
}
function unpackTuple(packed) {
  return unpack(packed, [8, 24]);
}

// src/CoordMap.ts
var LOWER_HALF_MASK = 2 ** 16 - 1;
var MAX_SUPPORTED = 2 ** 15 - 1;
function subtract(from, subtract2) {
  const result = new CoordMap();
  for (const coord of from.coords()) {
    if (subtract2.get(coord)) continue;
    result.set(coord, true);
  }
  return result;
}
function coordToKey(coord) {
  const key = coord.x << 16 | coord.y & LOWER_HALF_MASK;
  return key;
}
function keyToCoord(key) {
  const x = key >> 16;
  const y = key << 16 >> 16;
  return { x, y };
}
var CoordMap = class _CoordMap {
  constructor(props) {
    this.map = /* @__PURE__ */ new Map();
    this.defaultValue = props?.defaultValue;
  }
  static from(coordMapLike) {
    const coordMap = new _CoordMap();
    coordMap.map = coordMapLike.map;
    coordMap.defaultValue = coordMapLike.defaultValue;
    return coordMap;
  }
  set(coord, value) {
    if (coord.x > MAX_SUPPORTED || coord.x < -1 * MAX_SUPPORTED || coord.y > MAX_SUPPORTED || coord.y < -1 * MAX_SUPPORTED) {
      throw new Error(`CoordMap only supports coords up to ${MAX_SUPPORTED}`);
    }
    return this.map.set(coordToKey(coord), value);
  }
  get(coord) {
    return this.map.get(coordToKey(coord)) ?? this.defaultValue;
  }
  keys() {
    return this.map.keys();
  }
  coords() {
    return transformIterator(this.map.keys(), (key) => keyToCoord(key));
  }
  entries() {
    return this.map.entries();
  }
  toArray() {
    const entries = Array.from(this.map.entries());
    return entries.map(([key, value]) => [keyToCoord(key), value]);
  }
  values() {
    return this.map.values();
  }
  delete(coord) {
    return this.map.delete(coordToKey(coord));
  }
  has(coord) {
    return this.map.has(coordToKey(coord));
  }
  clear() {
    for (const key of this.map.keys()) {
      this.map.delete(key);
    }
  }
  get size() {
    return this.map.size;
  }
};

// src/VoxelCoordMap.ts
function coordToKey2(coord) {
  return `${coord.x}/${coord.y}/${coord.z}`;
}
function keyToCoord2(key) {
  const fragments = key.split("/");
  return { x: Number(fragments[0]), y: Number(fragments[1]), z: Number(fragments[2]) };
}
var VoxelCoordMap = class _VoxelCoordMap {
  constructor(props) {
    this.map = /* @__PURE__ */ new Map();
    this.defaultValue = props?.defaultValue;
  }
  static from(coordMapLike) {
    const coordMap = new _VoxelCoordMap();
    coordMap.map = coordMapLike.map;
    coordMap.defaultValue = coordMapLike.defaultValue;
    return coordMap;
  }
  set(coord, value) {
    return this.map.set(coordToKey2(coord), value);
  }
  get(coord) {
    return this.map.get(coordToKey2(coord)) ?? this.defaultValue;
  }
  keys() {
    return this.map.keys();
  }
  coords() {
    return transformIterator(this.map.keys(), (key) => keyToCoord2(key));
  }
  entries() {
    return this.map.entries();
  }
  toArray() {
    const entries = Array.from(this.map.entries());
    return entries.map(([key, value]) => [keyToCoord2(key), value]);
  }
  values() {
    return this.map.values();
  }
  delete(coord) {
    return this.map.delete(coordToKey2(coord));
  }
  has(coord) {
    return this.map.has(coordToKey2(coord));
  }
  clear() {
    for (const key of this.map.keys()) {
      this.map.delete(key);
    }
  }
  get size() {
    return this.map.size;
  }
};

// src/eth.ts
function padToBitLength(input, bits) {
  if (input.substring(0, 2) == "0x") input = input.substring(2);
  const length = bits / 4;
  input = input.padStart(length, "0");
  input = input.substring(input.length - length);
  return `0x${input}`;
}
function toEthAddress(input) {
  return padToBitLength(input, 160);
}
function to256BitString(input) {
  return padToBitLength(input, 256);
}
function extractEncodedArguments(input) {
  if (input[0] !== "0" && input[1] !== "x") throw new Error("Invalid hex string");
  return "0x" + input.substring(10);
}

// src/cubic.ts
var RND_A = 134775813;
var RND_B = 1103515245;
var ACCURACY = 1e3;
function randomize(seed, x, y) {
  return (((x ^ y) * RND_A ^ seed + x) * (RND_B * x << 16 ^ RND_B * y - RND_A) >>> 0) / 4294967295;
}
function tile(coordinate, period) {
  if (coordinate < 0) while (coordinate < 0) coordinate += period;
  return coordinate % period;
}
function interpolate(a, b, c, d, x, s, scale) {
  const p = d - c - (a - b);
  return (b * Math.pow(s, 3) + x * (c * Math.pow(s, 2) + a * s * (-s + x) + x * (-(b + p) * s + p * x))) * scale;
}
function cubicNoiseConfig(seed, octave, scale, periodX = Number.MAX_SAFE_INTEGER, periodY = Number.MAX_SAFE_INTEGER) {
  return {
    seed: Math.floor(seed * Number.MAX_SAFE_INTEGER),
    periodX,
    periodY,
    octave,
    scale
  };
}
function cubicNoiseSample1(config, x) {
  const xi = Math.floor(x);
  const lerp = x - xi;
  return interpolate(
    randomize(config.seed, tile(xi - 1, config.periodX), 0),
    randomize(config.seed, tile(xi, config.periodX), 0),
    randomize(config.seed, tile(xi + 1, config.periodX), 0),
    randomize(config.seed, tile(xi + 2, config.periodX), 0),
    lerp,
    1,
    1
  ) * 0.666666 + 0.166666;
}
function cubicNoiseSample2({ octave, periodX, periodY, seed, scale }, x, y) {
  const xi = Math.floor(x / octave);
  const lerpX = Math.floor(x * ACCURACY / octave) - xi * ACCURACY;
  const yi = Math.floor(y / octave);
  const lerpY = Math.floor(y * ACCURACY / octave) - yi * ACCURACY;
  const x0 = tile(xi - 1, periodX);
  const x1 = tile(xi, periodX);
  const x2 = tile(xi + 1, periodX);
  const x3 = tile(xi + 2, periodX);
  const xSamples = new Array(4);
  for (let i = 0; i < 4; ++i) {
    const y2 = tile(yi - 1 + i, periodY);
    xSamples[i] = interpolate(
      randomize(seed, x0, y2),
      randomize(seed, x1, y2),
      randomize(seed, x2, y2),
      randomize(seed, x3, y2),
      lerpX,
      ACCURACY,
      1
    );
  }
  return Math.floor(
    interpolate(xSamples[0], xSamples[1], xSamples[2], xSamples[3], lerpY, ACCURACY, scale) / Math.pow(ACCURACY, 6)
  );
}

// src/console.ts
var TOPICS_KEY = "mud-logger-topics";
function enableLogger() {
  const windowConsole = window.console;
  let filtersActive = Boolean(localStorage.getItem(TOPICS_KEY));
  const topicsString = localStorage.getItem(TOPICS_KEY);
  let topics = topicsString ? JSON.parse(topicsString) : [];
  function log(...logs) {
    if (filtersActive) return;
    windowConsole.log(...logs);
  }
  function logWithTopic(topic, ...logs) {
    if (!filtersActive || topics.includes(topic)) {
      windowConsole.log(`--- BETTER CONSOLE / TOPIC ${topic} ---`);
      windowConsole.log(...logs);
    }
  }
  function enableFilters() {
    localStorage.setItem(TOPICS_KEY, JSON.stringify([]));
    filtersActive = true;
  }
  function disableFilters() {
    localStorage.removeItem(TOPICS_KEY);
    filtersActive = false;
  }
  function addTopic(topic) {
    topics.push(topic);
    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));
  }
  function removeTopic(topic) {
    topics = topics.filter((t) => t !== topic);
    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));
  }
  function resetTopics() {
    topics = [];
    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));
  }
  const logger = {
    ...windowConsole,
    log,
    logWithTopic,
    enableFilters,
    disableFilters,
    addTopic,
    removeTopic,
    resetTopics
  };
  window.logger = logger;
  window.console = logger;
  return logger;
}

// src/distance.ts
function euclidean(a, b) {
  if (a.length !== b.length) throw new Error("points must have same dimension");
  return Math.sqrt(a.reduce((acc, _, i) => acc + Math.pow(a[i] - b[i], 2), 0));
}

// src/math.ts
function roundTowardsZero(x) {
  const sign = x < 0 ? -1 : 1;
  return sign * Math.floor(Math.abs(x));
}

// src/v2/arrayToHex.ts
var arrayToHex = (array) => `0x${[...new Uint8Array(array)].map((x) => x.toString(16).padStart(2, "0")).join("")}`;

// src/v2/bytesToString.ts
var bytesToString = (bytes) => [...bytes].map((x) => String.fromCharCode(x)).join("");

// src/v2/isHex.ts
function isHex(hex) {
  return /^(0x)?([\da-f]{2})*$/i.test(hex);
}

// src/v2/hexToArray.ts
var hexToArray = (hex) => {
  if (!isHex(hex)) {
    console.error("Invalid hex string", hex);
    throw new Error("Invalid hex string");
  }
  const bytes = hex.match(/[\da-f]{2}/gi);
  if (!bytes) return new Uint8Array([]);
  return new Uint8Array(bytes.map((byte) => parseInt(byte, 16)));
};

// src/v2/stringToBytes.ts
var stringToBytes16 = (str) => {
  if (str.length > 16) throw new Error("string too long");
  return new Uint8Array(16).map((v, i) => str.charCodeAt(i));
};
var stringToBytes32 = (str) => {
  if (str.length > 32) throw new Error("string too long");
  return new Uint8Array(32).map((v, i) => str.charCodeAt(i));
};

// src/bytes.ts
function formatHex(hex) {
  if (hex.substring(0, 2) == "0x") hex = hex.substring(2);
  const prefix = hex.length % 2 !== 0 ? "0x0" : "0x";
  return prefix + hex;
}
function hexStringToUint8Array(hexString) {
  return hexToArray(hexString);
}
function Uint8ArrayToHexString(data) {
  if (data.length === 0) return "0x00";
  return formatHex(data.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), ""));
}
function concatUint8Arrays(...arrays) {
  return Uint8Array.from(
    arrays.reduce((acc, curr) => {
      return [...acc, ...curr];
    }, [])
  );
}
function splitUint8Arrays(data, byteLengths) {
  const arrays = [];
  let i = 0;
  for (const length of byteLengths) {
    const array = new Uint8Array(length);
    arrays.push(array);
    for (let j = 0; j < length; j++) {
      array[j] = data[i];
      i++;
    }
  }
  return arrays;
}
function Int32ArrayToUint8Array(input) {
  const buffer = new ArrayBuffer(input.length * 4);
  const int32arr = new Int32Array(buffer);
  for (let i = 0; i < input.length; i++) {
    int32arr[i] = input[i];
  }
  return new Uint8Array(buffer);
}
function Uint8ArrayToInt32Array(input) {
  return [...new Int32Array(input.buffer)];
}
function ethAddressToUint8Array(address) {
  return hexStringToUint8Array(toEthAddress(address));
}
function createToInt(size) {
  if (size < 2) {
    throw new Error("Minimum size is 2");
  } else if (size > 64) {
    throw new Error("Maximum size is 64");
  }
  const maxValue = 2 ** (size - 1) - 1;
  const minValue = -maxValue - 1;
  return (value) => {
    value = value << 0;
    if (value > maxValue || value < minValue) {
      console.log("value", value, maxValue, minValue, value > maxValue, value < minValue);
      throw new Error(`Int${size} overflow`);
    }
    if (value < 0) {
      return 2 ** size + value;
    } else {
      return value;
    }
  };
}
var toInt32 = createToInt(32);
export {
  CoordMap,
  Int32ArrayToUint8Array,
  Uint8ArrayToHexString,
  Uint8ArrayToInt32Array,
  VoxelCoordMap,
  areaContains,
  arrayToHex,
  arrayToIterator,
  awaitPromise,
  awaitStreamValue,
  awaitValue,
  bytesToString,
  cacheUntilReady,
  callWithRetry,
  computedToStream,
  concatIterators,
  concatUint8Arrays,
  coordToKey,
  coordsOf,
  createToInt,
  cubicNoiseConfig,
  cubicNoiseSample1,
  cubicNoiseSample2,
  deferred,
  enableLogger,
  ethAddressToUint8Array,
  euclidean,
  extractEncodedArguments,
  filterNullish,
  filterNullishValues,
  formatHex,
  fromWorker,
  hexStringToUint8Array,
  hexToArray,
  interpolate,
  isFunction,
  isHex,
  isNotEmpty,
  isObject,
  keyToCoord,
  makeIterable,
  mapObject,
  mergeIterators,
  numValues,
  observableToComputed,
  observableToStream,
  pack,
  packTuple,
  padToBitLength,
  pickRandom,
  random,
  randomize,
  range,
  rejectAfter,
  roundTowardsZero,
  runWorker,
  sleep,
  splitUint8Arrays,
  streamToComputed,
  streamToDefinedComputed,
  streamToWrappedValue,
  stretch,
  stringToBytes16,
  stringToBytes32,
  subtract,
  tile,
  timeoutAfter,
  to256BitString,
  toEthAddress,
  toInt32,
  transformIterator,
  unpack,
  unpackTuple,
  uuid
};
/**
 * UUID.core.js - UUID.js for Minimalists
 *
 * @file
 * @author  LiosK
 * @version v4.2.0
 * @license Apache License 2.0: Copyright (c) 2010-2018 LiosK
 * @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js
 */
//# sourceMappingURL=index.js.map