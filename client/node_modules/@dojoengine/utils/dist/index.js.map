{"version":3,"sources":["../src/game/simplex.ts","../src/utils/index.ts"],"sourcesContent":["import * as math from \"mathjs\";\n\nconst multiply = (a: any, b: any) => {\n    if (!Array.isArray(a) || !Array.isArray(b)) return math.multiply(a, b);\n    return a.map((v, i) => v * b[i]);\n};\n\nconst floor = (a: any) => {\n    return a.map((v: any) => Math.floor(v));\n};\n\nconst step = (a: any, b: any) => {\n    return a.map((v: any, i: any) => (b[i] <= v ? 0 : 1));\n};\n\nconst mod289 = (x: any) => {\n    return x.map((v: any) => v - Math.floor(v * (1.0 / 289.0)) * 289.0);\n};\n\nconst permute = (x: any) => {\n    x = x.map((v: any) => (v * 34.0 + 1.0) * v);\n    return mod289(x);\n};\n\nconst taylorInvSqrt = (r: any) => {\n    return r.map((v: any) => 1.79284291400159 - 0.85373472095314 * v);\n};\n\nexport const snoise = (v: any) => {\n    const C = [1.0 / 6.0, 1.0 / 3.0];\n    const D = [0.0, 0.5, 1.0, 2.0];\n\n    // First corner\n    const i = floor(math.add(v, math.dot(v, [C[1], C[1], C[1]])));\n    const x0 = math.add(math.subtract(v, i), math.dot(i, [C[0], C[0], C[0]]));\n\n    // Other corners\n    const g = step([x0[1], x0[2], x0[0]], [x0[0], x0[1], x0[2]]);\n    const l = math.subtract(1.0, g);\n    const i1 = math.min(\n        [\n            [g[0], g[1], g[2]],\n            [l[2], l[0], l[1]],\n        ],\n        0\n    );\n    const i2 = math.max(\n        [\n            [g[0], g[1], g[2]],\n            [l[2], l[0], l[1]],\n        ],\n        0\n    );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    const x1 = math.add(math.subtract(x0, i1), [C[0], C[0], C[0]]);\n    const x2 = math.add(math.subtract(x0, i2), [C[1], C[1], C[1]]); // 2.0*C.x = 1/3 = C.y\n    const x3 = math.subtract(x0, [D[1], D[1], D[1]]); // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    let p1 = permute(math.add(i[2], [0.0, i1[2], i2[2], 1.0]));\n    let p2 = permute(math.add(math.add(p1, i[1]), [0.0, i1[1], i2[1], 1.0]));\n    const p = permute(math.add(math.add(p2, i[0]), [0.0, i1[0], i2[0], 1.0]));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    const ns = [0.285714285714286, -0.928571428571428, 0.142857142857143]; // these must be *exact*\n    const j = math.subtract(p, multiply(49, floor(multiply(p, ns[2] * ns[2])))); //  mod(p,7*7)\n\n    const x_ = floor(multiply(j, ns[2]));\n    const y_ = floor(math.subtract(j, multiply(7, x_))); // mod(j,N)\n\n    const x = math.add(multiply(x_, ns[0]), [ns[1], ns[1], ns[1], ns[1]]);\n    const y = math.add(multiply(y_, ns[0]), [ns[1], ns[1], ns[1], ns[1]]);\n    const h = math.subtract(math.subtract(1.0, math.abs(x)), math.abs(y));\n\n    const b0 = [x[0], x[1], y[0], y[1]];\n    const b1 = [x[2], x[3], y[2], y[3]];\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    const s0 = math.add(multiply(floor(b0), 2.0), 1.0);\n    const s1 = math.add(multiply(floor(b1), 2.0), 1.0);\n    const sh = multiply(-1, step(h, [0, 0, 0, 0]));\n\n    const a0 = math.add(\n        [b0[0], b0[2], b0[1], b0[3]],\n        multiply([s0[0], s0[2], s0[1], s0[3]], [sh[0], sh[0], sh[1], sh[1]])\n    );\n    const a1 = math.add(\n        [b1[0], b1[2], b1[1], b1[3]],\n        multiply([s1[0], s1[2], s1[1], s1[3]], [sh[2], sh[2], sh[3], sh[3]])\n    );\n\n    let p0 = [a0[0], a0[1], h[0]];\n    p1 = [a0[2], a0[3], h[1]];\n    p2 = [a1[0], a1[1], h[2]];\n    let p3 = [a1[2], a1[3], h[3]];\n\n    // Normalise gradients\n    const norm = taylorInvSqrt([\n        math.dot(p0, p0),\n        math.dot(p1, p1),\n        math.dot(p2, p2),\n        math.dot(p3, p3),\n    ]);\n    p0 = multiply(p0, norm[0]);\n    p1 = multiply(p1, norm[1]);\n    p2 = multiply(p2, norm[2]);\n    p3 = multiply(p3, norm[3]);\n\n    // Mix final noise value\n    //@ts-ignore\n    let m = math.max(\n        [\n            //@ts-ignore\n            math.subtract(0.5, [\n                math.dot(x0, x0),\n                math.dot(x1, x1),\n                math.dot(x2, x2),\n                math.dot(x3, x3),\n            ]),\n            [0, 0, 0, 0],\n        ],\n        0\n    );\n    m = multiply(m, m);\n    m = multiply(m, m);\n    const noise = multiply(\n        105.0,\n        //@ts-ignore\n        math.dot(m, [\n            math.dot(p0, x0),\n            math.dot(p1, x1),\n            math.dot(p2, x2),\n            math.dot(p3, x3),\n        ])\n    );\n    return noise;\n};\n\nexport const recursiveSNoise = (p: any, pers: any, octaves: any) => {\n    let total = 0.0;\n    let frequency = 1.0;\n    let amplitude = 1.0;\n    let maxValue = 0.0;\n\n    for (let i = 0; i < octaves; i++) {\n        total += snoise(multiply(p, frequency)) * amplitude;\n        maxValue += amplitude;\n        amplitude *= pers;\n        frequency *= 2.0;\n    }\n\n    const noise = total / maxValue;\n    return noise;\n};\n\nexport default {\n    snoise,\n    recursiveSNoise,\n};\n","import {\n    type Component,\n    type Components,\n    type ComponentValue,\n    type Entity,\n    Type as RecsType,\n    type Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport { poseidonHashMany } from \"micro-starknet\";\nimport { type ByteArray, byteArray, addAddressPadding } from \"starknet\";\n\nconst STORE_SET_RECORD_EVENT_NAME =\n    \"0x1a2f334228cee715f1f0f54053bb6b5eac54fa336e0bc1aacf7516decb0471d\";\nconst TAG_SEPARATOR = \"-\";\n\n/**\n * Filters events from a given receipt based on specific criteria.\n *\n * @param {any} receipt - The transaction receipt.\n * @returns {any[]} An array of events that meet the filtering criteria.\n */\nexport function getEvents(receipt: any): any[] {\n    return receipt.events.filter((event: any) => {\n        return (\n            event.keys.length === 1 &&\n            event.keys[0] === STORE_SET_RECORD_EVENT_NAME\n        );\n    });\n}\n\n/**\n * Iterates over an array of events and updates components based on event data.\n *\n * @param {Components} components - The components to be updated.\n * @param {Event[]} events - An array of events containing component data.\n */\nexport function setComponentsFromEvents(components: Components, events: any[]) {\n    events.forEach((event) => setComponentFromEvent(components, event.data));\n}\n\n/**\n * Updates a component based on the data from a single event.\n *\n * @param {Components} components - The components to be updated.\n * @param {string[]} eventData - The data from a single event.\n */\nexport function setComponentFromEvent(\n    components: Components,\n    eventData: string[]\n) {\n    const componentNames = getComponentNames(components);\n    // retrieve the component name\n    try {\n        const componentName = getComponentNameFromEvent(\n            Array.from(componentNames.keys()),\n            eventData\n        );\n        // retrieve the component from name\n        const component =\n            components[componentNames.get(componentName) as string];\n\n        // get keys\n        const keysNumber = parseInt(eventData[1]);\n        const index = 2 + keysNumber + 1;\n\n        const keys = eventData\n            .slice(2, 2 + keysNumber)\n            .map((key) => BigInt(key));\n\n        // get entityIndex from keys\n        const entityIndex = getEntityIdFromKeys(keys);\n\n        // get values\n        const numberOfValues = parseInt(eventData[index]);\n\n        const string_keys = keys.map((key) => key.toString());\n\n        // get values\n        const values = eventData.slice(index, index + numberOfValues);\n\n        // create component object from values with schema\n        const componentValues = decodeComponent(component, [\n            ...string_keys,\n            ...values,\n        ]);\n\n        // set component\n        setComponent(component, entityIndex, componentValues);\n    } catch (error) {\n        console.log(error);\n    }\n}\n\n// Extract component names from components\nfunction getComponentNames(components: Components): Map<string, string> {\n    const names = new Map<string, string>();\n    for (const key of Object.keys(components)) {\n        const c: Component = components[key];\n        names.set(c.metadata?.name as string, key);\n    }\n    return names;\n}\n\n/**\n * Parse component value into typescript typed value\n *\n * @param {string} value - The value to parse\n * @param {RecsType} type - The target type\n */\nexport function parseComponentValue(value: string, type: RecsType) {\n    switch (type) {\n        case RecsType.Boolean:\n            return value === \"0x0\" ? false : true;\n        case RecsType.Number:\n            return Number(value);\n        case RecsType.BigInt:\n            return BigInt(value);\n        default:\n            return value;\n    }\n}\n\n/**\n * Decodes a component based on the provided schema.\n *\n * @param {Component} component - The component description created by defineComponent(), containing the schema and metadata types.\n * @param {string[]} values - An array of string values used to populate the decoded component.\n * @returns {Object} The decoded component object.\n */\nexport function decodeComponent(component: Component, values: string[]): any {\n    const schema: any = component.schema;\n    const types: string[] = (component.metadata?.types as string[]) ?? [];\n    const indices = { types: 0, values: 0 };\n    return decodeComponentValues(schema, types, values, indices);\n}\n\nfunction decodeComponentValues(\n    schema: Schema,\n    types: string[],\n    values: string[],\n    indices: any\n): any {\n    // Iterate through the keys of the schema and reduce them to build the decoded component.\n    return Object.keys(schema).reduce((acc: any, key) => {\n        const valueType = schema[key];\n        if (typeof valueType === \"object\") {\n            // valueType is a Schema\n            // it means it's a nested component. Therefore, we recursively decode it.\n            acc[key] = decodeComponentValues(\n                valueType as Schema,\n                types,\n                values,\n                indices\n            );\n        } else {\n            // valueType is a RecsType\n            // If the schema key points directly to a type or is not an object,\n            // we parse its value using the provided parseComponentValue function\n            // and move to the next index in the values array.\n            acc[key] = parseComponentValue(\n                values[indices.values],\n                valueType as RecsType\n            );\n            indices.values++;\n            // the u256 type in cairo is actually { low: u128, high: u128 }\n            // we need to consume two u128 values, shifting the second to compose u256\n            if (types[indices.types] === \"u256\") {\n                const value = parseComponentValue(\n                    values[indices.values],\n                    valueType as RecsType\n                ) as bigint;\n                acc[key] |= value << 128n;\n                indices.values++;\n            }\n            indices.types++;\n        }\n        return acc;\n    }, {});\n}\n\n/**\n * Converts a hexadecimal string to an ASCII string.\n */\nexport function hexToAscii(hex: string): string {\n    let str = \"\";\n    for (let n = 2; n < hex.length; n += 2) {\n        str += String.fromCharCode(Number.parseInt(hex.substr(n, 2), 16));\n    }\n    return str;\n}\n\n/**\n * Converts an ASCII string to a hexadecimal string.\n * With a 0x prefix, matching the original function's format\n */\nexport function asciiToHex(str: string): string {\n    let hex = \"0x\";\n    for (let i = 0; i < str.length; i++) {\n        hex += str.charCodeAt(i).toString(16).padStart(2, \"0\");\n    }\n    return hex;\n}\n\n/**\n * Get the component name from felt event name\n */\nexport function getComponentNameFromEvent(\n    actions: string[],\n    event: string[]\n): string {\n    const actionFelt: Record<string, string> = actions.reduce(\n        (acc: Record<string, string>, action: string) => {\n            const parts = splitEventTag(action);\n            acc[getSelectorFromTag(parts[0], parts[1])] = action;\n            return acc;\n        },\n        {}\n    );\n    const eventName: string = event[0];\n    const action: string | undefined = actionFelt[eventName];\n    if (!action) {\n        throw new Error(\n            `Action ${eventName} not found in actions : ${actions}`\n        );\n    }\n    return action;\n}\n\n// Encodes big number to formatted hex string\nfunction toHexString(bn: bigint): string {\n    return \"0x\" + bn.toString(16);\n}\n\n// Computes dojo selector from namespace and event name\nexport function getSelectorFromTag(namespace: string, event: string): string {\n    return toHexString(\n        poseidonHashMany([\n            computeByteArrayHash(namespace),\n            computeByteArrayHash(event),\n        ])\n    );\n}\n\n// Serializes a ByteArray to a bigint array\nfunction serializeByteArray(byteArray: ByteArray): bigint[] {\n    const result: bigint[] = [\n        BigInt(byteArray.data.length),\n        ...byteArray.data.map((word) => BigInt(word.toString())),\n        BigInt(byteArray.pending_word),\n        BigInt(byteArray.pending_word_len),\n    ];\n    return result;\n}\n\n// Poseidon hash of a string representated as a ByteArray\nexport function computeByteArrayHash(str: string): bigint {\n    const bytes = byteArray.byteArrayFromString(str);\n    return poseidonHashMany(serializeByteArray(bytes));\n}\n\n// Splits selector name into namespace and event name\nexport function splitEventTag(event: string): string[] {\n    return event.split(TAG_SEPARATOR);\n}\n\n/**\n * Determines the entity ID from an array of keys. If only one key is provided,\n * it's directly used as the entity ID. Otherwise, a poseidon hash of the keys is calculated.\n *\n * @param {bigint[]} keys - An array of big integer keys.\n * @returns {Entity} The determined entity ID.\n */\nexport function getEntityIdFromKeys(keys: bigint[]): Entity {\n    // if (keys.length === 1) {\n    //     return (\"0x\" + keys[0].toString(16)) as Entity;\n    // }\n    // calculate the poseidon hash of the keys\n    const poseidon = poseidonHashMany(keys);\n    // Ensure consistent padding for entity IDs\n    return addAddressPadding(\"0x\" + poseidon.toString(16)) as Entity;\n}\n\n/**\n * Iterate through GraphQL entities and set components based on them.\n *\n * @param {Components} components - The target components structure where the parsed data will be set.\n * @param {any[]} entities - The array of GraphQL entities to parse and set in the components.\n */\nexport function setComponentsFromGraphQLEntities(\n    components: Components,\n    entities: any\n) {\n    entities.forEach((entity: any) => {\n        setComponentFromGraphQLEntity(components, entity);\n    });\n}\n\n/**\n * Set a component from a single GraphQL entity.\n *\n * @param {Components} components - The target components structure where the parsed data will be set.\n * @param {any} entityEdge - The GraphQL entity containing node information to parse and set in the components.\n */\nexport function setComponentFromGraphQLEntity(\n    components: Components,\n    entityEdge: any\n) {\n    const keys = entityEdge.node.keys.map((key: string) => BigInt(key));\n    const entityIndex = getEntityIdFromKeys(keys);\n\n    entityEdge.node.models.forEach((model: any) => {\n        const componentName = model.__typename;\n        const component = components[componentName];\n\n        if (!component) {\n            console.error(`Component ${componentName} not found`);\n            return;\n        }\n\n        const componentValues = Object.keys(component.schema).reduce(\n            (acc: ComponentValue, key) => {\n                const value = model[key];\n                const parsedValue = parseComponentValueFromGraphQLEntity(\n                    value,\n                    component.schema[key]\n                );\n                acc[key] = parsedValue;\n                return acc;\n            },\n            {}\n        );\n\n        setComponent(component, entityIndex, componentValues);\n    });\n}\n\n/**\n * Parse a component's value from a GraphQL entity based on its type or schema.\n *\n * @param {any} value - The raw value from the GraphQL entity.\n * @param {RecsType | object} type - The expected type or schema for the value.\n * @returns {any} The parsed value.\n */\nexport function parseComponentValueFromGraphQLEntity(\n    value: any,\n    type: RecsType | object\n): any {\n    if (value === undefined || value === null) return value;\n\n    // Check if type is an object (i.e., a nested schema)\n    if (typeof type === \"object\" && type !== null) {\n        const parsedObject: any = {};\n        for (const key in type) {\n            parsedObject[key] = parseComponentValueFromGraphQLEntity(\n                value[key],\n                (type as any)[key]\n            );\n        }\n        return parsedObject;\n    }\n\n    // For primitive types\n    switch (type) {\n        case RecsType.Boolean:\n            return !!value;\n        case RecsType.Number:\n            if (typeof value === \"string\") {\n                return 0;\n            }\n            return !isNaN(Number(value)) ? Number(value) : value;\n        case RecsType.BigInt:\n            return BigInt(value);\n        default:\n            return value;\n    }\n}\n\nexport function shortenHex(hexString: string, numDigits = 6) {\n    if (hexString?.length <= numDigits) {\n        return hexString;\n    }\n\n    const halfDigits = Math.floor(numDigits / 2);\n    const firstHalf = hexString.slice(0, halfDigits);\n    const secondHalf = hexString.slice(-halfDigits);\n    return `${firstHalf}...${secondHalf}`;\n}\n\n/**\n * Get the default port for a given protocol\n * @param {string} protocol - The protocol to get the default port for\n * @returns {number} The default port\n */\nfunction getDefaultPortForProtocol(protocol: string): number {\n    switch (protocol) {\n        case \"https:\":\n            return 443;\n        case \"wss:\":\n            return 443;\n        default:\n            return 80;\n    }\n}\n\n/**\n * Converts a standard URI to multiaddr format\n * Examples:\n * - http://example.com → /dns4/example.com/tcp/80/http\n * - https://example.com → /dns4/example.com/tcp/443/https\n * - http://127.0.0.1:8080 → /ip4/127.0.0.1/tcp/8080/http\n * - http://[::1]:8080 → /ip6/::1/tcp/8080/http\n *\n * @param {string} uri - The URI to convert (e.g., \"http://example.com:8080/path\")\n * @returns {string} The multiaddr representation\n */\nexport function convertToRelayUri(uri: string): string {\n    try {\n        // Parse the URI\n        const url = new URL(uri);\n\n        // Determine default port based on protocol\n        const defaultPort = getDefaultPortForProtocol(url.protocol);\n        const port = url.port || defaultPort;\n        const protocol = url.protocol.replace(\":\", \"\");\n\n        // Handle IP addresses and domains\n        let addrType: string;\n        let hostname = url.hostname;\n\n        if (hostname.match(/^\\d+\\.\\d+\\.\\d+\\.\\d+$/)) {\n            // IPv4 address\n            addrType = \"ip4\";\n        } else if (hostname.startsWith(\"[\") && hostname.endsWith(\"]\")) {\n            // IPv6 address in URL format [::1]\n            addrType = \"ip6\";\n            hostname = hostname.slice(1, -1);\n        } else if (hostname.includes(\":\")) {\n            // IPv6 address without brackets\n            addrType = \"ip6\";\n        } else {\n            // Domain name\n            addrType = \"dns4\";\n        }\n\n        // Construct the multiaddr\n        let multiaddr = `/${addrType}/${hostname}/tcp/${port}`;\n\n        // Append protocol if it's not http or https\n        if (![\"http\", \"https\"].includes(protocol)) {\n            // Replace wss with x-parity-wss\n            const protocolToAppend =\n                protocol === \"wss\" ? \"x-parity-wss\" : protocol;\n            multiaddr += `/${protocolToAppend}`;\n        }\n\n        // Add path if it exists and is not just \"/\"\n        if (url.pathname && url.pathname !== \"/\") {\n            multiaddr += `/${encodeURIComponent(url.pathname)}`;\n        }\n\n        return multiaddr;\n    } catch (error) {\n        console.error(\"Invalid URI:\", error);\n        return \"\";\n    }\n}\n"],"mappings":"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","names":["math","multiply","a","b","v","i","floor","step","mod289","x","permute","taylorInvSqrt","r","snoise","C","D","x0","g","l","i1","i2","x1","x2","x3","p1","p2","p","ns","j","x_","y_","y","h","b0","b1","s0","s1","sh","a0","a1","p0","p3","norm","m","recursiveSNoise","pers","octaves","total","frequency","amplitude","maxValue","RecsType","setComponent","poseidonHashMany","byteArray","addAddressPadding","STORE_SET_RECORD_EVENT_NAME","TAG_SEPARATOR","getEvents","receipt","event","setComponentsFromEvents","components","events","setComponentFromEvent","eventData","componentNames","getComponentNames","componentName","getComponentNameFromEvent","component","keysNumber","index","keys","key","entityIndex","getEntityIdFromKeys","numberOfValues","string_keys","values","componentValues","decodeComponent","error","names","c","parseComponentValue","value","type","schema","types","decodeComponentValues","indices","acc","valueType","hexToAscii","hex","str","n","asciiToHex","i","actions","actionFelt","action","parts","splitEventTag","getSelectorFromTag","eventName","toHexString","bn","namespace","computeByteArrayHash","serializeByteArray","word","bytes","poseidon","setComponentsFromGraphQLEntities","entities","entity","setComponentFromGraphQLEntity","entityEdge","model","parsedValue","parseComponentValueFromGraphQLEntity","parsedObject","shortenHex","hexString","numDigits","halfDigits","firstHalf","secondHalf","getDefaultPortForProtocol","protocol","convertToRelayUri","uri","url","defaultPort","port","addrType","hostname","multiaddr"]}