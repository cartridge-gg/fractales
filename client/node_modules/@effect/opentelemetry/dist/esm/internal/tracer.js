import * as OtelApi from "@opentelemetry/api";
import * as OtelSemConv from "@opentelemetry/semantic-conventions";
import * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { constTrue, dual } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as EffectTracer from "effect/Tracer";
import { Resource } from "../Resource.js";
import { nanosToHrTime, recordToAttributes, unknownToAttributeValue } from "./utils.js";
const OtelSpanTypeId = /*#__PURE__*/Symbol.for("@effect/opentelemetry/Tracer/OtelSpan");
const kindMap = {
  "internal": OtelApi.SpanKind.INTERNAL,
  "client": OtelApi.SpanKind.CLIENT,
  "server": OtelApi.SpanKind.SERVER,
  "producer": OtelApi.SpanKind.PRODUCER,
  "consumer": OtelApi.SpanKind.CONSUMER
};
const getOtelParent = (tracer, otelContext, context) => {
  const active = tracer.getSpan(otelContext);
  const otelParent = active ? active.spanContext() : undefined;
  return otelParent ? Option.some(EffectTracer.externalSpan({
    spanId: otelParent.spanId,
    traceId: otelParent.traceId,
    sampled: (otelParent.traceFlags & 1) === 1,
    context
  })) : Option.none();
};
/** @internal */
export class OtelSpan {
  name;
  context;
  links;
  kind;
  [OtelSpanTypeId];
  _tag = "Span";
  span;
  spanId;
  traceId;
  attributes = /*#__PURE__*/new Map();
  sampled;
  parent;
  status;
  constructor(contextApi, traceApi, tracer, name, effectParent, context, links, startTime, kind, options) {
    this.name = name;
    this.context = context;
    this.links = links;
    this.kind = kind;
    this[OtelSpanTypeId] = OtelSpanTypeId;
    const active = contextApi.active();
    this.parent = effectParent._tag === "Some" ? effectParent : options?.root !== true ? getOtelParent(traceApi, active, context) : Option.none();
    this.span = tracer.startSpan(name, {
      startTime: nanosToHrTime(startTime),
      links: links.length > 0 ? links.map(link => ({
        context: makeSpanContext(link.span),
        attributes: recordToAttributes(link.attributes)
      })) : undefined,
      kind: kindMap[this.kind]
    }, this.parent._tag === "Some" ? populateContext(active, this.parent.value, context) : OtelApi.trace.deleteSpan(active));
    const spanContext = this.span.spanContext();
    this.spanId = spanContext.spanId;
    this.traceId = spanContext.traceId;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.sampled = (spanContext.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED;
  }
  attribute(key, value) {
    this.span.setAttribute(key, unknownToAttributeValue(value));
    this.attributes.set(key, value);
  }
  addLinks(links) {
    // eslint-disable-next-line no-restricted-syntax
    this.links.push(...links);
    this.span.addLinks(links.map(link => ({
      context: makeSpanContext(link.span),
      attributes: recordToAttributes(link.attributes)
    })));
  }
  end(endTime, exit) {
    const hrTime = nanosToHrTime(endTime);
    this.status = {
      _tag: "Ended",
      endTime,
      exit,
      startTime: this.status.startTime
    };
    if (exit._tag === "Success") {
      this.span.setStatus({
        code: OtelApi.SpanStatusCode.OK
      });
    } else {
      if (Cause.isInterruptedOnly(exit.cause)) {
        this.span.setStatus({
          code: OtelApi.SpanStatusCode.OK,
          message: Cause.pretty(exit.cause)
        });
        this.span.setAttribute("span.label", "⚠︎ Interrupted");
        this.span.setAttribute("status.interrupted", true);
      } else {
        const firstError = Cause.prettyErrors(exit.cause)[0];
        if (firstError) {
          firstError.stack = Cause.pretty(exit.cause, {
            renderErrorCause: true
          });
          this.span.recordException(firstError, hrTime);
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.ERROR,
            message: firstError.message
          });
        } else {
          // empty cause means no error
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.OK
          });
        }
      }
    }
    this.span.end(hrTime);
  }
  event(name, startTime, attributes) {
    this.span.addEvent(name, attributes ? recordToAttributes(attributes) : undefined, nanosToHrTime(startTime));
  }
}
/** @internal */
export const TracerProvider = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTracerProvider");
/** @internal */
export const Tracer = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTracer");
/** @internal */
export const make = /*#__PURE__*/Effect.map(Tracer, tracer => EffectTracer.make({
  span(name, parent, context, links, startTime, kind, options) {
    return new OtelSpan(OtelApi.context, OtelApi.trace, tracer, name, parent, context, links.slice(), startTime, kind, options);
  },
  context(execution, fiber) {
    const currentSpan = fiber.currentSpan;
    if (currentSpan === undefined) {
      return execution();
    }
    return OtelApi.context.with(populateContext(OtelApi.context.active(), currentSpan), execution);
  }
}));
/** @internal */
export const traceFlagsTag = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTraceFlags");
/** @internal */
export const traceStateTag = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTraceState");
/** @internal */
export const makeExternalSpan = options => {
  let context = Context.empty();
  if (options.traceFlags !== undefined) {
    context = Context.add(context, traceFlagsTag, options.traceFlags);
  }
  if (typeof options.traceState === "string") {
    context = Option.match(createTraceState(options.traceState), {
      onNone: () => context,
      onSome: traceState => Context.add(context, traceStateTag, traceState)
    });
  } else if (options.traceState) {
    context = Context.add(context, traceStateTag, options.traceState);
  }
  return {
    _tag: "ExternalSpan",
    traceId: options.traceId,
    spanId: options.spanId,
    sampled: options.traceFlags !== undefined ? (options.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED : true,
    context
  };
};
const makeOtelSpan = (span, clock) => {
  const spanContext = {
    traceId: span.traceId,
    spanId: span.spanId,
    traceFlags: span.sampled ? OtelApi.TraceFlags.SAMPLED : OtelApi.TraceFlags.NONE,
    isRemote: false
  };
  let exit = Exit.void;
  const self = {
    spanContext: () => spanContext,
    setAttribute(key, value) {
      span.attribute(key, value);
      return self;
    },
    setAttributes(attributes) {
      for (const [key, value] of Object.entries(attributes)) {
        span.attribute(key, value);
      }
      return self;
    },
    addEvent(name) {
      let attributes = undefined;
      let startTime = undefined;
      if (arguments.length === 3) {
        attributes = arguments[1];
        startTime = arguments[2];
      } else {
        startTime = arguments[1];
      }
      span.event(name, convertOtelTimeInput(startTime, clock), attributes);
      return self;
    },
    addLink(link) {
      span.addLinks([{
        _tag: "SpanLink",
        span: makeExternalSpan(link.context),
        attributes: link.attributes ?? {}
      }]);
      return self;
    },
    addLinks(links) {
      span.addLinks(links.map(link => ({
        _tag: "SpanLink",
        span: makeExternalSpan(link.context),
        attributes: link.attributes ?? {}
      })));
      return self;
    },
    setStatus(status) {
      exit = OtelApi.SpanStatusCode.ERROR ? Exit.die(status.message ?? "Unknown error") : Exit.void;
      return self;
    },
    updateName: () => self,
    end(endTime) {
      const time = convertOtelTimeInput(endTime, clock);
      span.end(time, exit);
      return self;
    },
    isRecording: constTrue,
    recordException(exception, timeInput) {
      const time = convertOtelTimeInput(timeInput, clock);
      const cause = Cause.fail(exception);
      const error = Cause.prettyErrors(cause)[0];
      span.event(error.message, time, {
        "exception.type": error.name,
        "exception.message": error.message,
        "exception.stacktrace": error.stack ?? ""
      });
    }
  };
  return self;
};
const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
const bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);
const convertOtelTimeInput = (input, clock) => {
  if (input === undefined) {
    return clock.unsafeCurrentTimeNanos();
  } else if (typeof input === "number") {
    return BigInt(Math.round(input * 1_000_000));
  } else if (input instanceof Date) {
    return BigInt(input.getTime()) * bigint1e6;
  }
  const [seconds, nanos] = input;
  return BigInt(seconds) * bigint1e9 + BigInt(nanos);
};
/** @internal */
export const currentOtelSpan = /*#__PURE__*/Effect.clockWith(clock => Effect.map(Effect.currentSpan, span => {
  if (OtelSpanTypeId in span) {
    return span.span;
  }
  return makeOtelSpan(span, clock);
}));
/** @internal */
export const layerGlobalProvider = /*#__PURE__*/Layer.sync(TracerProvider, () => OtelApi.trace.getTracerProvider());
/** @internal */
export const layerTracer = /*#__PURE__*/Layer.effect(Tracer, /*#__PURE__*/Effect.flatMap(/*#__PURE__*/Effect.zip(Resource, TracerProvider), ([resource, provider]) => Effect.sync(() => provider.getTracer(resource.attributes[OtelSemConv.ATTR_SERVICE_NAME], resource.attributes[OtelSemConv.ATTR_SERVICE_VERSION]))));
/** @internal */
export const layerGlobalTracer = /*#__PURE__*/layerTracer.pipe(/*#__PURE__*/Layer.provide(layerGlobalProvider));
/** @internal */
export const layerGlobal = /*#__PURE__*/Layer.unwrapEffect(Effect.map(make, Layer.setTracer)).pipe(/*#__PURE__*/Layer.provideMerge(layerGlobalTracer));
/** @internal */
export const layerWithoutOtelTracer = /*#__PURE__*/Layer.unwrapEffect(/*#__PURE__*/Effect.map(make, Layer.setTracer));
/** @internal */
export const layer = /*#__PURE__*/layerWithoutOtelTracer.pipe(/*#__PURE__*/Layer.provideMerge(layerTracer));
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
const createTraceState = /*#__PURE__*/Option.liftThrowable(OtelApi.createTraceState);
const populateContext = (otelContext, span, context) => span instanceof OtelSpan ? OtelApi.trace.setSpan(otelContext, span.span) : OtelApi.trace.setSpanContext(otelContext, makeSpanContext(span, context));
const makeSpanContext = (span, context) => ({
  spanId: span.spanId,
  traceId: span.traceId,
  isRemote: span._tag === "ExternalSpan",
  traceFlags: Option.getOrElse(context ? extractTraceTag(span, context, traceFlagsTag) : Context.getOption(span.context, traceFlagsTag), () => OtelApi.TraceFlags.SAMPLED),
  traceState: Option.getOrUndefined(context ? extractTraceTag(span, context, traceStateTag) : Context.getOption(span.context, traceStateTag))
});
const extractTraceTag = (parent, context, tag) => Option.orElse(Context.getOption(context, tag), () => Context.getOption(parent.context, tag));
/** @internal */
export const withSpanContext = /*#__PURE__*/dual(2, (effect, spanContext) => Effect.withParentSpan(effect, makeExternalSpan(spanContext)));
//# sourceMappingURL=tracer.js.map